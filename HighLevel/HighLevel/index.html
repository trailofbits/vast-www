<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>HighLevel - VAST: MLIR for Program Analysis</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "HighLevel";
        var mkdocs_page_input_path = "HighLevel/HighLevel.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> VAST: MLIR for Program Analysis
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">VAST: MLIR for Program Analysis</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">HighLevel</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/trailofbits/vast/edit/master/docs/HighLevel/HighLevel.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <!-- Autogenerated by mlir-tblgen; don't manually edit -->
<h1 id="hl-dialect">'hl' Dialect</h1>
<p>A high-level verbose program analysis MLIR dialect.
This dialect intends capture highevel constructs of C/C++
for further program analysis.</p>
<div class="toc">
<ul>
<li><a href="#hl-dialect">'hl' Dialect</a><ul>
<li><a href="#operation-definition">Operation definition</a><ul>
<li><a href="#hlaccess-vasthlaccessspecifierop">hl.access (::vast::hl::AccessSpecifierOp)</a><ul>
<li><a href="#attributes">Attributes:</a></li>
</ul>
</li>
<li><a href="#hlassignfadd-vasthladdfassignop">hl.assign.fadd (::vast::hl::AddFAssignOp)</a><ul>
<li><a href="#operands">Operands:</a></li>
<li><a href="#results">Results:</a></li>
</ul>
</li>
<li><a href="#hlfadd-vasthladdfop">hl.fadd (::vast::hl::AddFOp)</a><ul>
<li><a href="#operands_1">Operands:</a></li>
<li><a href="#results_1">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignadd-vasthladdiassignop">hl.assign.add (::vast::hl::AddIAssignOp)</a><ul>
<li><a href="#operands_2">Operands:</a></li>
<li><a href="#results_2">Results:</a></li>
</ul>
</li>
<li><a href="#hladd-vasthladdiop">hl.add (::vast::hl::AddIOp)</a><ul>
<li><a href="#operands_3">Operands:</a></li>
<li><a href="#results_3">Results:</a></li>
</ul>
</li>
<li><a href="#hllabeladdr-vasthladdrlabelexpr">hl.labeladdr (::vast::hl::AddrLabelExpr)</a><ul>
<li><a href="#operands_4">Operands:</a></li>
<li><a href="#results_4">Results:</a></li>
</ul>
</li>
<li><a href="#hladdressof-vasthladdressof">hl.addressof (::vast::hl::AddressOf)</a><ul>
<li><a href="#operands_5">Operands:</a></li>
<li><a href="#results_5">Results:</a></li>
</ul>
</li>
<li><a href="#hlalignofexpr-vasthlalignofexprop">hl.alignof.expr (::vast::hl::AlignOfExprOp)</a><ul>
<li><a href="#results_6">Results:</a></li>
</ul>
</li>
<li><a href="#hlalignoftype-vasthlalignoftypeop">hl.alignof.type (::vast::hl::AlignOfTypeOp)</a><ul>
<li><a href="#attributes_1">Attributes:</a></li>
<li><a href="#results_7">Results:</a></li>
</ul>
</li>
<li><a href="#hlassign-vasthlassignop">hl.assign (::vast::hl::AssignOp)</a><ul>
<li><a href="#operands_6">Operands:</a></li>
<li><a href="#results_8">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignbinand-vasthlbinandassignop">hl.assign.bin.and (::vast::hl::BinAndAssignOp)</a><ul>
<li><a href="#operands_7">Operands:</a></li>
<li><a href="#results_9">Results:</a></li>
</ul>
</li>
<li><a href="#hlbinand-vasthlbinandop">hl.bin.and (::vast::hl::BinAndOp)</a><ul>
<li><a href="#operands_8">Operands:</a></li>
<li><a href="#results_10">Results:</a></li>
</ul>
</li>
<li><a href="#hlbincomma-vasthlbincomma">hl.bin.comma (::vast::hl::BinComma)</a><ul>
<li><a href="#operands_9">Operands:</a></li>
<li><a href="#results_11">Results:</a></li>
</ul>
</li>
<li><a href="#hlbinland-vasthlbinlandop">hl.bin.land (::vast::hl::BinLAndOp)</a><ul>
<li><a href="#results_12">Results:</a></li>
</ul>
</li>
<li><a href="#hlbinlor-vasthlbinlorop">hl.bin.lor (::vast::hl::BinLOrOp)</a><ul>
<li><a href="#results_13">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignbinor-vasthlbinorassignop">hl.assign.bin.or (::vast::hl::BinOrAssignOp)</a><ul>
<li><a href="#operands_10">Operands:</a></li>
<li><a href="#results_14">Results:</a></li>
</ul>
</li>
<li><a href="#hlbinor-vasthlbinorop">hl.bin.or (::vast::hl::BinOrOp)</a><ul>
<li><a href="#operands_11">Operands:</a></li>
<li><a href="#results_15">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignbinshl-vasthlbinshlassignop">hl.assign.bin.shl (::vast::hl::BinShlAssignOp)</a><ul>
<li><a href="#operands_12">Operands:</a></li>
<li><a href="#results_16">Results:</a></li>
</ul>
</li>
<li><a href="#hlbinshl-vasthlbinshlop">hl.bin.shl (::vast::hl::BinShlOp)</a><ul>
<li><a href="#operands_13">Operands:</a></li>
<li><a href="#results_17">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignbinshr-vasthlbinshrassignop">hl.assign.bin.shr (::vast::hl::BinShrAssignOp)</a><ul>
<li><a href="#operands_14">Operands:</a></li>
<li><a href="#results_18">Results:</a></li>
</ul>
</li>
<li><a href="#hlbinshr-vasthlbinshrop">hl.bin.shr (::vast::hl::BinShrOp)</a><ul>
<li><a href="#operands_15">Operands:</a></li>
<li><a href="#results_19">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignbinxor-vasthlbinxorassignop">hl.assign.bin.xor (::vast::hl::BinXorAssignOp)</a><ul>
<li><a href="#operands_16">Operands:</a></li>
<li><a href="#results_20">Results:</a></li>
</ul>
</li>
<li><a href="#hlbinxor-vasthlbinxorop">hl.bin.xor (::vast::hl::BinXorOp)</a><ul>
<li><a href="#operands_17">Operands:</a></li>
<li><a href="#results_21">Results:</a></li>
</ul>
</li>
<li><a href="#hlbuiltin_bitcast-vasthlbuiltinbitcastop">hl.builtin_bitcast (::vast::hl::BuiltinBitCastOp)</a><ul>
<li><a href="#attributes_2">Attributes:</a></li>
<li><a href="#operands_18">Operands:</a></li>
<li><a href="#results_22">Results:</a></li>
</ul>
</li>
<li><a href="#hlcstyle_cast-vasthlcstylecastop">hl.cstyle_cast (::vast::hl::CStyleCastOp)</a><ul>
<li><a href="#attributes_3">Attributes:</a></li>
<li><a href="#operands_19">Operands:</a></li>
<li><a href="#results_23">Results:</a></li>
</ul>
</li>
<li><a href="#hlcall-vasthlcallop">hl.call (::vast::hl::CallOp)</a><ul>
<li><a href="#attributes_4">Attributes:</a></li>
<li><a href="#operands_20">Operands:</a></li>
<li><a href="#results_24">Results:</a></li>
</ul>
</li>
<li><a href="#hlclass-vasthlclassdeclop">hl.class (::vast::hl::ClassDeclOp)</a><ul>
<li><a href="#attributes_5">Attributes:</a></li>
</ul>
</li>
<li><a href="#hlcmp-vasthlcmpop">hl.cmp (::vast::hl::CmpOp)</a><ul>
<li><a href="#attributes_6">Attributes:</a></li>
<li><a href="#operands_21">Operands:</a></li>
<li><a href="#results_25">Results:</a></li>
</ul>
</li>
<li><a href="#hlconst-vasthlconstantop">hl.const (::vast::hl::ConstantOp)</a><ul>
<li><a href="#attributes_7">Attributes:</a></li>
<li><a href="#results_26">Results:</a></li>
</ul>
</li>
<li><a href="#hlbase-vasthlcxxbasespecifierop">hl.base (::vast::hl::CxxBaseSpecifierOp)</a><ul>
<li><a href="#attributes_8">Attributes:</a></li>
</ul>
</li>
<li><a href="#hlcxxstruct-vasthlcxxstructdeclop">hl.cxxstruct (::vast::hl::CxxStructDeclOp)</a><ul>
<li><a href="#attributes_9">Attributes:</a></li>
</ul>
</li>
<li><a href="#hlref-vasthldeclrefop">hl.ref (::vast::hl::DeclRefOp)</a><ul>
<li><a href="#operands_22">Operands:</a></li>
<li><a href="#results_27">Results:</a></li>
</ul>
</li>
<li><a href="#hlderef-vasthlderef">hl.deref (::vast::hl::Deref)</a><ul>
<li><a href="#operands_23">Operands:</a></li>
<li><a href="#results_28">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignfdiv-vasthldivfassignop">hl.assign.fdiv (::vast::hl::DivFAssignOp)</a><ul>
<li><a href="#operands_24">Operands:</a></li>
<li><a href="#results_29">Results:</a></li>
</ul>
</li>
<li><a href="#hlfdiv-vasthldivfop">hl.fdiv (::vast::hl::DivFOp)</a><ul>
<li><a href="#operands_25">Operands:</a></li>
<li><a href="#results_30">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignsdiv-vasthldivsassignop">hl.assign.sdiv (::vast::hl::DivSAssignOp)</a><ul>
<li><a href="#operands_26">Operands:</a></li>
<li><a href="#results_31">Results:</a></li>
</ul>
</li>
<li><a href="#hlsdiv-vasthldivsop">hl.sdiv (::vast::hl::DivSOp)</a><ul>
<li><a href="#operands_27">Operands:</a></li>
<li><a href="#results_32">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignudiv-vasthldivuassignop">hl.assign.udiv (::vast::hl::DivUAssignOp)</a><ul>
<li><a href="#operands_28">Operands:</a></li>
<li><a href="#results_33">Results:</a></li>
</ul>
</li>
<li><a href="#hludiv-vasthldivuop">hl.udiv (::vast::hl::DivUOp)</a><ul>
<li><a href="#operands_29">Operands:</a></li>
<li><a href="#results_34">Results:</a></li>
</ul>
</li>
<li><a href="#hlenumconst-vasthlenumconstantop">hl.enum.const (::vast::hl::EnumConstantOp)</a><ul>
<li><a href="#attributes_10">Attributes:</a></li>
</ul>
</li>
<li><a href="#hlenum-vasthlenumdeclop">hl.enum (::vast::hl::EnumDeclOp)</a><ul>
<li><a href="#attributes_11">Attributes:</a></li>
</ul>
</li>
<li><a href="#hlenumref-vasthlenumrefop">hl.enumref (::vast::hl::EnumRefOp)</a><ul>
<li><a href="#attributes_12">Attributes:</a></li>
<li><a href="#results_35">Results:</a></li>
</ul>
</li>
<li><a href="#hlexpr-vasthlexprop">hl.expr (::vast::hl::ExprOp)</a><ul>
<li><a href="#results_36">Results:</a></li>
</ul>
</li>
<li><a href="#hlgnuextension-vasthlextensionop">hl.gnu.extension (::vast::hl::ExtensionOp)</a><ul>
<li><a href="#operands_30">Operands:</a></li>
<li><a href="#results_37">Results:</a></li>
</ul>
</li>
<li><a href="#hlfcmp-vasthlfcmpop">hl.fcmp (::vast::hl::FCmpOp)</a><ul>
<li><a href="#attributes_13">Attributes:</a></li>
<li><a href="#operands_31">Operands:</a></li>
<li><a href="#results_38">Results:</a></li>
</ul>
</li>
<li><a href="#hlfield-vasthlfielddeclop">hl.field (::vast::hl::FieldDeclOp)</a><ul>
<li><a href="#attributes_14">Attributes:</a></li>
</ul>
</li>
<li><a href="#hlfunc-vasthlfuncop">hl.func (::vast::hl::FuncOp)</a><ul>
<li><a href="#attributes_15">Attributes:</a></li>
</ul>
</li>
<li><a href="#hlfuncref-vasthlfuncrefop">hl.funcref (::vast::hl::FuncRefOp)</a><ul>
<li><a href="#attributes_16">Attributes:</a></li>
<li><a href="#results_39">Results:</a></li>
</ul>
</li>
<li><a href="#hlglobref-vasthlglobalrefop">hl.globref (::vast::hl::GlobalRefOp)</a><ul>
<li><a href="#attributes_17">Attributes:</a></li>
<li><a href="#results_40">Results:</a></li>
</ul>
</li>
<li><a href="#hlbreak-vasthlbreakop">hl.break (::vast::hl::BreakOp)</a></li>
<li><a href="#hlcase-vasthlcaseop">hl.case (::vast::hl::CaseOp)</a></li>
<li><a href="#hlcond-vasthlcondop">hl.cond (::vast::hl::CondOp)</a><ul>
<li><a href="#results_41">Results:</a></li>
</ul>
</li>
<li><a href="#hlcondyield-vasthlcondyieldop">hl.cond.yield (::vast::hl::CondYieldOp)</a><ul>
<li><a href="#operands_32">Operands:</a></li>
</ul>
</li>
<li><a href="#hlcontinue-vasthlcontinueop">hl.continue (::vast::hl::ContinueOp)</a></li>
<li><a href="#hldefault-vasthldefaultop">hl.default (::vast::hl::DefaultOp)</a></li>
<li><a href="#hldo-vasthldoop">hl.do (::vast::hl::DoOp)</a></li>
<li><a href="#hlfor-vasthlforop">hl.for (::vast::hl::ForOp)</a></li>
<li><a href="#hlgoto-vasthlgotostmt">hl.goto (::vast::hl::GotoStmt)</a><ul>
<li><a href="#operands_33">Operands:</a></li>
</ul>
</li>
<li><a href="#hlif-vasthlifop">hl.if (::vast::hl::IfOp)</a></li>
<li><a href="#hllabeldecl-vasthllabeldeclop">hl.label.decl (::vast::hl::LabelDeclOp)</a><ul>
<li><a href="#attributes_18">Attributes:</a></li>
<li><a href="#results_42">Results:</a></li>
</ul>
</li>
<li><a href="#hllabel-vasthllabelstmt">hl.label (::vast::hl::LabelStmt)</a><ul>
<li><a href="#operands_34">Operands:</a></li>
</ul>
</li>
<li><a href="#hlskip-vasthlskipstmt">hl.skip (::vast::hl::SkipStmt)</a></li>
<li><a href="#hlswitch-vasthlswitchop">hl.switch (::vast::hl::SwitchOp)</a></li>
<li><a href="#hlvalueyield-vasthlvalueyieldop">hl.value.yield (::vast::hl::ValueYieldOp)</a><ul>
<li><a href="#operands_35">Operands:</a></li>
</ul>
</li>
<li><a href="#hlvar-vasthlvardeclop">hl.var (::vast::hl::VarDeclOp)</a><ul>
<li><a href="#attributes_19">Attributes:</a></li>
<li><a href="#results_43">Results:</a></li>
</ul>
</li>
<li><a href="#hlwhile-vasthlwhileop">hl.while (::vast::hl::WhileOp)</a></li>
<li><a href="#hlimplicit_cast-vasthlimplicitcastop">hl.implicit_cast (::vast::hl::ImplicitCastOp)</a><ul>
<li><a href="#attributes_20">Attributes:</a></li>
<li><a href="#operands_36">Operands:</a></li>
<li><a href="#results_44">Results:</a></li>
</ul>
</li>
<li><a href="#hlindirect_call-vasthlindirectcallop">hl.indirect_call (::vast::hl::IndirectCallOp)</a><ul>
<li><a href="#operands_37">Operands:</a></li>
<li><a href="#results_45">Results:</a></li>
</ul>
</li>
<li><a href="#hlinitlist-vasthlinitlistexpr">hl.initlist (::vast::hl::InitListExpr)</a><ul>
<li><a href="#operands_38">Operands:</a></li>
<li><a href="#results_46">Results:</a></li>
</ul>
</li>
<li><a href="#hllnot-vasthllnotop">hl.lnot (::vast::hl::LNotOp)</a><ul>
<li><a href="#operands_39">Operands:</a></li>
<li><a href="#results_47">Results:</a></li>
</ul>
</li>
<li><a href="#hlminus-vasthlminusop">hl.minus (::vast::hl::MinusOp)</a><ul>
<li><a href="#operands_40">Operands:</a></li>
<li><a href="#results_48">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignfmul-vasthlmulfassignop">hl.assign.fmul (::vast::hl::MulFAssignOp)</a><ul>
<li><a href="#operands_41">Operands:</a></li>
<li><a href="#results_49">Results:</a></li>
</ul>
</li>
<li><a href="#hlfmul-vasthlmulfop">hl.fmul (::vast::hl::MulFOp)</a><ul>
<li><a href="#operands_42">Operands:</a></li>
<li><a href="#results_50">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignmul-vasthlmuliassignop">hl.assign.mul (::vast::hl::MulIAssignOp)</a><ul>
<li><a href="#operands_43">Operands:</a></li>
<li><a href="#results_51">Results:</a></li>
</ul>
</li>
<li><a href="#hlmul-vasthlmuliop">hl.mul (::vast::hl::MulIOp)</a><ul>
<li><a href="#operands_44">Operands:</a></li>
<li><a href="#results_52">Results:</a></li>
</ul>
</li>
<li><a href="#hlnot-vasthlnotop">hl.not (::vast::hl::NotOp)</a><ul>
<li><a href="#operands_45">Operands:</a></li>
<li><a href="#results_53">Results:</a></li>
</ul>
</li>
<li><a href="#hlplus-vasthlplusop">hl.plus (::vast::hl::PlusOp)</a><ul>
<li><a href="#operands_46">Operands:</a></li>
<li><a href="#results_54">Results:</a></li>
</ul>
</li>
<li><a href="#hlpostdec-vasthlpostdecop">hl.post.dec (::vast::hl::PostDecOp)</a><ul>
<li><a href="#operands_47">Operands:</a></li>
<li><a href="#results_55">Results:</a></li>
</ul>
</li>
<li><a href="#hlpostinc-vasthlpostincop">hl.post.inc (::vast::hl::PostIncOp)</a><ul>
<li><a href="#operands_48">Operands:</a></li>
<li><a href="#results_56">Results:</a></li>
</ul>
</li>
<li><a href="#hlpredec-vasthlpredecop">hl.pre.dec (::vast::hl::PreDecOp)</a><ul>
<li><a href="#operands_49">Operands:</a></li>
<li><a href="#results_57">Results:</a></li>
</ul>
</li>
<li><a href="#hlpreinc-vasthlpreincop">hl.pre.inc (::vast::hl::PreIncOp)</a><ul>
<li><a href="#operands_50">Operands:</a></li>
<li><a href="#results_58">Results:</a></li>
</ul>
</li>
<li><a href="#hlpredefinedexpr-vasthlpredefinedexpr">hl.predefined.expr (::vast::hl::PredefinedExpr)</a><ul>
<li><a href="#attributes_21">Attributes:</a></li>
<li><a href="#operands_51">Operands:</a></li>
<li><a href="#results_59">Results:</a></li>
</ul>
</li>
<li><a href="#hlmember-vasthlrecordmemberop">hl.member (::vast::hl::RecordMemberOp)</a><ul>
<li><a href="#attributes_22">Attributes:</a></li>
<li><a href="#operands_52">Operands:</a></li>
<li><a href="#results_60">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignfrem-vasthlremfassignop">hl.assign.frem (::vast::hl::RemFAssignOp)</a><ul>
<li><a href="#operands_53">Operands:</a></li>
<li><a href="#results_61">Results:</a></li>
</ul>
</li>
<li><a href="#hlfrem-vasthlremfop">hl.frem (::vast::hl::RemFOp)</a><ul>
<li><a href="#operands_54">Operands:</a></li>
<li><a href="#results_62">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignsrem-vasthlremsassignop">hl.assign.srem (::vast::hl::RemSAssignOp)</a><ul>
<li><a href="#operands_55">Operands:</a></li>
<li><a href="#results_63">Results:</a></li>
</ul>
</li>
<li><a href="#hlsrem-vasthlremsop">hl.srem (::vast::hl::RemSOp)</a><ul>
<li><a href="#operands_56">Operands:</a></li>
<li><a href="#results_64">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignurem-vasthlremuassignop">hl.assign.urem (::vast::hl::RemUAssignOp)</a><ul>
<li><a href="#operands_57">Operands:</a></li>
<li><a href="#results_65">Results:</a></li>
</ul>
</li>
<li><a href="#hlurem-vasthlremuop">hl.urem (::vast::hl::RemUOp)</a><ul>
<li><a href="#operands_58">Operands:</a></li>
<li><a href="#results_66">Results:</a></li>
</ul>
</li>
<li><a href="#hlreturn-vasthlreturnop">hl.return (::vast::hl::ReturnOp)</a><ul>
<li><a href="#operands_59">Operands:</a></li>
</ul>
</li>
<li><a href="#hlscope-vasthlscopeop">hl.scope (::vast::hl::ScopeOp)</a></li>
<li><a href="#hlsizeofexpr-vasthlsizeofexprop">hl.sizeof.expr (::vast::hl::SizeOfExprOp)</a><ul>
<li><a href="#results_67">Results:</a></li>
</ul>
</li>
<li><a href="#hlsizeoftype-vasthlsizeoftypeop">hl.sizeof.type (::vast::hl::SizeOfTypeOp)</a><ul>
<li><a href="#attributes_23">Attributes:</a></li>
<li><a href="#results_68">Results:</a></li>
</ul>
</li>
<li><a href="#hlstmtexpr-vasthlstmtexprop">hl.stmt.expr (::vast::hl::StmtExprOp)</a><ul>
<li><a href="#results_69">Results:</a></li>
</ul>
</li>
<li><a href="#hlstruct-vasthlstructdeclop">hl.struct (::vast::hl::StructDeclOp)</a><ul>
<li><a href="#attributes_24">Attributes:</a></li>
</ul>
</li>
<li><a href="#hlassignfsub-vasthlsubfassignop">hl.assign.fsub (::vast::hl::SubFAssignOp)</a><ul>
<li><a href="#operands_60">Operands:</a></li>
<li><a href="#results_70">Results:</a></li>
</ul>
</li>
<li><a href="#hlfsub-vasthlsubfop">hl.fsub (::vast::hl::SubFOp)</a><ul>
<li><a href="#operands_61">Operands:</a></li>
<li><a href="#results_71">Results:</a></li>
</ul>
</li>
<li><a href="#hlassignsub-vasthlsubiassignop">hl.assign.sub (::vast::hl::SubIAssignOp)</a><ul>
<li><a href="#operands_62">Operands:</a></li>
<li><a href="#results_72">Results:</a></li>
</ul>
</li>
<li><a href="#hlsub-vasthlsubiop">hl.sub (::vast::hl::SubIOp)</a><ul>
<li><a href="#operands_63">Operands:</a></li>
<li><a href="#results_73">Results:</a></li>
</ul>
</li>
<li><a href="#hlsubscript-vasthlsubscriptop">hl.subscript (::vast::hl::SubscriptOp)</a><ul>
<li><a href="#operands_64">Operands:</a></li>
<li><a href="#results_74">Results:</a></li>
</ul>
</li>
<li><a href="#hlthis-vasthlthisop">hl.this (::vast::hl::ThisOp)</a><ul>
<li><a href="#results_75">Results:</a></li>
</ul>
</li>
<li><a href="#hltranslation_unit-vasthltranslationunitop">hl.translation_unit (::vast::hl::TranslationUnitOp)</a></li>
<li><a href="#hltype-vasthltypedeclop">hl.type (::vast::hl::TypeDeclOp)</a><ul>
<li><a href="#attributes_25">Attributes:</a></li>
</ul>
</li>
<li><a href="#hltypedef-vasthltypedefop">hl.typedef (::vast::hl::TypeDefOp)</a><ul>
<li><a href="#attributes_26">Attributes:</a></li>
</ul>
</li>
<li><a href="#hlunion-vasthluniondeclop">hl.union (::vast::hl::UnionDeclOp)</a><ul>
<li><a href="#attributes_27">Attributes:</a></li>
</ul>
</li>
<li><a href="#hlunreachable-vasthlunreachableop">hl.unreachable (::vast::hl::UnreachableOp)</a></li>
</ul>
</li>
<li><a href="#attribute-definition">Attribute definition</a><ul>
<li><a href="#annotationattr">AnnotationAttr</a><ul>
<li><a href="#parameters">Parameters:</a></li>
</ul>
</li>
<li><a href="#booleanattr">BooleanAttr</a><ul>
<li><a href="#parameters_1">Parameters:</a></li>
</ul>
</li>
<li><a href="#cvqualifiersattr">CVQualifiersAttr</a><ul>
<li><a href="#parameters_2">Parameters:</a></li>
</ul>
</li>
<li><a href="#cvrqualifiersattr">CVRQualifiersAttr</a><ul>
<li><a href="#parameters_3">Parameters:</a></li>
</ul>
</li>
<li><a href="#floatattr">FloatAttr</a><ul>
<li><a href="#parameters_4">Parameters:</a></li>
</ul>
</li>
<li><a href="#integerattr">IntegerAttr</a><ul>
<li><a href="#parameters_5">Parameters:</a></li>
</ul>
</li>
<li><a href="#stringattr">StringAttr</a><ul>
<li><a href="#parameters_6">Parameters:</a></li>
</ul>
</li>
<li><a href="#stringliteralattr">StringLiteralAttr</a><ul>
<li><a href="#parameters_7">Parameters:</a></li>
</ul>
</li>
<li><a href="#ucvqualifiersattr">UCVQualifiersAttr</a><ul>
<li><a href="#parameters_8">Parameters:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#type-definition">Type definition</a><ul>
<li><a href="#adjustedtype">AdjustedType</a><ul>
<li><a href="#parameters_9">Parameters:</a></li>
</ul>
</li>
<li><a href="#arraytype">ArrayType</a><ul>
<li><a href="#parameters_10">Parameters:</a></li>
</ul>
</li>
<li><a href="#attributedtype">AttributedType</a><ul>
<li><a href="#parameters_11">Parameters:</a></li>
</ul>
</li>
<li><a href="#bfloat16type">BFloat16Type</a><ul>
<li><a href="#parameters_12">Parameters:</a></li>
</ul>
</li>
<li><a href="#booltype">BoolType</a><ul>
<li><a href="#parameters_13">Parameters:</a></li>
</ul>
</li>
<li><a href="#chartype">CharType</a><ul>
<li><a href="#parameters_14">Parameters:</a></li>
</ul>
</li>
<li><a href="#decayedtype">DecayedType</a><ul>
<li><a href="#parameters_15">Parameters:</a></li>
</ul>
</li>
<li><a href="#doubletype">DoubleType</a><ul>
<li><a href="#parameters_16">Parameters:</a></li>
</ul>
</li>
<li><a href="#elaboratedtype">ElaboratedType</a><ul>
<li><a href="#parameters_17">Parameters:</a></li>
</ul>
</li>
<li><a href="#enumtype">EnumType</a><ul>
<li><a href="#parameters_18">Parameters:</a></li>
</ul>
</li>
<li><a href="#float128type">Float128Type</a><ul>
<li><a href="#parameters_19">Parameters:</a></li>
</ul>
</li>
<li><a href="#floattype">FloatType</a><ul>
<li><a href="#parameters_20">Parameters:</a></li>
</ul>
</li>
<li><a href="#halftype">HalfType</a><ul>
<li><a href="#parameters_21">Parameters:</a></li>
</ul>
</li>
<li><a href="#int128type">Int128Type</a><ul>
<li><a href="#parameters_22">Parameters:</a></li>
</ul>
</li>
<li><a href="#inttype">IntType</a><ul>
<li><a href="#parameters_23">Parameters:</a></li>
</ul>
</li>
<li><a href="#lvaluetype">LValueType</a><ul>
<li><a href="#parameters_24">Parameters:</a></li>
</ul>
</li>
<li><a href="#labeltype">LabelType</a></li>
<li><a href="#longdoubletype">LongDoubleType</a><ul>
<li><a href="#parameters_25">Parameters:</a></li>
</ul>
</li>
<li><a href="#longlongtype">LongLongType</a><ul>
<li><a href="#parameters_26">Parameters:</a></li>
</ul>
</li>
<li><a href="#longtype">LongType</a><ul>
<li><a href="#parameters_27">Parameters:</a></li>
</ul>
</li>
<li><a href="#parentype">ParenType</a><ul>
<li><a href="#parameters_28">Parameters:</a></li>
</ul>
</li>
<li><a href="#pointertype">PointerType</a><ul>
<li><a href="#parameters_29">Parameters:</a></li>
</ul>
</li>
<li><a href="#rvaluetype">RValueType</a><ul>
<li><a href="#parameters_30">Parameters:</a></li>
</ul>
</li>
<li><a href="#recordtype">RecordType</a><ul>
<li><a href="#parameters_31">Parameters:</a></li>
</ul>
</li>
<li><a href="#referencetype">ReferenceType</a><ul>
<li><a href="#parameters_32">Parameters:</a></li>
</ul>
</li>
<li><a href="#shorttype">ShortType</a><ul>
<li><a href="#parameters_33">Parameters:</a></li>
</ul>
</li>
<li><a href="#typedeftype">TypedefType</a><ul>
<li><a href="#parameters_34">Parameters:</a></li>
</ul>
</li>
<li><a href="#voidtype">VoidType</a><ul>
<li><a href="#parameters_35">Parameters:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="operation-definition">Operation definition</h2>
<h3 id="hlaccess-vasthlaccessspecifierop"><code>hl.access</code> (::vast::hl::AccessSpecifierOp)</h3>
<p>VAST C++ access specifier declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.access` attr-dict $spec
</code></pre>
<p>VAST C++ access specifier declaration</p>
<h4 id="attributes">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>spec</code></td>
<td style="text-align: center;">::vast::hl::AccessSpecifierAttr</td>
<td>Access specifier</td>
</tr>
</tbody>
</table>
<h3 id="hlassignfadd-vasthladdfassignop"><code>hl.assign.fadd</code> (::vast::hl::AddFAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.fadd` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlfadd-vasthladdfop"><code>hl.fadd</code> (::vast::hl::AddFOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.fadd` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_1">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_1">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignadd-vasthladdiassignop"><code>hl.assign.add</code> (::vast::hl::AddIAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.add` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_2">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_2">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hladd-vasthladdiop"><code>hl.add</code> (::vast::hl::AddIOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.add` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<p>Traits: Commutative</p>
<h4 id="operands_3">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_3">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hllabeladdr-vasthladdrlabelexpr"><code>hl.labeladdr</code> (::vast::hl::AddrLabelExpr)</h3>
<p>VAST address of label extension</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.labeladdr` $label attr-dict `:` type($result)
</code></pre>
<p>VAST address of label extension</p>
<h4 id="operands_4">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>label</code></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="results_4">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>lvalue to pointer like type</td>
</tr>
</tbody>
</table>
<h3 id="hladdressof-vasthladdressof"><code>hl.addressof</code> (::vast::hl::AddressOf)</h3>
<p>VAST addressof operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.addressof` $value attr-dict `:` type($value) `-&gt;` type($result)
</code></pre>
<p>VAST addressof operation</p>
<h4 id="operands_5">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>value</code></td>
<td>lvalue to any type</td>
</tr>
</tbody>
</table>
<h4 id="results_5">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlalignofexpr-vasthlalignofexprop"><code>hl.alignof.expr</code> (::vast::hl::AlignOfExprOp)</h3>
<p>VAST expr alignof operator</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.alignof.expr` attr-dict `-&gt;` type($result) $expr
</code></pre>
<p>VAST expr alignof operator</p>
<h4 id="results_6">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>integer like type</td>
</tr>
</tbody>
</table>
<h3 id="hlalignoftype-vasthlalignoftypeop"><code>hl.alignof.type</code> (::vast::hl::AlignOfTypeOp)</h3>
<p>VAST type alignof operator</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.alignof.type` $arg attr-dict `-&gt;` type($result)
</code></pre>
<p>VAST type alignof operator</p>
<h4 id="attributes_1">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>arg</code></td>
<td style="text-align: center;">::mlir::TypeAttr</td>
<td>any type attribute</td>
</tr>
</tbody>
</table>
<h4 id="results_7">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>integer like type</td>
</tr>
</tbody>
</table>
<h3 id="hlassign-vasthlassignop"><code>hl.assign</code> (::vast::hl::AssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_6">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_8">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignbinand-vasthlbinandassignop"><code>hl.assign.bin.and</code> (::vast::hl::BinAndAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.bin.and` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_7">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_9">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlbinand-vasthlbinandop"><code>hl.bin.and</code> (::vast::hl::BinAndOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.bin.and` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_8">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_10">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlbincomma-vasthlbincomma"><code>hl.bin.comma</code> (::vast::hl::BinComma)</h3>
<p>VAST binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.bin.comma` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>Traits: AttrSizedOperandSegments</p>
<h4 id="operands_9">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_11">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlbinland-vasthlbinlandop"><code>hl.bin.land</code> (::vast::hl::BinLAndOp)</h3>
<p>VAST logical binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.bin.land` $lhs`,` $rhs attr-dict `:` type(results)
</code></pre>
<p>High-level logical binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : type</p>
<h4 id="results_12">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlbinlor-vasthlbinlorop"><code>hl.bin.lor</code> (::vast::hl::BinLOrOp)</h3>
<p>VAST logical binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.bin.lor` $lhs`,` $rhs attr-dict `:` type(results)
</code></pre>
<p>High-level logical binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : type</p>
<h4 id="results_13">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignbinor-vasthlbinorassignop"><code>hl.assign.bin.or</code> (::vast::hl::BinOrAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.bin.or` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_10">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_14">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlbinor-vasthlbinorop"><code>hl.bin.or</code> (::vast::hl::BinOrOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.bin.or` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_11">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_15">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignbinshl-vasthlbinshlassignop"><code>hl.assign.bin.shl</code> (::vast::hl::BinShlAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.bin.shl` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_12">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to integer like type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_16">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>integer like type</td>
</tr>
</tbody>
</table>
<h3 id="hlbinshl-vasthlbinshlop"><code>hl.bin.shl</code> (::vast::hl::BinShlOp)</h3>
<p>VAST binary shift operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.bin.shl` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level binary shift operation. This operation takes two operands
and returns one result.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_13">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>integer like type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>integer like type</td>
</tr>
</tbody>
</table>
<h4 id="results_17">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>integer like type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignbinshr-vasthlbinshrassignop"><code>hl.assign.bin.shr</code> (::vast::hl::BinShrAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.bin.shr` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_14">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to integer like type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_18">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>integer like type</td>
</tr>
</tbody>
</table>
<h3 id="hlbinshr-vasthlbinshrop"><code>hl.bin.shr</code> (::vast::hl::BinShrOp)</h3>
<p>VAST binary shift operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.bin.shr` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level binary shift operation. This operation takes two operands
and returns one result.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_15">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>integer like type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>integer like type</td>
</tr>
</tbody>
</table>
<h4 id="results_19">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>integer like type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignbinxor-vasthlbinxorassignop"><code>hl.assign.bin.xor</code> (::vast::hl::BinXorAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.bin.xor` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_16">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_20">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlbinxor-vasthlbinxorop"><code>hl.bin.xor</code> (::vast::hl::BinXorOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.bin.xor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_17">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_21">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlbuiltin_bitcast-vasthlbuiltinbitcastop"><code>hl.builtin_bitcast</code> (::vast::hl::BuiltinBitCastOp)</h3>
<p>VAST cast operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.builtin_bitcast` $value $kind attr-dict `:` type($value) `-&gt;` type($result)
</code></pre>
<p>VAST cast operation</p>
<h4 id="attributes_2">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>kind</code></td>
<td style="text-align: center;">::vast::hl::CastKindAttr</td>
<td>cast kind</td>
</tr>
</tbody>
</table>
<h4 id="operands_18">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>value</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_22">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlcstyle_cast-vasthlcstylecastop"><code>hl.cstyle_cast</code> (::vast::hl::CStyleCastOp)</h3>
<p>VAST cast operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.cstyle_cast` $value $kind attr-dict `:` type($value) `-&gt;` type($result)
</code></pre>
<p>VAST cast operation</p>
<h4 id="attributes_3">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>kind</code></td>
<td style="text-align: center;">::vast::hl::CastKindAttr</td>
<td>cast kind</td>
</tr>
</tbody>
</table>
<h4 id="operands_19">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>value</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_23">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlcall-vasthlcallop"><code>hl.call</code> (::vast::hl::CallOp)</h3>
<p>VAST call operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.call` $callee `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results )
</code></pre>
<p>VAST call operation
Interfaces: CallOpInterface</p>
<h4 id="attributes_4">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>callee</code></td>
<td style="text-align: center;">::mlir::FlatSymbolRefAttr</td>
<td>flat symbol reference attribute</td>
</tr>
</tbody>
</table>
<h4 id="operands_20">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>argOperands</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_24">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>results</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlclass-vasthlclassdeclop"><code>hl.class</code> (::vast::hl::ClassDeclOp)</h3>
<p>VAST C++ class declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.class` $name attr-dict `:` `bases` $bases $fields
</code></pre>
<p>VAST C++ class declaration
Traits: NoTerminator</p>
<p>Interfaces: VastSymbol</p>
<h4 id="attributes_5">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
</tbody>
</table>
<h3 id="hlcmp-vasthlcmpop"><code>hl.cmp</code> (::vast::hl::CmpOp)</h3>
<p>VAST comparison operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.cmp` $predicate $lhs `,` $rhs  attr-dict `:` type(operands) `-&gt;` type($result)
</code></pre>
<p>VAST comparison operation</p>
<h4 id="attributes_6">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>predicate</code></td>
<td style="text-align: center;">::vast::hl::PredicateAttr</td>
<td>comparison predicate</td>
</tr>
</tbody>
</table>
<h4 id="operands_21">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_25">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>bool or integer like type</td>
</tr>
</tbody>
</table>
<h3 id="hlconst-vasthlconstantop"><code>hl.const</code> (::vast::hl::ConstantOp)</h3>
<p>VAST integral constant</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.const` $value attr-dict
</code></pre>
<p>VAST integral constant
Traits: ConstantLike</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="attributes_7">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>value</code></td>
<td style="text-align: center;">::mlir::TypedAttr</td>
<td>TypedAttr instance</td>
</tr>
</tbody>
</table>
<h4 id="results_26">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlbase-vasthlcxxbasespecifierop"><code>hl.base</code> (::vast::hl::CxxBaseSpecifierOp)</h3>
<p>VAST base class specifier</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.base` $type attr-dict $access (`virtual` $is_virtual^)?
</code></pre>
<p>VAST base class specifier
Interfaces: VastSymbol</p>
<h4 id="attributes_8">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>type</code></td>
<td style="text-align: center;">::mlir::TypeAttr</td>
<td>any type attribute</td>
</tr>
<tr>
<td style="text-align: center;"><code>access</code></td>
<td style="text-align: center;">::vast::hl::AccessSpecifierAttr</td>
<td>Access specifier</td>
</tr>
<tr>
<td style="text-align: center;"><code>is_virtual</code></td>
<td style="text-align: center;">::mlir::UnitAttr</td>
<td>unit attribute</td>
</tr>
</tbody>
</table>
<h3 id="hlcxxstruct-vasthlcxxstructdeclop"><code>hl.cxxstruct</code> (::vast::hl::CxxStructDeclOp)</h3>
<p>VAST C++ struct declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.cxxstruct` $name attr-dict `:` `bases` $bases $fields
</code></pre>
<p>VAST C++ struct declaration
Traits: NoTerminator</p>
<p>Interfaces: VastSymbol</p>
<h4 id="attributes_9">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
</tbody>
</table>
<h3 id="hlref-vasthldeclrefop"><code>hl.ref</code> (::vast::hl::DeclRefOp)</h3>
<p>VAST variable reference declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.ref` $decl attr-dict `:`type(operands)
</code></pre>
<p>VAST variable reference declaration
Interfaces: InferTypeOpInterface</p>
<h4 id="operands_22">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>decl</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_27">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>lvalue to any type</td>
</tr>
</tbody>
</table>
<h3 id="hlderef-vasthlderef"><code>hl.deref</code> (::vast::hl::Deref)</h3>
<p>VAST deref operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.deref` $addr attr-dict `:` type($addr) `-&gt;` type($result)
</code></pre>
<p>VAST deref operation</p>
<h4 id="operands_23">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>addr</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_28">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>lvalue to any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignfdiv-vasthldivfassignop"><code>hl.assign.fdiv</code> (::vast::hl::DivFAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.fdiv` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_24">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_29">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlfdiv-vasthldivfop"><code>hl.fdiv</code> (::vast::hl::DivFOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.fdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_25">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_30">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignsdiv-vasthldivsassignop"><code>hl.assign.sdiv</code> (::vast::hl::DivSAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.sdiv` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_26">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_31">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlsdiv-vasthldivsop"><code>hl.sdiv</code> (::vast::hl::DivSOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.sdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_27">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_32">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignudiv-vasthldivuassignop"><code>hl.assign.udiv</code> (::vast::hl::DivUAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.udiv` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_28">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_33">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hludiv-vasthldivuop"><code>hl.udiv</code> (::vast::hl::DivUOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.udiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_29">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_34">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlenumconst-vasthlenumconstantop"><code>hl.enum.const</code> (::vast::hl::EnumConstantOp)</h3>
<p>VAST enum constant declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.enum.const` $name `=` $value attr-dict (`init` $init^)?
</code></pre>
<p>Enumeration constant servers to link name to an enum value.
It is required to be scoped in Enum operation. For example:</p>
<pre><code>hl.enum.const &quot;F&quot; = 2 : !hl.int
</code></pre>
<p>A constant can have a constant expression initializer:</p>
<pre><code>hl.enum.const &quot;G&quot; = #hl.integer&lt;12&gt; : !hl.int init  {
  %0 = hl.enumref &quot;F&quot; : !hl.int
  %1 = hl.enumref &quot;C&quot; : !hl.int
  %2 = hl.add %0, %1 : !hl.int
  hl.value.yield %2 : !hl.int
}
</code></pre>
<h4 id="attributes_10">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td style="text-align: center;"><code>value</code></td>
<td style="text-align: center;">::mlir::TypedAttr</td>
<td>TypedAttr instance</td>
</tr>
</tbody>
</table>
<h3 id="hlenum-vasthlenumdeclop"><code>hl.enum</code> (::vast::hl::EnumDeclOp)</h3>
<p>VAST enum declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.enum` $name attr-dict `:` $type $constants
</code></pre>
<p>Enum declaration serves to declare region for enum constant declarations.
It also defines an underlying type.</p>
<p>Traits: NoTerminator</p>
<p>Interfaces: VastSymbol</p>
<h4 id="attributes_11">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td style="text-align: center;"><code>type</code></td>
<td style="text-align: center;">::mlir::TypeAttr</td>
<td>any type attribute</td>
</tr>
</tbody>
</table>
<h3 id="hlenumref-vasthlenumrefop"><code>hl.enumref</code> (::vast::hl::EnumRefOp)</h3>
<p>VAST variable reference declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.enumref` $value attr-dict `:` type($result)
</code></pre>
<p>VAST variable reference declaration</p>
<h4 id="attributes_12">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>value</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
</tbody>
</table>
<h4 id="results_35">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlexpr-vasthlexprop"><code>hl.expr</code> (::vast::hl::ExprOp)</h3>
<p>VAST expression</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.expr` attr-dict `:` type($result) $subexpr
</code></pre>
<p>VAST expression
Traits: SingleBlock</p>
<h4 id="results_36">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlgnuextension-vasthlextensionop"><code>hl.gnu.extension</code> (::vast::hl::ExtensionOp)</h3>
<p>VAST extension (<strong>extension</strong>) keyword</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.gnu.extension` $value attr-dict `:` type($value) `-&gt;` type($result)
</code></pre>
<p>VAST op corresponding to GNU <strong>extension</strong> keyword.</p>
<h4 id="operands_30">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>value</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_37">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlfcmp-vasthlfcmpop"><code>hl.fcmp</code> (::vast::hl::FCmpOp)</h3>
<p>VAST flaoting point comparison operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.fcmp` $predicate $lhs `,` $rhs  attr-dict `:` type(operands) `-&gt;` type($result)
</code></pre>
<p>VAST flaoting point comparison operation</p>
<h4 id="attributes_13">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>predicate</code></td>
<td style="text-align: center;">::vast::hl::FPredicateAttr</td>
<td>floating point comparison predicate</td>
</tr>
</tbody>
</table>
<h4 id="operands_31">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>float like type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>float like type</td>
</tr>
</tbody>
</table>
<h4 id="results_38">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>bool or integer like type</td>
</tr>
</tbody>
</table>
<h3 id="hlfield-vasthlfielddeclop"><code>hl.field</code> (::vast::hl::FieldDeclOp)</h3>
<p>VAST record field declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.field` $name attr-dict (`bw` $bits^)? `:` $type
</code></pre>
<p>VAST record field declaration
Interfaces: VastSymbol</p>
<h4 id="attributes_14">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td style="text-align: center;"><code>type</code></td>
<td style="text-align: center;">::mlir::TypeAttr</td>
<td>any type attribute</td>
</tr>
<tr>
<td style="text-align: center;"><code>bits</code></td>
<td style="text-align: center;">::mlir::IntegerAttr</td>
<td>32-bit signless integer attribute</td>
</tr>
</tbody>
</table>
<h3 id="hlfunc-vasthlfuncop"><code>hl.func</code> (::vast::hl::FuncOp)</h3>
<p>VAST high-level function definintion or declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.func` $linkage $sym_name custom&lt; FunctionSignatureAndBody &gt;($function_type, attr-dict, $body)
</code></pre>
<p>Inspired by <code>cir::FuncOp</code> and <code>mlir::func::FuncOp</code>:</p>
<blockquote>
<p>Operations within the function cannot implicitly capture values defined
outside of the function, i.e. Functions are <code>IsolatedFromAbove</code>. All
external references must use function arguments or attributes that establish
a symbolic connection (e.g. symbols referenced by name via a string
attribute like SymbolRefAttr). An external function declaration (used when
referring to a function declared in some other module) has no body.</p>
</blockquote>
<p>The function linkage information is specified by <code>linkage</code>, as defined by
<code>GlobalLinkageKind</code> attribute.</p>
<p>Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator</p>
<p>Interfaces: CallableOpInterface, FunctionOpInterface, Symbol</p>
<h4 id="attributes_15">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>sym_name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td style="text-align: center;"><code>function_type</code></td>
<td style="text-align: center;">::mlir::TypeAttr</td>
<td>type attribute of function type</td>
</tr>
<tr>
<td style="text-align: center;"><code>linkage</code></td>
<td style="text-align: center;">::vast::hl::GlobalLinkageKindAttr</td>
<td>Linkage type/kind</td>
</tr>
<tr>
<td style="text-align: center;"><code>sym_visibility</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td style="text-align: center;"><code>arg_attrs</code></td>
<td style="text-align: center;">::mlir::ArrayAttr</td>
<td>Array of dictionary attributes</td>
</tr>
<tr>
<td style="text-align: center;"><code>res_attrs</code></td>
<td style="text-align: center;">::mlir::ArrayAttr</td>
<td>Array of dictionary attributes</td>
</tr>
</tbody>
</table>
<h3 id="hlfuncref-vasthlfuncrefop"><code>hl.funcref</code> (::vast::hl::FuncRefOp)</h3>
<p>VAST function reference declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.funcref` $function attr-dict `:` type($result)
</code></pre>
<p>VAST function reference declaration</p>
<h4 id="attributes_16">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>function</code></td>
<td style="text-align: center;">::mlir::FlatSymbolRefAttr</td>
<td>flat symbol reference attribute</td>
</tr>
</tbody>
</table>
<h4 id="results_39">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlglobref-vasthlglobalrefop"><code>hl.globref</code> (::vast::hl::GlobalRefOp)</h3>
<p>VAST global variable reference declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.globref` $global attr-dict `:` type($result)
</code></pre>
<p>VAST global variable reference declaration</p>
<h4 id="attributes_17">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>global</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
</tbody>
</table>
<h4 id="results_40">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlbreak-vasthlbreakop"><code>hl.break</code> (::vast::hl::BreakOp)</h3>
<p>VAST break statement</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.break` attr-dict
</code></pre>
<p>VAST break statement
Traits: NoRegionArguments, NoTerminator, soft_terminator</p>
<h3 id="hlcase-vasthlcaseop"><code>hl.case</code> (::vast::hl::CaseOp)</h3>
<p>VAST case statement</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.case` $lhs $body attr-dict
</code></pre>
<p>The operation represents a single case of a switch statement.</p>
<p>The generic form of the operation is as follows:</p>
<p>hl.case {
  ... /<em> lhs/check region </em>/
  hl.value.yield %val : !hl.type
} {
  ... /<em> body region </em>/
}</p>
<p>It represents a C statement of form <code>case lhs: body;</code>.</p>
<p>Traits: NoRegionArguments, NoTerminator</p>
<h3 id="hlcond-vasthlcondop"><code>hl.cond</code> (::vast::hl::CondOp)</h3>
<p>VAST conditional statement</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.cond` $condRegion `?` $thenRegion `:` $elseRegion attr-dict `:` type(results)
</code></pre>
<p>The operation takes builders of three regions -- condition, true branch and false branch.
Builders, given the location, build a particular region.</p>
<p>The generic form of the operation is as follows:</p>
<p>hl.cond {
  ... /<em> condition region </em>/
  hl.cond.yield %cond : !hl.bool
} ? {
  ... /<em> true region </em>/
} : {
  ... /<em> false region </em>/
}</p>
<p>Traits: NoRegionArguments, NoTerminator</p>
<h4 id="results_41">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlcondyield-vasthlcondyieldop"><code>hl.cond.yield</code> (::vast::hl::CondYieldOp)</h3>
<p>condition yield operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.cond.yield` attr-dict $result `:` type($result)
</code></pre>
<p>A condition yield operation is used to terminate the region representing
condition expression of control flow operations <code>IfOp</code>, <code>WhileOp</code>, <code>ForOp</code>
and <code>DoOp</code>. It yields a boolean value for the conditional branch.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>hl.cond.yield result : BoolType</p>
<p>Traits: HasParent<IfOp, WhileOp, ForOp, DoOp, CondOp>, Terminator</p>
<h4 id="operands_32">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlcontinue-vasthlcontinueop"><code>hl.continue</code> (::vast::hl::ContinueOp)</h3>
<p>VAST continue statement</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.continue` attr-dict
</code></pre>
<p>VAST continue statement
Traits: NoRegionArguments, NoTerminator, soft_terminator</p>
<h3 id="hldefault-vasthldefaultop"><code>hl.default</code> (::vast::hl::DefaultOp)</h3>
<p>VAST default statement</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.default` $body attr-dict
</code></pre>
<p>VAST default statement
Traits: NoRegionArguments, NoTerminator</p>
<h3 id="hldo-vasthldoop"><code>hl.do</code> (::vast::hl::DoOp)</h3>
<p>VAST do-while statement</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.do` $bodyRegion `while` $condRegion attr-dict
</code></pre>
<p>The operation represents a do-while statement.</p>
<p>The generic form of the operation is as follows:</p>
<p>hl.do {
  ... /<em> body region </em>/
} cond {
  ... /<em> cond region </em>/
  hl.cond.yield %cond : !hl.bool
}</p>
<p>Traits: NoRegionArguments, NoTerminator</p>
<h3 id="hlfor-vasthlforop"><code>hl.for</code> (::vast::hl::ForOp)</h3>
<p>VAST for statement</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.for` $condRegion `incr` $incrRegion attr-dict `do` $bodyRegion
</code></pre>
<p>Operation represents a for-loop statement.</p>
<p>The generic form of the operation is as follows:</p>
<p>hl.for {
  ... /<em> cond region </em>/
  hl.cond.yield %cond : !hl.bool
} incr {
  ... /<em> increment/update region </em>/
} do {
  ... /<em> body region </em>/
}</p>
<p>Traits: NoRegionArguments, NoTerminator</p>
<h3 id="hlgoto-vasthlgotostmt"><code>hl.goto</code> (::vast::hl::GotoStmt)</h3>
<p>Syntax:</p>
<pre><code>operation ::= `hl.goto` $label attr-dict
</code></pre>
<h4 id="operands_33">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>label</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="hlif-vasthlifop"><code>hl.if</code> (::vast::hl::IfOp)</h3>
<p>VAST if statement</p>
<p>The operation takes builders of two mandatory regions -- condition and then
region -- and one builder optional region representing else block of C if statement.
Builders, given the location, build a particular region.</p>
<p>The generic form of the operation is as follows:</p>
<p>hl.if {
  ... /<em> condition region </em>/
  hl.cond.yield %cond : !hl.bool
} then {
  ... /<em> then region </em>/
} else {
  ... /<em> else region </em>/
}</p>
<p>Traits: NoRegionArguments, NoTerminator</p>
<h3 id="hllabeldecl-vasthllabeldeclop"><code>hl.label.decl</code> (::vast::hl::LabelDeclOp)</h3>
<p>Syntax:</p>
<pre><code>operation ::= `hl.label.decl` $name attr-dict `:` type($result)
</code></pre>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="attributes_18">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
</tbody>
</table>
<h4 id="results_42">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="hllabel-vasthllabelstmt"><code>hl.label</code> (::vast::hl::LabelStmt)</h3>
<p>VAST control flow operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.label` $label $body attr-dict
</code></pre>
<p>VAST control flow operation
Traits: NoRegionArguments, NoTerminator</p>
<h4 id="operands_34">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>label</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="hlskip-vasthlskipstmt"><code>hl.skip</code> (::vast::hl::SkipStmt)</h3>
<p>VAST skip statement</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.skip` attr-dict
</code></pre>
<p>VAST skip statement</p>
<h3 id="hlswitch-vasthlswitchop"><code>hl.switch</code> (::vast::hl::SwitchOp)</h3>
<p>VAST switch statement</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.switch` $condRegion `cases` $cases attr-dict
</code></pre>
<p>The operation represents a switch statement.</p>
<p>The generic form of the operation is as follows:</p>
<p>hl.switch {
  ... /<em> cond region </em>/
  hl.value.yield %val : !hl.type
} cases {
  ... /<em> casesregion </em>/
}</p>
<p>Traits: NoRegionArguments, NoTerminator</p>
<h3 id="hlvalueyield-vasthlvalueyieldop"><code>hl.value.yield</code> (::vast::hl::ValueYieldOp)</h3>
<p>value yield operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.value.yield` attr-dict $result `:` type($result)
</code></pre>
<p>A value yield operation is used to terminate the case region of a switch
statement. The yielded value triggers the parent case statement region.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>hl.value.yield result : type</p>
<p>Traits: Terminator</p>
<h4 id="operands_35">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlvar-vasthlvardeclop"><code>hl.var</code> (::vast::hl::VarDeclOp)</h3>
<p>VAST variable declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.var` $name attr-dict ($storageClass^)? ($threadStorageClass^)? `:` type($result)
              (`=` $initializer^)?
              (`allocation_size` $allocation_size^)?
</code></pre>
<p>VAST variable declaration
Interfaces: VastSymbol</p>
<h4 id="attributes_19">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td style="text-align: center;"><code>storageClass</code></td>
<td style="text-align: center;">::vast::hl::StorageClassAttr</td>
<td>storage class</td>
</tr>
<tr>
<td style="text-align: center;"><code>threadStorageClass</code></td>
<td style="text-align: center;">::vast::hl::TSClassAttr</td>
<td>thread storage class</td>
</tr>
</tbody>
</table>
<h4 id="results_43">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlwhile-vasthlwhileop"><code>hl.while</code> (::vast::hl::WhileOp)</h3>
<p>VAST while statement</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.while` $condRegion `do` $bodyRegion attr-dict
</code></pre>
<p>The operation takes builders of two mandatory regions -- condition and body
region. Builders, given the location, build a particular region.</p>
<p>The generic form of the operation is as follows:</p>
<p>hl.while {
  ... /<em> condition region </em>/
  hl.cond.yield %cond : !hl.bool
} do {
  ... /<em> body region </em>/
}</p>
<p>Traits: NoRegionArguments, NoTerminator</p>
<h3 id="hlimplicit_cast-vasthlimplicitcastop"><code>hl.implicit_cast</code> (::vast::hl::ImplicitCastOp)</h3>
<p>VAST cast operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.implicit_cast` $value $kind attr-dict `:` type($value) `-&gt;` type($result)
</code></pre>
<p>VAST cast operation</p>
<h4 id="attributes_20">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>kind</code></td>
<td style="text-align: center;">::vast::hl::CastKindAttr</td>
<td>cast kind</td>
</tr>
</tbody>
</table>
<h4 id="operands_36">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>value</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_44">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlindirect_call-vasthlindirectcallop"><code>hl.indirect_call</code> (::vast::hl::IndirectCallOp)</h3>
<p>VAST call operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.indirect_call` $callee `:` type($callee)  `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results )
</code></pre>
<p>VAST call operation
Interfaces: CallOpInterface</p>
<h4 id="operands_37">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>callee</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>argOperands</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_45">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>results</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlinitlist-vasthlinitlistexpr"><code>hl.initlist</code> (::vast::hl::InitListExpr)</h3>
<p>VAST initializer list expression</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.initlist` $elements attr-dict `:` functional-type($elements, results)
</code></pre>
<p>VAST initializer list expression</p>
<h4 id="operands_38">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>elements</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_46">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">&laquo;unnamed&raquo;</td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hllnot-vasthllnotop"><code>hl.lnot</code> (::vast::hl::LNotOp)</h3>
<p>VAST unary logical operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.lnot` $arg attr-dict `:` type($arg) `-&gt;` type($res)
</code></pre>
<p>High-level unary logical operation assures that
result has the right type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %arg : type -&gt; ret_type</p>
<h4 id="operands_39">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>arg</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_47">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>res</code></td>
<td>bool or integer like type</td>
</tr>
</tbody>
</table>
<h3 id="hlminus-vasthlminusop"><code>hl.minus</code> (::vast::hl::MinusOp)</h3>
<p>VAST unary type preserving operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.minus` $arg attr-dict `:` type($result)
</code></pre>
<p>Type preserving high-level unary operation assures that argument and
result has the same type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %arg : type</p>
<p>Traits: SameOperandsAndResultType</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_40">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>arg</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_48">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignfmul-vasthlmulfassignop"><code>hl.assign.fmul</code> (::vast::hl::MulFAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.fmul` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_41">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_49">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlfmul-vasthlmulfop"><code>hl.fmul</code> (::vast::hl::MulFOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.fmul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_42">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_50">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignmul-vasthlmuliassignop"><code>hl.assign.mul</code> (::vast::hl::MulIAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.mul` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_43">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_51">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlmul-vasthlmuliop"><code>hl.mul</code> (::vast::hl::MulIOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.mul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<p>Traits: Commutative</p>
<h4 id="operands_44">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_52">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlnot-vasthlnotop"><code>hl.not</code> (::vast::hl::NotOp)</h3>
<p>VAST unary type preserving operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.not` $arg attr-dict `:` type($result)
</code></pre>
<p>Type preserving high-level unary operation assures that argument and
result has the same type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %arg : type</p>
<p>Traits: SameOperandsAndResultType</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_45">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>arg</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_53">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlplus-vasthlplusop"><code>hl.plus</code> (::vast::hl::PlusOp)</h3>
<p>VAST unary type preserving operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.plus` $arg attr-dict `:` type($result)
</code></pre>
<p>Type preserving high-level unary operation assures that argument and
result has the same type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %arg : type</p>
<p>Traits: SameOperandsAndResultType</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_46">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>arg</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_54">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlpostdec-vasthlpostdecop"><code>hl.post.dec</code> (::vast::hl::PostDecOp)</h3>
<p>VAST unary inplace operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.post.dec` $arg attr-dict `:` type($arg) `-&gt;` type($result)
</code></pre>
<p>Inplace high-level unary operation changes its single argument in place.
It does not produce a new value.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %arg : type</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_47">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>arg</code></td>
<td>lvalue to any type</td>
</tr>
</tbody>
</table>
<h4 id="results_55">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlpostinc-vasthlpostincop"><code>hl.post.inc</code> (::vast::hl::PostIncOp)</h3>
<p>VAST unary inplace operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.post.inc` $arg attr-dict `:` type($arg) `-&gt;` type($result)
</code></pre>
<p>Inplace high-level unary operation changes its single argument in place.
It does not produce a new value.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %arg : type</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_48">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>arg</code></td>
<td>lvalue to any type</td>
</tr>
</tbody>
</table>
<h4 id="results_56">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlpredec-vasthlpredecop"><code>hl.pre.dec</code> (::vast::hl::PreDecOp)</h3>
<p>VAST unary inplace operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.pre.dec` $arg attr-dict `:` type($arg) `-&gt;` type($result)
</code></pre>
<p>Inplace high-level unary operation changes its single argument in place.
It does not produce a new value.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %arg : type</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_49">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>arg</code></td>
<td>lvalue to any type</td>
</tr>
</tbody>
</table>
<h4 id="results_57">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlpreinc-vasthlpreincop"><code>hl.pre.inc</code> (::vast::hl::PreIncOp)</h3>
<p>VAST unary inplace operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.pre.inc` $arg attr-dict `:` type($arg) `-&gt;` type($result)
</code></pre>
<p>Inplace high-level unary operation changes its single argument in place.
It does not produce a new value.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %arg : type</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_50">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>arg</code></td>
<td>lvalue to any type</td>
</tr>
</tbody>
</table>
<h4 id="results_58">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlpredefinedexpr-vasthlpredefinedexpr"><code>hl.predefined.expr</code> (::vast::hl::PredefinedExpr)</h3>
<p>VAT predefined expr ( such as <strong>func</strong> )</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.predefined.expr` $value $kind attr-dict `:` type($value) `-&gt;` type($result)
</code></pre>
<p>VAT predefined expr ( such as <strong>func</strong> )</p>
<h4 id="attributes_21">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>kind</code></td>
<td style="text-align: center;">::vast::hl::IdentKindAttr</td>
<td>ident kind</td>
</tr>
</tbody>
</table>
<h4 id="operands_51">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>value</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_59">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlmember-vasthlrecordmemberop"><code>hl.member</code> (::vast::hl::RecordMemberOp)</h3>
<p>VAST record element access operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.member` $record `at` $name attr-dict `:` type($record) `-&gt;` type($element)
</code></pre>
<p>VAST record element access operation</p>
<h4 id="attributes_22">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
</tbody>
</table>
<h4 id="operands_52">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>record</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_60">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>element</code></td>
<td>lvalue to any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignfrem-vasthlremfassignop"><code>hl.assign.frem</code> (::vast::hl::RemFAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.frem` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_53">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_61">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlfrem-vasthlremfop"><code>hl.frem</code> (::vast::hl::RemFOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.frem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_54">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_62">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignsrem-vasthlremsassignop"><code>hl.assign.srem</code> (::vast::hl::RemSAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.srem` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_55">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_63">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlsrem-vasthlremsop"><code>hl.srem</code> (::vast::hl::RemSOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.srem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_56">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_64">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignurem-vasthlremuassignop"><code>hl.assign.urem</code> (::vast::hl::RemUAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.urem` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_57">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_65">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlurem-vasthlremuop"><code>hl.urem</code> (::vast::hl::RemUOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.urem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_58">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_66">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlreturn-vasthlreturnop"><code>hl.return</code> (::vast::hl::ReturnOp)</h3>
<p>Syntax:</p>
<pre><code>operation ::= `hl.return` ($result^ `:` type($result))? attr-dict
</code></pre>
<p>Traits: soft_terminator</p>
<h4 id="operands_59">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlscope-vasthlscopeop"><code>hl.scope</code> (::vast::hl::ScopeOp)</h3>
<p>VAST scope declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.scope` $body attr-dict
</code></pre>
<p>Scope operation servers to represent explicitly high-level code scope.
Other control flow operations represent scopes implicitly.  It is a
single-region operation.</p>
<p>Traits: NoTerminator</p>
<h3 id="hlsizeofexpr-vasthlsizeofexprop"><code>hl.sizeof.expr</code> (::vast::hl::SizeOfExprOp)</h3>
<p>VAST expr sizeof operator</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.sizeof.expr` attr-dict `-&gt;` type($result) $expr
</code></pre>
<p>VAST expr sizeof operator</p>
<h4 id="results_67">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>integer like type</td>
</tr>
</tbody>
</table>
<h3 id="hlsizeoftype-vasthlsizeoftypeop"><code>hl.sizeof.type</code> (::vast::hl::SizeOfTypeOp)</h3>
<p>VAST type sizeof operator</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.sizeof.type` $arg attr-dict `-&gt;` type($result)
</code></pre>
<p>VAST type sizeof operator</p>
<h4 id="attributes_23">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>arg</code></td>
<td style="text-align: center;">::mlir::TypeAttr</td>
<td>any type attribute</td>
</tr>
</tbody>
</table>
<h4 id="results_68">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>integer like type</td>
</tr>
</tbody>
</table>
<h3 id="hlstmtexpr-vasthlstmtexprop"><code>hl.stmt.expr</code> (::vast::hl::StmtExprOp)</h3>
<p>VAST statement expression</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.stmt.expr` attr-dict `:` type($result) $substmt
</code></pre>
<p>VAST statement expression
Traits: NoTerminator, SingleBlock</p>
<h4 id="results_69">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlstruct-vasthlstructdeclop"><code>hl.struct</code> (::vast::hl::StructDeclOp)</h3>
<p>VAST struct declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.struct` $name attr-dict `:` $fields
</code></pre>
<p>VAST struct declaration
Traits: NoTerminator</p>
<p>Interfaces: VastSymbol</p>
<h4 id="attributes_24">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
</tbody>
</table>
<h3 id="hlassignfsub-vasthlsubfassignop"><code>hl.assign.fsub</code> (::vast::hl::SubFAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.fsub` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_60">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_70">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlfsub-vasthlsubfop"><code>hl.fsub</code> (::vast::hl::SubFOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.fsub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_61">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_71">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlassignsub-vasthlsubiassignop"><code>hl.assign.sub</code> (::vast::hl::SubIAssignOp)</h3>
<p>VAST compound assign operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.assign.sub` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)
</code></pre>
<p>A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <assign.op> src to dst : functional-type(operands, results)</p>
<p>It represents C compound assignment statement:</p>
<p>dst =<op> src;</p>
<p>Interfaces: InferTypeOpInterface</p>
<h4 id="operands_62">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>src</code></td>
<td>lvalue to any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>dst</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_72">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlsub-vasthlsubiop"><code>hl.sub</code> (::vast::hl::SubIOp)</h3>
<p>VAST arithmetic binary operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.sub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
</code></pre>
<p>High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.</p>
<p>The custom assembly form of the operation is as follows:</p>
<p>%result = <op> %lhs, %rhs  : functional-type(operands, results)</p>
<h4 id="operands_63">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>lhs</code></td>
<td>any type</td>
</tr>
<tr>
<td style="text-align: center;"><code>rhs</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h4 id="results_73">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hlsubscript-vasthlsubscriptop"><code>hl.subscript</code> (::vast::hl::SubscriptOp)</h3>
<p>VAST array subscript operator</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.subscript` $array `at` ` ` `[` $index `:` type($index) `]` attr-dict
              `:` type($array) `-&gt;` type($result)
</code></pre>
<p>VAST array subscript operator</p>
<h4 id="operands_64">Operands:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>array</code></td>
<td>lvalue to subscriptable type</td>
</tr>
<tr>
<td style="text-align: center;"><code>index</code></td>
<td>integer like type</td>
</tr>
</tbody>
</table>
<h4 id="results_74">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>lvalue to any type</td>
</tr>
</tbody>
</table>
<h3 id="hlthis-vasthlthisop"><code>hl.this</code> (::vast::hl::ThisOp)</h3>
<p>VAST this operator</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.this` attr-dict `:` type($result)
</code></pre>
<p>VAST this operator</p>
<h4 id="results_75">Results:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table>
<h3 id="hltranslation_unit-vasthltranslationunitop"><code>hl.translation_unit</code> (::vast::hl::TranslationUnitOp)</h3>
<p>VAST translation unit</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.translation_unit` $body attr-dict
</code></pre>
<p>VAST tranaslation unit
Traits: IsolatedFromAbove, NoTerminator, SymbolTable</p>
<h3 id="hltype-vasthltypedeclop"><code>hl.type</code> (::vast::hl::TypeDeclOp)</h3>
<p>VAST type declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.type` $name attr-dict
</code></pre>
<p>VAST type declaration
Interfaces: VastSymbol</p>
<h4 id="attributes_25">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
</tbody>
</table>
<h3 id="hltypedef-vasthltypedefop"><code>hl.typedef</code> (::vast::hl::TypeDefOp)</h3>
<p>VAST typedef operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.typedef` $name attr-dict `:` $type
</code></pre>
<p>Typedef operation servers to declare named types.
It creates a new type symbol in the current scope to
be referenced as NamedType later.</p>
<p>Interfaces: VastSymbol</p>
<h4 id="attributes_26">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td style="text-align: center;"><code>type</code></td>
<td style="text-align: center;">::mlir::TypeAttr</td>
<td>any type attribute</td>
</tr>
</tbody>
</table>
<h3 id="hlunion-vasthluniondeclop"><code>hl.union</code> (::vast::hl::UnionDeclOp)</h3>
<p>VAST record declaration</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.union` $name attr-dict `:` $fields
</code></pre>
<p>VAST record declaration
Traits: NoTerminator</p>
<p>Interfaces: VastSymbol</p>
<h4 id="attributes_27">Attributes:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Attribute</th>
<th style="text-align: center;">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>name</code></td>
<td style="text-align: center;">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
</tbody>
</table>
<h3 id="hlunreachable-vasthlunreachableop"><code>hl.unreachable</code> (::vast::hl::UnreachableOp)</h3>
<p>VAST unreachable operation</p>
<p>Syntax:</p>
<pre><code>operation ::= `hl.unreachable` attr-dict
</code></pre>
<p>VAST unreachable operation
Traits: Terminator</p>
<h2 id="attribute-definition">Attribute definition</h2>
<h3 id="annotationattr">AnnotationAttr</h3>
<p>Syntax:</p>
<pre><code>#hl.annotation&lt;
  ::mlir::StringAttr   # name
&gt;
</code></pre>
<h4 id="parameters">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">name</td>
<td style="text-align: center;"><code>::mlir::StringAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="booleanattr">BooleanAttr</h3>
<p>An Attribute containing a boolean value</p>
<p>Syntax:</p>
<pre><code>#core.bool&lt;
  ::mlir::Type,   # type
  bool   # value
&gt;
</code></pre>
<p>An boolean attribute is a literal attribute that represents a boolean value.</p>
<h4 id="parameters_1">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">type</td>
<td style="text-align: center;"><code>::mlir::Type</code></td>
<td></td>
</tr>
<tr>
<td style="text-align: center;">value</td>
<td style="text-align: center;"><code>bool</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="cvqualifiersattr">CVQualifiersAttr</h3>
<p>Syntax:</p>
<pre><code>#hl.quals&lt;
  bool,   # is_const
  bool   # is_volatile
&gt;
</code></pre>
<h4 id="parameters_2">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">is_const</td>
<td style="text-align: center;"><code>bool</code></td>
<td>const qualifier</td>
</tr>
<tr>
<td style="text-align: center;">is_volatile</td>
<td style="text-align: center;"><code>bool</code></td>
<td>volatile qualifier</td>
</tr>
</tbody>
</table>
<h3 id="cvrqualifiersattr">CVRQualifiersAttr</h3>
<p>Syntax:</p>
<pre><code>#hl.quals&lt;
  bool,   # is_const
  bool,   # is_volatile
  bool   # is_restrict
&gt;
</code></pre>
<h4 id="parameters_3">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">is_const</td>
<td style="text-align: center;"><code>bool</code></td>
<td>const qualifier</td>
</tr>
<tr>
<td style="text-align: center;">is_volatile</td>
<td style="text-align: center;"><code>bool</code></td>
<td>volatile qualifier</td>
</tr>
<tr>
<td style="text-align: center;">is_restrict</td>
<td style="text-align: center;"><code>bool</code></td>
<td>restrict qualifier</td>
</tr>
</tbody>
</table>
<h3 id="floatattr">FloatAttr</h3>
<p>An Attribute containing a floating point value</p>
<p>Syntax:</p>
<pre><code>#core.float&lt;
  ::mlir::Type,   # type
  ::llvm::APFloat   # value
&gt;
</code></pre>
<p>A float attribute is a literal attribute that represents a floating point
value of the specified floating point type.</p>
<h4 id="parameters_4">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">type</td>
<td style="text-align: center;"><code>::mlir::Type</code></td>
<td></td>
</tr>
<tr>
<td style="text-align: center;">value</td>
<td style="text-align: center;"><code>::llvm::APFloat</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="integerattr">IntegerAttr</h3>
<p>An Attribute containing a integer value</p>
<p>Syntax:</p>
<pre><code>#core.integer&lt;
  ::mlir::Type,   # type
  ::llvm::APSInt   # value
&gt;
</code></pre>
<p>An integer attribute is a literal attribute that represents an integral
value of the specified integer type.</p>
<h4 id="parameters_5">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">type</td>
<td style="text-align: center;"><code>::mlir::Type</code></td>
<td></td>
</tr>
<tr>
<td style="text-align: center;">value</td>
<td style="text-align: center;"><code>::llvm::APSInt</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="stringattr">StringAttr</h3>
<p>An Attribute containing a string</p>
<p>Syntax:</p>
<pre><code>#core.str&lt;
  ::llvm::StringRef,   # value
  ::mlir::Type   # type
&gt;
</code></pre>
<p>Note: Temporarily copied from builtin dialect, because llvm-15 does not have
<code>TypedAttrInterface</code> yet.</p>
<p>Syntax:</p>
<pre><code>string-attribute ::= string-literal (`:` type)?
</code></pre>
<p>A string attribute is an attribute that represents a string literal value.</p>
<p>Examples:</p>
<pre><code class="language-mlir">&quot;An important string&quot;
&quot;string with a type&quot; : !dialect.string
</code></pre>
<h4 id="parameters_6">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">value</td>
<td style="text-align: center;"><code>::llvm::StringRef</code></td>
<td></td>
</tr>
<tr>
<td style="text-align: center;">type</td>
<td style="text-align: center;"><code>::mlir::Type</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="stringliteralattr">StringLiteralAttr</h3>
<p>An Attribute containing an escaped string</p>
<p>Syntax:</p>
<pre><code>string-attribute ::= string-literal (`:` type)?
</code></pre>
<p>A string literal attribute is an attribute that represents an escaped string literal value.</p>
<p>Examples:</p>
<pre><code class="language-mlir">&quot;An important string&quot;
&quot;string with a type&quot; : !dialect.string
</code></pre>
<h4 id="parameters_7">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">value</td>
<td style="text-align: center;"><code>::llvm::StringRef</code></td>
<td></td>
</tr>
<tr>
<td style="text-align: center;">type</td>
<td style="text-align: center;"><code>::mlir::Type</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="ucvqualifiersattr">UCVQualifiersAttr</h3>
<p>Syntax:</p>
<pre><code>#hl.quals&lt;
  bool,   # is_unsigned
  bool,   # is_const
  bool   # is_volatile
&gt;
</code></pre>
<h4 id="parameters_8">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">is_unsigned</td>
<td style="text-align: center;"><code>bool</code></td>
<td>unsigned qualifier</td>
</tr>
<tr>
<td style="text-align: center;">is_const</td>
<td style="text-align: center;"><code>bool</code></td>
<td>const qualifier</td>
</tr>
<tr>
<td style="text-align: center;">is_volatile</td>
<td style="text-align: center;"><code>bool</code></td>
<td>volatile qualifier</td>
</tr>
</tbody>
</table>
<h2 id="type-definition">Type definition</h2>
<h3 id="adjustedtype">AdjustedType</h3>
<p>Syntax:</p>
<pre><code>!hl.adjusted&lt;
  Type,   # original
  Type   # adjusted
&gt;
</code></pre>
<h4 id="parameters_9">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">original</td>
<td style="text-align: center;"><code>Type</code></td>
<td></td>
</tr>
<tr>
<td style="text-align: center;">adjusted</td>
<td style="text-align: center;"><code>Type</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="arraytype">ArrayType</h3>
<p>Syntax:</p>
<pre><code>!hl.array&lt;
  SizeParam,   # size
  Type,   # elementType
  CVRQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_10">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">size</td>
<td style="text-align: center;"><code>SizeParam</code></td>
<td>size parameter for arrays</td>
</tr>
<tr>
<td style="text-align: center;">elementType</td>
<td style="text-align: center;"><code>Type</code></td>
<td></td>
</tr>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVRQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="attributedtype">AttributedType</h3>
<p>Syntax:</p>
<pre><code>!hl.attributed&lt;
  Type   # elementType
&gt;
</code></pre>
<h4 id="parameters_11">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">elementType</td>
<td style="text-align: center;"><code>Type</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="bfloat16type">BFloat16Type</h3>
<p>Syntax:</p>
<pre><code>!hl.bfloat16&lt;
  CVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_12">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="booltype">BoolType</h3>
<p>Syntax:</p>
<pre><code>!hl.bool&lt;
  CVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_13">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="chartype">CharType</h3>
<p>Syntax:</p>
<pre><code>!hl.char&lt;
  UCVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_14">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>UCVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="decayedtype">DecayedType</h3>
<p>Syntax:</p>
<pre><code>!hl.decayed&lt;
  Type   # elementType
&gt;
</code></pre>
<h4 id="parameters_15">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">elementType</td>
<td style="text-align: center;"><code>Type</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="doubletype">DoubleType</h3>
<p>Syntax:</p>
<pre><code>!hl.double&lt;
  CVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_16">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="elaboratedtype">ElaboratedType</h3>
<p>Syntax:</p>
<pre><code>!hl.elaborated&lt;
  Type,   # elementType
  CVRQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_17">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">elementType</td>
<td style="text-align: center;"><code>Type</code></td>
<td></td>
</tr>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVRQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="enumtype">EnumType</h3>
<p>Syntax:</p>
<pre><code>!hl.enum&lt;
  ::llvm::StringRef,   # name
  CVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_18">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">name</td>
<td style="text-align: center;"><code>::llvm::StringRef</code></td>
<td></td>
</tr>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="float128type">Float128Type</h3>
<p>Syntax:</p>
<pre><code>!hl.float128&lt;
  CVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_19">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="floattype">FloatType</h3>
<p>Syntax:</p>
<pre><code>!hl.float&lt;
  CVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_20">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="halftype">HalfType</h3>
<p>Syntax:</p>
<pre><code>!hl.half&lt;
  CVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_21">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="int128type">Int128Type</h3>
<p>Syntax:</p>
<pre><code>!hl.int128&lt;
  UCVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_22">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>UCVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="inttype">IntType</h3>
<p>Syntax:</p>
<pre><code>!hl.int&lt;
  UCVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_23">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>UCVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="lvaluetype">LValueType</h3>
<p>Syntax:</p>
<pre><code>!hl.lvalue&lt;
  Type   # elementType
&gt;
</code></pre>
<h4 id="parameters_24">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">elementType</td>
<td style="text-align: center;"><code>Type</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="labeltype">LabelType</h3>
<p>Syntax: <code>!hl.label</code></p>
<h3 id="longdoubletype">LongDoubleType</h3>
<p>Syntax:</p>
<pre><code>!hl.longdouble&lt;
  CVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_25">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="longlongtype">LongLongType</h3>
<p>Syntax:</p>
<pre><code>!hl.longlong&lt;
  UCVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_26">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>UCVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="longtype">LongType</h3>
<p>Syntax:</p>
<pre><code>!hl.long&lt;
  UCVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_27">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>UCVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="parentype">ParenType</h3>
<p>Syntax:</p>
<pre><code>!hl.paren&lt;
  Type   # elementType
&gt;
</code></pre>
<h4 id="parameters_28">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">elementType</td>
<td style="text-align: center;"><code>Type</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="pointertype">PointerType</h3>
<p>Syntax:</p>
<pre><code>!hl.ptr&lt;
  Type,   # elementType
  CVRQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_29">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">elementType</td>
<td style="text-align: center;"><code>Type</code></td>
<td></td>
</tr>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVRQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="rvaluetype">RValueType</h3>
<p>Syntax:</p>
<pre><code>!hl.rvalue&lt;
  Type   # elementType
&gt;
</code></pre>
<h4 id="parameters_30">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">elementType</td>
<td style="text-align: center;"><code>Type</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="recordtype">RecordType</h3>
<p>Syntax:</p>
<pre><code>!hl.record&lt;
  ::llvm::StringRef,   # name
  CVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_31">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">name</td>
<td style="text-align: center;"><code>::llvm::StringRef</code></td>
<td></td>
</tr>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="referencetype">ReferenceType</h3>
<p>Syntax:</p>
<pre><code>!hl.reference&lt;
  Type   # elementType
&gt;
</code></pre>
<h4 id="parameters_32">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">elementType</td>
<td style="text-align: center;"><code>Type</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="shorttype">ShortType</h3>
<p>Syntax:</p>
<pre><code>!hl.short&lt;
  UCVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_33">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>UCVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="typedeftype">TypedefType</h3>
<p>Syntax:</p>
<pre><code>!hl.typedef&lt;
  ::llvm::StringRef,   # name
  CVRQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_34">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">name</td>
<td style="text-align: center;"><code>::llvm::StringRef</code></td>
<td></td>
</tr>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVRQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="voidtype">VoidType</h3>
<p>Syntax:</p>
<pre><code>!hl.void&lt;
  CVQualifiersAttr   # quals
&gt;
</code></pre>
<h4 id="parameters_35">Parameters:</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">C++ type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">quals</td>
<td style="text-align: center;"><code>CVQualifiersAttr</code></td>
<td></td>
</tr>
</tbody>
</table>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/trailofbits/vast" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>

{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"VAST Documentation To generate MLIR docs invoke: cmake --build --preset <build-preset> --target vast-doc","title":"Home"},{"location":"#vast-documentation","text":"To generate MLIR docs invoke: cmake --build --preset <build-preset> --target vast-doc","title":"VAST Documentation"},{"location":"ConversionPasses/","text":"-vast-abify : Transform functions and apply abi conversion to their type. This pass is still a work in progress. -vast-core-to-llvm : VAST Core dialec to LLVM Dialect conversion Converts core dialect operations to LLVM dialect. -vast-hl-structs-to-llvm : Transform hl.struct into llvm types without applying ABI conversions. This pass is still a work in progress. -vast-hl-to-func : Lower high-level functions to func.func operations. Lowers high-level function operations to function dialect. Drops high-level information like linkage attributes. -vast-hl-to-lazy-regions : Transform hl operations that have short-circuiting into lazy operations. This pass is still a work in progress. -vast-hl-to-ll-cf : VAST HL control flow to LL control flow Transforms high level control flow operations into their low level representation. This pass is still a work in progress. -vast-hl-to-ll-geps : Convert hl.member to ll.gep This pass is still a work in progress. -vast-hl-to-ll-vars : Convert hl variables into ll versions. This pass is still a work in progress. -vast-irs-to-llvm : VAST to LLVM Dialect conversion Converts lowest level VAST operations to LLVM dialect. It is expected that module being converted was already lowered by other VAST passes. This pass is still a work in progress. -vast-lower-abi : Lower abi operations. This pass is still a work in progress.","title":"ConversionPasses"},{"location":"ConversionPasses/#-vast-abify-transform-functions-and-apply-abi-conversion-to-their-type","text":"This pass is still a work in progress.","title":"-vast-abify: Transform functions and apply abi conversion to their type."},{"location":"ConversionPasses/#-vast-core-to-llvm-vast-core-dialec-to-llvm-dialect-conversion","text":"Converts core dialect operations to LLVM dialect.","title":"-vast-core-to-llvm: VAST Core dialec to LLVM Dialect conversion"},{"location":"ConversionPasses/#-vast-hl-structs-to-llvm-transform-hlstruct-into-llvm-types-without-applying-abi-conversions","text":"This pass is still a work in progress.","title":"-vast-hl-structs-to-llvm: Transform hl.struct into llvm types without applying ABI conversions."},{"location":"ConversionPasses/#-vast-hl-to-func-lower-high-level-functions-to-funcfunc-operations","text":"Lowers high-level function operations to function dialect. Drops high-level information like linkage attributes.","title":"-vast-hl-to-func: Lower high-level functions to func.func operations."},{"location":"ConversionPasses/#-vast-hl-to-lazy-regions-transform-hl-operations-that-have-short-circuiting-into-lazy-operations","text":"This pass is still a work in progress.","title":"-vast-hl-to-lazy-regions: Transform hl operations that have short-circuiting into lazy operations."},{"location":"ConversionPasses/#-vast-hl-to-ll-cf-vast-hl-control-flow-to-ll-control-flow","text":"Transforms high level control flow operations into their low level representation. This pass is still a work in progress.","title":"-vast-hl-to-ll-cf: VAST HL control flow to LL control flow"},{"location":"ConversionPasses/#-vast-hl-to-ll-geps-convert-hlmember-to-llgep","text":"This pass is still a work in progress.","title":"-vast-hl-to-ll-geps: Convert hl.member to ll.gep"},{"location":"ConversionPasses/#-vast-hl-to-ll-vars-convert-hl-variables-into-ll-versions","text":"This pass is still a work in progress.","title":"-vast-hl-to-ll-vars: Convert hl variables into ll versions."},{"location":"ConversionPasses/#-vast-irs-to-llvm-vast-to-llvm-dialect-conversion","text":"Converts lowest level VAST operations to LLVM dialect. It is expected that module being converted was already lowered by other VAST passes. This pass is still a work in progress.","title":"-vast-irs-to-llvm: VAST to LLVM Dialect conversion"},{"location":"ConversionPasses/#-vast-lower-abi-lower-abi-operations","text":"This pass is still a work in progress.","title":"-vast-lower-abi: Lower abi operations."},{"location":"HighLevelPasses/","text":"-vast-export-fn-info : Create JSON that exports information about function arguments. Lowers module into llvm IR and dumps it on stderr. Options -o : Output JSON file to be created. -vast-hl-dce : Trim dead code Removes unreachable code, such as code after return or break/continue. -vast-hl-lower-types : Lower high-level types to standard types Lower high-level types into standard types which is usually required first step by other passes in the pipeline. Information about bit sizes of high level types is inferred from the data layout of the module, which is derived from the information provided by clang and emitted automatically by vast-cc . TODO: Named types are not yet supported. -vast-hl-lower-typedefs : Remove `hl::TypeDef type from types. Resolve typedefs types - this is usefull for more low-level analysis or transformations. -vast-hl-splice-trailing-scopes : Remove trailing hl::Scope s. Removes trailing scopes. -vast-llvm-dump : Pass for developers to quickly dump module as llvm ir. Lowers module into llvm IR and dumps it on stderr. Options -bc-file : Specify file where to dump the bitcode","title":"HighLevelPasses"},{"location":"HighLevelPasses/#-vast-export-fn-info-create-json-that-exports-information-about-function-arguments","text":"Lowers module into llvm IR and dumps it on stderr.","title":"-vast-export-fn-info: Create JSON that exports information about function arguments."},{"location":"HighLevelPasses/#options","text":"-o : Output JSON file to be created.","title":"Options"},{"location":"HighLevelPasses/#-vast-hl-dce-trim-dead-code","text":"Removes unreachable code, such as code after return or break/continue.","title":"-vast-hl-dce: Trim dead code"},{"location":"HighLevelPasses/#-vast-hl-lower-types-lower-high-level-types-to-standard-types","text":"Lower high-level types into standard types which is usually required first step by other passes in the pipeline. Information about bit sizes of high level types is inferred from the data layout of the module, which is derived from the information provided by clang and emitted automatically by vast-cc . TODO: Named types are not yet supported.","title":"-vast-hl-lower-types: Lower high-level types to standard types"},{"location":"HighLevelPasses/#-vast-hl-lower-typedefs-remove-hltypedef-type-from-types","text":"Resolve typedefs types - this is usefull for more low-level analysis or transformations.","title":"-vast-hl-lower-typedefs: Remove `hl::TypeDef type from types."},{"location":"HighLevelPasses/#-vast-hl-splice-trailing-scopes-remove-trailing-hlscopes","text":"Removes trailing scopes.","title":"-vast-hl-splice-trailing-scopes: Remove trailing hl::Scopes."},{"location":"HighLevelPasses/#-vast-llvm-dump-pass-for-developers-to-quickly-dump-module-as-llvm-ir","text":"Lowers module into llvm IR and dumps it on stderr.","title":"-vast-llvm-dump: Pass for developers to quickly dump module as llvm ir."},{"location":"HighLevelPasses/#options_1","text":"-bc-file : Specify file where to dump the bitcode","title":"Options"},{"location":"LowLevelPasses/","text":"-vast-ll-to-llvm : Convert low level operations to LLVM dialect. Work in progess.","title":"LowLevelPasses"},{"location":"LowLevelPasses/#-vast-ll-to-llvm-convert-low-level-operations-to-llvm-dialect","text":"Work in progess.","title":"-vast-ll-to-llvm: Convert low level operations to LLVM dialect."},{"location":"ABI/ABI/","text":"'abi' Dialect A vast ABI dialect. Dialect provides operations to describe how arguments and return values are transformed to better model target abi. 'abi' Dialect Operation definition abi.call_args (::vast::abi::CallArgsOp) Results: abi.call_exec (::vast::abi::CallExecutionOp) Attributes: Operands: Results: abi.call (::vast::abi::CallOp) Attributes: Operands: Results: abi.call_rets (::vast::abi::CallRetsOp) Results: abi.direct (::vast::abi::DirectOp) Operands: Results: abi.epilogue (::vast::abi::EpilogueOp) Results: abi.func (::vast::abi::FuncOp) Attributes: abi.prologue (::vast::abi::PrologueOp) Results: abi.ret_direct (::vast::abi::RetDirectOp) Operands: Results: abi.todo (::vast::abi::TodoOp) Operands: Results: abi.wrap_fn (::vast::abi::WrapFuncOp) Attributes: abi.yield (::vast::abi::YieldOp) Operands: Results: Operation definition abi.call_args (::vast::abi::CallArgsOp) Not implement yet. WIP Results: Result Description results any type abi.call_exec (::vast::abi::CallExecutionOp) WIP WIP Interfaces: CallOpInterface Attributes: Attribute MLIR Type Description callee ::mlir::FlatSymbolRefAttr flat symbol reference attribute Operands: Operand Description args any type Results: Result Description result any type abi.call (::vast::abi::CallOp) ABI call operation ABI call operation Interfaces: CallOpInterface Attributes: Attribute MLIR Type Description callee ::mlir::FlatSymbolRefAttr flat symbol reference attribute Operands: Operand Description args any type Results: Result Description results any type abi.call_rets (::vast::abi::CallRetsOp) Not implement yet. WIP Results: Result Description results any type abi.direct (::vast::abi::DirectOp) Pass value directly - usually means by register Pass value directly - usually means by register. Operands: Operand Description value any type Results: Result Description result any type abi.epilogue (::vast::abi::EpilogueOp) WIP WIP Results: Result Description results any type abi.func (::vast::abi::FuncOp) Function with transformed type. Placeholder. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, Symbol Attributes: Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::hl::GlobalLinkageKindAttr Linkage type/kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes abi.prologue (::vast::abi::PrologueOp) WIP WIP Results: Result Description results any type abi.ret_direct (::vast::abi::RetDirectOp) Value is returned directly. Value is returned directly. Operands: Operand Description value any type Results: Result Description result any type abi.todo (::vast::abi::TodoOp) Not implement yet. Not implemented yet Operands: Operand Description value any type Results: Result Description result any type abi.wrap_fn (::vast::abi::WrapFuncOp) Function that defines abi transformation of args. Placeholder. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, Symbol Attributes: Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::hl::GlobalLinkageKindAttr Linkage type/kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes abi.yield (::vast::abi::YieldOp) WIP WIP Traits: Terminator Operands: Operand Description values any type Results: Result Description result any type","title":"ABI"},{"location":"ABI/ABI/#abi-dialect","text":"A vast ABI dialect. Dialect provides operations to describe how arguments and return values are transformed to better model target abi. 'abi' Dialect Operation definition abi.call_args (::vast::abi::CallArgsOp) Results: abi.call_exec (::vast::abi::CallExecutionOp) Attributes: Operands: Results: abi.call (::vast::abi::CallOp) Attributes: Operands: Results: abi.call_rets (::vast::abi::CallRetsOp) Results: abi.direct (::vast::abi::DirectOp) Operands: Results: abi.epilogue (::vast::abi::EpilogueOp) Results: abi.func (::vast::abi::FuncOp) Attributes: abi.prologue (::vast::abi::PrologueOp) Results: abi.ret_direct (::vast::abi::RetDirectOp) Operands: Results: abi.todo (::vast::abi::TodoOp) Operands: Results: abi.wrap_fn (::vast::abi::WrapFuncOp) Attributes: abi.yield (::vast::abi::YieldOp) Operands: Results:","title":"'abi' Dialect"},{"location":"ABI/ABI/#operation-definition","text":"","title":"Operation definition"},{"location":"ABI/ABI/#abicall_args-vastabicallargsop","text":"Not implement yet. WIP","title":"abi.call_args (::vast::abi::CallArgsOp)"},{"location":"ABI/ABI/#results","text":"Result Description results any type","title":"Results:"},{"location":"ABI/ABI/#abicall_exec-vastabicallexecutionop","text":"WIP WIP Interfaces: CallOpInterface","title":"abi.call_exec (::vast::abi::CallExecutionOp)"},{"location":"ABI/ABI/#attributes","text":"Attribute MLIR Type Description callee ::mlir::FlatSymbolRefAttr flat symbol reference attribute","title":"Attributes:"},{"location":"ABI/ABI/#operands","text":"Operand Description args any type","title":"Operands:"},{"location":"ABI/ABI/#results_1","text":"Result Description result any type","title":"Results:"},{"location":"ABI/ABI/#abicall-vastabicallop","text":"ABI call operation ABI call operation Interfaces: CallOpInterface","title":"abi.call (::vast::abi::CallOp)"},{"location":"ABI/ABI/#attributes_1","text":"Attribute MLIR Type Description callee ::mlir::FlatSymbolRefAttr flat symbol reference attribute","title":"Attributes:"},{"location":"ABI/ABI/#operands_1","text":"Operand Description args any type","title":"Operands:"},{"location":"ABI/ABI/#results_2","text":"Result Description results any type","title":"Results:"},{"location":"ABI/ABI/#abicall_rets-vastabicallretsop","text":"Not implement yet. WIP","title":"abi.call_rets (::vast::abi::CallRetsOp)"},{"location":"ABI/ABI/#results_3","text":"Result Description results any type","title":"Results:"},{"location":"ABI/ABI/#abidirect-vastabidirectop","text":"Pass value directly - usually means by register Pass value directly - usually means by register.","title":"abi.direct (::vast::abi::DirectOp)"},{"location":"ABI/ABI/#operands_2","text":"Operand Description value any type","title":"Operands:"},{"location":"ABI/ABI/#results_4","text":"Result Description result any type","title":"Results:"},{"location":"ABI/ABI/#abiepilogue-vastabiepilogueop","text":"WIP WIP","title":"abi.epilogue (::vast::abi::EpilogueOp)"},{"location":"ABI/ABI/#results_5","text":"Result Description results any type","title":"Results:"},{"location":"ABI/ABI/#abifunc-vastabifuncop","text":"Function with transformed type. Placeholder. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, Symbol","title":"abi.func (::vast::abi::FuncOp)"},{"location":"ABI/ABI/#attributes_2","text":"Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::hl::GlobalLinkageKindAttr Linkage type/kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes","title":"Attributes:"},{"location":"ABI/ABI/#abiprologue-vastabiprologueop","text":"WIP WIP","title":"abi.prologue (::vast::abi::PrologueOp)"},{"location":"ABI/ABI/#results_6","text":"Result Description results any type","title":"Results:"},{"location":"ABI/ABI/#abiret_direct-vastabiretdirectop","text":"Value is returned directly. Value is returned directly.","title":"abi.ret_direct (::vast::abi::RetDirectOp)"},{"location":"ABI/ABI/#operands_3","text":"Operand Description value any type","title":"Operands:"},{"location":"ABI/ABI/#results_7","text":"Result Description result any type","title":"Results:"},{"location":"ABI/ABI/#abitodo-vastabitodoop","text":"Not implement yet. Not implemented yet","title":"abi.todo (::vast::abi::TodoOp)"},{"location":"ABI/ABI/#operands_4","text":"Operand Description value any type","title":"Operands:"},{"location":"ABI/ABI/#results_8","text":"Result Description result any type","title":"Results:"},{"location":"ABI/ABI/#abiwrap_fn-vastabiwrapfuncop","text":"Function that defines abi transformation of args. Placeholder. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, Symbol","title":"abi.wrap_fn (::vast::abi::WrapFuncOp)"},{"location":"ABI/ABI/#attributes_3","text":"Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::hl::GlobalLinkageKindAttr Linkage type/kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes","title":"Attributes:"},{"location":"ABI/ABI/#abiyield-vastabiyieldop","text":"WIP WIP Traits: Terminator","title":"abi.yield (::vast::abi::YieldOp)"},{"location":"ABI/ABI/#operands_5","text":"Operand Description values any type","title":"Operands:"},{"location":"ABI/ABI/#results_9","text":"Result Description result any type","title":"Results:"},{"location":"Core/Core/","text":"'core' Dialect Utility dialect to provide common features for other dialects. Dialect providing features that may be used by other dialects. These features can be used by including \"vast/Dialect/Core/Utils.td\" It also provides lazy.op for lazy evaluation of expressions and binary logical operations that make use of it. 'core' Dialect Operation definition core.bin.land (::vast::core::BinLAndOp) Operands: Results: core.bin.lor (::vast::core::BinLOrOp) Operands: Results: core.lazy.op (::vast::core::LazyOp) Results: core.select (::vast::core::SelectOp) Operands: Results: Operation definition core.bin.land (::vast::core::BinLAndOp) VAST core dialect logical binary operation Syntax: operation ::= `core.bin.land` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) Core dialect logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type Operands: Operand Description lhs any type rhs any type Results: Result Description result any type core.bin.lor (::vast::core::BinLOrOp) VAST core dialect logical binary operation Syntax: operation ::= `core.bin.lor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) Core dialect logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type Operands: Operand Description lhs any type rhs any type Results: Result Description result any type core.lazy.op (::vast::core::LazyOp) Lazily evaluate a region. Syntax: operation ::= `core.lazy.op` $lazy attr-dict `:` type(results) The operation serves to encapsulate delayed evaluation in its region. Traits: NoTerminator Results: Result Description result any type core.select (::vast::core::SelectOp) Select a value based on condition. Syntax: operation ::= `core.select` $cond `,` $thenRegion `,` $elseRegion attr-dict `:` functional-type(operands, results) Usual select operation. First operand is selected if predicate is true, second otherwise (to mirror how ternary works in C). %result = %cond %lhs, %rhs : type Operands: Operand Description cond any type thenRegion any type elseRegion any type Results: Result Description results any type","title":"Core"},{"location":"Core/Core/#core-dialect","text":"Utility dialect to provide common features for other dialects. Dialect providing features that may be used by other dialects. These features can be used by including \"vast/Dialect/Core/Utils.td\" It also provides lazy.op for lazy evaluation of expressions and binary logical operations that make use of it. 'core' Dialect Operation definition core.bin.land (::vast::core::BinLAndOp) Operands: Results: core.bin.lor (::vast::core::BinLOrOp) Operands: Results: core.lazy.op (::vast::core::LazyOp) Results: core.select (::vast::core::SelectOp) Operands: Results:","title":"'core' Dialect"},{"location":"Core/Core/#operation-definition","text":"","title":"Operation definition"},{"location":"Core/Core/#corebinland-vastcorebinlandop","text":"VAST core dialect logical binary operation Syntax: operation ::= `core.bin.land` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) Core dialect logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type","title":"core.bin.land (::vast::core::BinLAndOp)"},{"location":"Core/Core/#operands","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"Core/Core/#results","text":"Result Description result any type","title":"Results:"},{"location":"Core/Core/#corebinlor-vastcorebinlorop","text":"VAST core dialect logical binary operation Syntax: operation ::= `core.bin.lor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) Core dialect logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type","title":"core.bin.lor (::vast::core::BinLOrOp)"},{"location":"Core/Core/#operands_1","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"Core/Core/#results_1","text":"Result Description result any type","title":"Results:"},{"location":"Core/Core/#corelazyop-vastcorelazyop","text":"Lazily evaluate a region. Syntax: operation ::= `core.lazy.op` $lazy attr-dict `:` type(results) The operation serves to encapsulate delayed evaluation in its region. Traits: NoTerminator","title":"core.lazy.op (::vast::core::LazyOp)"},{"location":"Core/Core/#results_2","text":"Result Description result any type","title":"Results:"},{"location":"Core/Core/#coreselect-vastcoreselectop","text":"Select a value based on condition. Syntax: operation ::= `core.select` $cond `,` $thenRegion `,` $elseRegion attr-dict `:` functional-type(operands, results) Usual select operation. First operand is selected if predicate is true, second otherwise (to mirror how ternary works in C). %result = %cond %lhs, %rhs : type","title":"core.select (::vast::core::SelectOp)"},{"location":"Core/Core/#operands_2","text":"Operand Description cond any type thenRegion any type elseRegion any type","title":"Operands:"},{"location":"Core/Core/#results_3","text":"Result Description results any type","title":"Results:"},{"location":"Designs/abi/","text":"ABI VAST partially models ABI specifications for function types and therefore callsites. While the specification goes into details regarding registers, for now VAST only offers lowering similar to what clang codegen does - argument and return types are coerced to types that will easily fit their respective registers once that allocation takes place. There is nothing preventing inclusion of information about registers as well (for example as metadata or separate operations/dialect), however it is not yet implemented. Similar to other transformation in VAST, ABI modelling tries to be as modular as possible and as such can be split into three distinct steps: Compute classification of types Encode computed classification into module Lower transformed module into some \"executable\" dialect Main goal for now is to lower function prototypes to match the types produced by clang, so that VAST emitted LLVM can be used as drop-in replacement for clang one. When reading this document please keep in mind that implementation of this feature is still ongoing and therefore particular technical details could change drastically (although we hope that overall design will remain the same). Classification Mirrors what clang does, but instead of locking the computed information away, we expose the API. In ideal world we would like to keep the algorithm(s, as there may be multiple per different ABIs) generic. This can be achieved by requiring users to implement & provide interface that specifies various details about used types; algorithm will be same when talking about hl or LLVM types after all. ABI Dialect Once classification for a function is computed, we need to: Change function prototype Encode how new types match to the old types + some oddities such as sret . To facilitate this, VAST contains abi dialect, which operations encode \"high-level\" descriptions of type transformations that can occur during ABI lowering as operations. This is not very different from what clang does, but VAST does it over multiple steps. For functions, type change itself is easy and to mark that function is transformed, abi.func operation is used instead of original one to define the newly formed function. However, as arguments and return types are different, we introduce abi.prologue and abi.epilogue operations. Consider following function we want to lower: Disclaimer: Since abi dialect does not have nice formatting, therefore examples in this section contain some artistic liberty, but semantics (and operations) are preserved. strut Point{ int; int; int; }; int size( struct Point p ) { ... } After running the classification, we discover that type of size should be ( i64, i32 ) -> i32 - both arguments and returned value are passed directly. Therefore we encode it as follows: abi.func size(i64 %arg0_0, i32 %arg0_1 ) -> i32 { %arg = abi.prologue -> hl.lvalue< hl.struct< \"Point\" > > { %0 = abi.direct %arg0_0, %arg0_1: (i64, i32) -> hl.struct< \"Point\" > abi.yield %0 } // Computation can continue as before, because %arg has a correct type %ret = ... value that was previously returned ... -> i32 %out = abi.epilogue { %0 = abi.direct %ret: i32 -> i32 abi.yield %0 } hl.return %out } In case, there were multiple function arguments, the abi.prologue would return more values. %args = abi.prologue -> (hl.lvalue< hl.struct< \"Point\" > >, i32 ) { %0 = abi.direct %arg0_0, %arg0_1 %1 = abi.direct %arg1 abi.yield %0, %1 } TODO: Add extra examples, at least memory and sret . This design allows easy analysis and subsequent rewrite (as each function has a prologue and epilogue and returned values are explicitly yielded). Callsites are transformed in the same manner (unfortunately, they look more complicated due to nested regions): %x = hl.call< \"size\" > %arg: hl.struct< \"Point\" > -> i32 %x = abi.call< \"size\" >: () -> i32 { %arg0_0, %arg0_1 = abi.call_args: () -> (i64, i32) { %0, %1 = abi.direct %arg abi.yield %0, %1 } %x' = hl.call< \"size\" > %arg0_0, &arg0_1 : (i64, i32) -> i32 %0 = abi.call_rets : () -> i32 { %0 = abi.direct %x' : i32 -> i32 abi.yield %0 } abi.yield %0 } For now, same abi operations are used to encode transformation in callsite and function (although they change the value in a \"opposite direction\"), this may be later revisited, but for now it is enough to look at the parent operation to determine whether the transformation lies in a function or callsite. Lowering to some executable dialect While abi dialect provides us with all the information required to do the transformation, it does not \"compute\" anything. Rather this lowering is left to a next pass. We hope by splitting the transformation into 2, we achieve the following: We can implement multiple \"backends\" - whether back to hl , llvm or totally random dialect of user choice. Re-use existing implementation of classification algorithm.","title":"Abi"},{"location":"Designs/abi/#abi","text":"VAST partially models ABI specifications for function types and therefore callsites. While the specification goes into details regarding registers, for now VAST only offers lowering similar to what clang codegen does - argument and return types are coerced to types that will easily fit their respective registers once that allocation takes place. There is nothing preventing inclusion of information about registers as well (for example as metadata or separate operations/dialect), however it is not yet implemented. Similar to other transformation in VAST, ABI modelling tries to be as modular as possible and as such can be split into three distinct steps: Compute classification of types Encode computed classification into module Lower transformed module into some \"executable\" dialect Main goal for now is to lower function prototypes to match the types produced by clang, so that VAST emitted LLVM can be used as drop-in replacement for clang one. When reading this document please keep in mind that implementation of this feature is still ongoing and therefore particular technical details could change drastically (although we hope that overall design will remain the same).","title":"ABI"},{"location":"Designs/abi/#classification","text":"Mirrors what clang does, but instead of locking the computed information away, we expose the API. In ideal world we would like to keep the algorithm(s, as there may be multiple per different ABIs) generic. This can be achieved by requiring users to implement & provide interface that specifies various details about used types; algorithm will be same when talking about hl or LLVM types after all.","title":"Classification"},{"location":"Designs/abi/#abi-dialect","text":"Once classification for a function is computed, we need to: Change function prototype Encode how new types match to the old types + some oddities such as sret . To facilitate this, VAST contains abi dialect, which operations encode \"high-level\" descriptions of type transformations that can occur during ABI lowering as operations. This is not very different from what clang does, but VAST does it over multiple steps. For functions, type change itself is easy and to mark that function is transformed, abi.func operation is used instead of original one to define the newly formed function. However, as arguments and return types are different, we introduce abi.prologue and abi.epilogue operations. Consider following function we want to lower: Disclaimer: Since abi dialect does not have nice formatting, therefore examples in this section contain some artistic liberty, but semantics (and operations) are preserved. strut Point{ int; int; int; }; int size( struct Point p ) { ... } After running the classification, we discover that type of size should be ( i64, i32 ) -> i32 - both arguments and returned value are passed directly. Therefore we encode it as follows: abi.func size(i64 %arg0_0, i32 %arg0_1 ) -> i32 { %arg = abi.prologue -> hl.lvalue< hl.struct< \"Point\" > > { %0 = abi.direct %arg0_0, %arg0_1: (i64, i32) -> hl.struct< \"Point\" > abi.yield %0 } // Computation can continue as before, because %arg has a correct type %ret = ... value that was previously returned ... -> i32 %out = abi.epilogue { %0 = abi.direct %ret: i32 -> i32 abi.yield %0 } hl.return %out } In case, there were multiple function arguments, the abi.prologue would return more values. %args = abi.prologue -> (hl.lvalue< hl.struct< \"Point\" > >, i32 ) { %0 = abi.direct %arg0_0, %arg0_1 %1 = abi.direct %arg1 abi.yield %0, %1 } TODO: Add extra examples, at least memory and sret . This design allows easy analysis and subsequent rewrite (as each function has a prologue and epilogue and returned values are explicitly yielded). Callsites are transformed in the same manner (unfortunately, they look more complicated due to nested regions): %x = hl.call< \"size\" > %arg: hl.struct< \"Point\" > -> i32 %x = abi.call< \"size\" >: () -> i32 { %arg0_0, %arg0_1 = abi.call_args: () -> (i64, i32) { %0, %1 = abi.direct %arg abi.yield %0, %1 } %x' = hl.call< \"size\" > %arg0_0, &arg0_1 : (i64, i32) -> i32 %0 = abi.call_rets : () -> i32 { %0 = abi.direct %x' : i32 -> i32 abi.yield %0 } abi.yield %0 } For now, same abi operations are used to encode transformation in callsite and function (although they change the value in a \"opposite direction\"), this may be later revisited, but for now it is enough to look at the parent operation to determine whether the transformation lies in a function or callsite.","title":"ABI Dialect"},{"location":"Designs/abi/#lowering-to-some-executable-dialect","text":"While abi dialect provides us with all the information required to do the transformation, it does not \"compute\" anything. Rather this lowering is left to a next pass. We hope by splitting the transformation into 2, we achieve the following: We can implement multiple \"backends\" - whether back to hl , llvm or totally random dialect of user choice. Re-use existing implementation of classification algorithm.","title":"Lowering to some executable dialect"},{"location":"Designs/cpp2-parameters/","text":"Lifting parameter passing [https://github.com/hsutter/708/blob/main/708.pdf] The proposed way of parameter passing for next-gen c++ is to use declarative style: f( in X x) // x can be read from f( inout X x) // x can be used in read and write f( out X x) // x can be writen to f( move X x) // x will be moved from f(forward X x) // x will be passed along Similar holds for return values: auto f() move X { /* ... */ } // move X to caller auto f() X { /* ... */ } // possibly same auto f() forward X { /* ... */ } // pass along X to the caller Using the semantics aware vast dialects, we can design a method to automatically modernize code to use a declarative style of parameter passing. Examples CPP CPP2 void f(const X& x) { g(x); } void f(in X x) { g(x); } VAST high-level dialect Transformed to parameter dialect hl.func @f(%x: !hl.ref < !hl.lvalue < !hl.struct < \"X\" > >, const >) { %0 = hl.call @g(%x) : (!hl.ref < !hl.lvalue < !hl.struct < \"X\" > >, const >) -> !hl.void } hl.func @f(%x: !par.in < !hl.lvalue < !hl.struct < \"X\" > > >) { %0 = hl.call @g(%x) : (!par.in < !hl.lvalue < !hl.struct < \"X\" > > >) -> !hl.void } The transformation will be probably overapproximating, in cases when the analysis cannot determine the precise category, i.e., inout oveapproximates in and out parameters. Dialect The dialect will define type adaptors for each parameter category: !par.in< T > !par.out< T > !par.inout< T > !par.move< T > !par.forward< T > Parameter categories can also be present as type attributes not to mess up the rest of the type trait system. This needs further investigation. The advantage of the type adaptors we can enforce the correct usage of values. For example, we can forbid usage of out parameter in other places than assignment.","title":"Cpp2 parameters"},{"location":"Designs/cpp2-parameters/#lifting-parameter-passing-httpsgithubcomhsutter708blobmain708pdf","text":"The proposed way of parameter passing for next-gen c++ is to use declarative style: f( in X x) // x can be read from f( inout X x) // x can be used in read and write f( out X x) // x can be writen to f( move X x) // x will be moved from f(forward X x) // x will be passed along Similar holds for return values: auto f() move X { /* ... */ } // move X to caller auto f() X { /* ... */ } // possibly same auto f() forward X { /* ... */ } // pass along X to the caller Using the semantics aware vast dialects, we can design a method to automatically modernize code to use a declarative style of parameter passing.","title":"Lifting parameter passing [https://github.com/hsutter/708/blob/main/708.pdf]"},{"location":"Designs/cpp2-parameters/#examples","text":"CPP CPP2 void f(const X& x) { g(x); } void f(in X x) { g(x); } VAST high-level dialect Transformed to parameter dialect hl.func @f(%x: !hl.ref < !hl.lvalue < !hl.struct < \"X\" > >, const >) { %0 = hl.call @g(%x) : (!hl.ref < !hl.lvalue < !hl.struct < \"X\" > >, const >) -> !hl.void } hl.func @f(%x: !par.in < !hl.lvalue < !hl.struct < \"X\" > > >) { %0 = hl.call @g(%x) : (!par.in < !hl.lvalue < !hl.struct < \"X\" > > >) -> !hl.void } The transformation will be probably overapproximating, in cases when the analysis cannot determine the precise category, i.e., inout oveapproximates in and out parameters.","title":"Examples"},{"location":"Designs/cpp2-parameters/#dialect","text":"The dialect will define type adaptors for each parameter category: !par.in< T > !par.out< T > !par.inout< T > !par.move< T > !par.forward< T > Parameter categories can also be present as type attributes not to mess up the rest of the type trait system. This needs further investigation. The advantage of the type adaptors we can enforce the correct usage of values. For example, we can forbid usage of out parameter in other places than assignment.","title":"Dialect"},{"location":"Examples/Codegen/","text":"","title":"Codegen"},{"location":"HighLevel/HighLevel/","text":"'hl' Dialect A high-level verbose program analysis MLIR dialect. This dialect intends capture highevel constructs of C/C++ for further program analysis. 'hl' Dialect Operation definition hl.access (::vast::hl::AccessSpecifierOp) Attributes: hl.assign.fadd (::vast::hl::AddFAssignOp) Operands: Results: hl.fadd (::vast::hl::AddFOp) Operands: Results: hl.assign.add (::vast::hl::AddIAssignOp) Operands: Results: hl.add (::vast::hl::AddIOp) Operands: Results: hl.labeladdr (::vast::hl::AddrLabelExpr) Operands: Results: hl.addressof (::vast::hl::AddressOf) Operands: Results: hl.alignof.expr (::vast::hl::AlignOfExprOp) Results: hl.alignof.type (::vast::hl::AlignOfTypeOp) Attributes: Results: hl.assign (::vast::hl::AssignOp) Operands: Results: hl.assign.bin.and (::vast::hl::BinAndAssignOp) Operands: Results: hl.bin.and (::vast::hl::BinAndOp) Operands: Results: hl.bin.comma (::vast::hl::BinComma) Operands: Results: hl.bin.land (::vast::hl::BinLAndOp) Results: hl.bin.lor (::vast::hl::BinLOrOp) Results: hl.assign.bin.or (::vast::hl::BinOrAssignOp) Operands: Results: hl.bin.or (::vast::hl::BinOrOp) Operands: Results: hl.assign.bin.shl (::vast::hl::BinShlAssignOp) Operands: Results: hl.bin.shl (::vast::hl::BinShlOp) Operands: Results: hl.assign.bin.shr (::vast::hl::BinShrAssignOp) Operands: Results: hl.bin.shr (::vast::hl::BinShrOp) Operands: Results: hl.assign.bin.xor (::vast::hl::BinXorAssignOp) Operands: Results: hl.bin.xor (::vast::hl::BinXorOp) Operands: Results: hl.builtin_bitcast (::vast::hl::BuiltinBitCastOp) Attributes: Operands: Results: hl.cstyle_cast (::vast::hl::CStyleCastOp) Attributes: Operands: Results: hl.call (::vast::hl::CallOp) Attributes: Operands: Results: hl.class (::vast::hl::ClassDeclOp) Attributes: hl.cmp (::vast::hl::CmpOp) Attributes: Operands: Results: hl.const (::vast::hl::ConstantOp) Attributes: Results: hl.base (::vast::hl::CxxBaseSpecifierOp) Attributes: hl.cxxstruct (::vast::hl::CxxStructDeclOp) Attributes: hl.ref (::vast::hl::DeclRefOp) Operands: Results: hl.deref (::vast::hl::Deref) Operands: Results: hl.assign.fdiv (::vast::hl::DivFAssignOp) Operands: Results: hl.fdiv (::vast::hl::DivFOp) Operands: Results: hl.assign.sdiv (::vast::hl::DivSAssignOp) Operands: Results: hl.sdiv (::vast::hl::DivSOp) Operands: Results: hl.assign.udiv (::vast::hl::DivUAssignOp) Operands: Results: hl.udiv (::vast::hl::DivUOp) Operands: Results: hl.enum.const (::vast::hl::EnumConstantOp) Attributes: hl.enum (::vast::hl::EnumDeclOp) Attributes: hl.enumref (::vast::hl::EnumRefOp) Attributes: Results: hl.expr (::vast::hl::ExprOp) Results: hl.gnu.extension (::vast::hl::ExtensionOp) Operands: Results: hl.fcmp (::vast::hl::FCmpOp) Attributes: Operands: Results: hl.field (::vast::hl::FieldDeclOp) Attributes: hl.func (::vast::hl::FuncOp) Attributes: hl.funcref (::vast::hl::FuncRefOp) Attributes: Results: hl.globref (::vast::hl::GlobalRefOp) Attributes: Results: hl.break (::vast::hl::BreakOp) hl.case (::vast::hl::CaseOp) hl.cond (::vast::hl::CondOp) Results: hl.cond.yield (::vast::hl::CondYieldOp) Operands: hl.continue (::vast::hl::ContinueOp) hl.default (::vast::hl::DefaultOp) hl.do (::vast::hl::DoOp) hl.for (::vast::hl::ForOp) hl.goto (::vast::hl::GotoStmt) Operands: hl.if (::vast::hl::IfOp) hl.label.decl (::vast::hl::LabelDeclOp) Attributes: Results: hl.label (::vast::hl::LabelStmt) Operands: hl.skip (::vast::hl::SkipStmt) hl.switch (::vast::hl::SwitchOp) hl.value.yield (::vast::hl::ValueYieldOp) Operands: hl.var (::vast::hl::VarDeclOp) Attributes: Results: hl.while (::vast::hl::WhileOp) hl.implicit_cast (::vast::hl::ImplicitCastOp) Attributes: Operands: Results: hl.indirect_call (::vast::hl::IndirectCallOp) Operands: Results: hl.initlist (::vast::hl::InitListExpr) Operands: Results: hl.lnot (::vast::hl::LNotOp) Operands: Results: hl.minus (::vast::hl::MinusOp) Operands: Results: hl.assign.fmul (::vast::hl::MulFAssignOp) Operands: Results: hl.fmul (::vast::hl::MulFOp) Operands: Results: hl.assign.mul (::vast::hl::MulIAssignOp) Operands: Results: hl.mul (::vast::hl::MulIOp) Operands: Results: hl.not (::vast::hl::NotOp) Operands: Results: hl.plus (::vast::hl::PlusOp) Operands: Results: hl.post.dec (::vast::hl::PostDecOp) Operands: Results: hl.post.inc (::vast::hl::PostIncOp) Operands: Results: hl.pre.dec (::vast::hl::PreDecOp) Operands: Results: hl.pre.inc (::vast::hl::PreIncOp) Operands: Results: hl.predefined.expr (::vast::hl::PredefinedExpr) Attributes: Operands: Results: hl.member (::vast::hl::RecordMemberOp) Attributes: Operands: Results: hl.assign.frem (::vast::hl::RemFAssignOp) Operands: Results: hl.frem (::vast::hl::RemFOp) Operands: Results: hl.assign.srem (::vast::hl::RemSAssignOp) Operands: Results: hl.srem (::vast::hl::RemSOp) Operands: Results: hl.assign.urem (::vast::hl::RemUAssignOp) Operands: Results: hl.urem (::vast::hl::RemUOp) Operands: Results: hl.return (::vast::hl::ReturnOp) Operands: hl.scope (::vast::hl::ScopeOp) hl.sizeof.expr (::vast::hl::SizeOfExprOp) Results: hl.sizeof.type (::vast::hl::SizeOfTypeOp) Attributes: Results: hl.stmt.expr (::vast::hl::StmtExprOp) Results: hl.struct (::vast::hl::StructDeclOp) Attributes: hl.assign.fsub (::vast::hl::SubFAssignOp) Operands: Results: hl.fsub (::vast::hl::SubFOp) Operands: Results: hl.assign.sub (::vast::hl::SubIAssignOp) Operands: Results: hl.sub (::vast::hl::SubIOp) Operands: Results: hl.subscript (::vast::hl::SubscriptOp) Operands: Results: hl.this (::vast::hl::ThisOp) Results: hl.translation_unit (::vast::hl::TranslationUnitOp) hl.type (::vast::hl::TypeDeclOp) Attributes: hl.typedef (::vast::hl::TypeDefOp) Attributes: hl.union (::vast::hl::UnionDeclOp) Attributes: hl.unreachable (::vast::hl::UnreachableOp) Attribute definition AnnotationAttr Parameters: BooleanAttr Parameters: CVQualifiersAttr Parameters: CVRQualifiersAttr Parameters: FloatAttr Parameters: IntegerAttr Parameters: StringAttr Parameters: StringLiteralAttr Parameters: UCVQualifiersAttr Parameters: Type definition AdjustedType Parameters: ArrayType Parameters: AttributedType Parameters: BFloat16Type Parameters: BoolType Parameters: CharType Parameters: DecayedType Parameters: DoubleType Parameters: ElaboratedType Parameters: EnumType Parameters: Float128Type Parameters: FloatType Parameters: HalfType Parameters: Int128Type Parameters: IntType Parameters: LValueType Parameters: LabelType LongDoubleType Parameters: LongLongType Parameters: LongType Parameters: ParenType Parameters: PointerType Parameters: RValueType Parameters: RecordType Parameters: ReferenceType Parameters: ShortType Parameters: TypedefType Parameters: VoidType Parameters: Operation definition hl.access (::vast::hl::AccessSpecifierOp) VAST C++ access specifier declaration Syntax: operation ::= `hl.access` attr-dict $spec VAST C++ access specifier declaration Attributes: Attribute MLIR Type Description spec ::vast::hl::AccessSpecifierAttr Access specifier hl.assign.fadd (::vast::hl::AddFAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.fadd` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.fadd (::vast::hl::AddFOp) VAST arithmetic binary operation Syntax: operation ::= `hl.fadd` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.assign.add (::vast::hl::AddIAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.add` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.add (::vast::hl::AddIOp) VAST arithmetic binary operation Syntax: operation ::= `hl.add` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Traits: Commutative Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.labeladdr (::vast::hl::AddrLabelExpr) VAST address of label extension Syntax: operation ::= `hl.labeladdr` $label attr-dict `:` type($result) VAST address of label extension Operands: Operand Description label Results: Result Description result lvalue to pointer like type hl.addressof (::vast::hl::AddressOf) VAST addressof operation Syntax: operation ::= `hl.addressof` $value attr-dict `:` type($value) `->` type($result) VAST addressof operation Operands: Operand Description value lvalue to any type Results: Result Description result any type hl.alignof.expr (::vast::hl::AlignOfExprOp) VAST expr alignof operator Syntax: operation ::= `hl.alignof.expr` attr-dict `->` type($result) $expr VAST expr alignof operator Results: Result Description result integer like type hl.alignof.type (::vast::hl::AlignOfTypeOp) VAST type alignof operator Syntax: operation ::= `hl.alignof.type` $arg attr-dict `->` type($result) VAST type alignof operator Attributes: Attribute MLIR Type Description arg ::mlir::TypeAttr any type attribute Results: Result Description result integer like type hl.assign (::vast::hl::AssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.bin.and (::vast::hl::BinAndAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.bin.and` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.bin.and (::vast::hl::BinAndOp) VAST arithmetic binary operation Syntax: operation ::= `hl.bin.and` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.bin.comma (::vast::hl::BinComma) VAST binary operation Syntax: operation ::= `hl.bin.comma` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) Traits: AttrSizedOperandSegments Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.bin.land (::vast::hl::BinLAndOp) VAST logical binary operation Syntax: operation ::= `hl.bin.land` $lhs`,` $rhs attr-dict `:` type(results) High-level logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type Results: Result Description result any type hl.bin.lor (::vast::hl::BinLOrOp) VAST logical binary operation Syntax: operation ::= `hl.bin.lor` $lhs`,` $rhs attr-dict `:` type(results) High-level logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type Results: Result Description result any type hl.assign.bin.or (::vast::hl::BinOrAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.bin.or` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.bin.or (::vast::hl::BinOrOp) VAST arithmetic binary operation Syntax: operation ::= `hl.bin.or` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.assign.bin.shl (::vast::hl::BinShlAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.bin.shl` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to integer like type dst any type Results: Result Description result integer like type hl.bin.shl (::vast::hl::BinShlOp) VAST binary shift operation Syntax: operation ::= `hl.bin.shl` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level binary shift operation. This operation takes two operands and returns one result. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs integer like type rhs integer like type Results: Result Description result integer like type hl.assign.bin.shr (::vast::hl::BinShrAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.bin.shr` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to integer like type dst any type Results: Result Description result integer like type hl.bin.shr (::vast::hl::BinShrOp) VAST binary shift operation Syntax: operation ::= `hl.bin.shr` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level binary shift operation. This operation takes two operands and returns one result. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs integer like type rhs integer like type Results: Result Description result integer like type hl.assign.bin.xor (::vast::hl::BinXorAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.bin.xor` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.bin.xor (::vast::hl::BinXorOp) VAST arithmetic binary operation Syntax: operation ::= `hl.bin.xor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.builtin_bitcast (::vast::hl::BuiltinBitCastOp) VAST cast operation Syntax: operation ::= `hl.builtin_bitcast` $value $kind attr-dict `:` type($value) `->` type($result) VAST cast operation Attributes: Attribute MLIR Type Description kind ::vast::hl::CastKindAttr cast kind Operands: Operand Description value any type Results: Result Description result any type hl.cstyle_cast (::vast::hl::CStyleCastOp) VAST cast operation Syntax: operation ::= `hl.cstyle_cast` $value $kind attr-dict `:` type($value) `->` type($result) VAST cast operation Attributes: Attribute MLIR Type Description kind ::vast::hl::CastKindAttr cast kind Operands: Operand Description value any type Results: Result Description result any type hl.call (::vast::hl::CallOp) VAST call operation Syntax: operation ::= `hl.call` $callee `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results ) VAST call operation Interfaces: CallOpInterface Attributes: Attribute MLIR Type Description callee ::mlir::FlatSymbolRefAttr flat symbol reference attribute Operands: Operand Description argOperands any type Results: Result Description results any type hl.class (::vast::hl::ClassDeclOp) VAST C++ class declaration Syntax: operation ::= `hl.class` $name attr-dict `:` `bases` $bases $fields VAST C++ class declaration Traits: NoTerminator Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute hl.cmp (::vast::hl::CmpOp) VAST comparison operation Syntax: operation ::= `hl.cmp` $predicate $lhs `,` $rhs attr-dict `:` type(operands) `->` type($result) VAST comparison operation Attributes: Attribute MLIR Type Description predicate ::vast::hl::PredicateAttr comparison predicate Operands: Operand Description lhs any type rhs any type Results: Result Description result bool or integer like type hl.const (::vast::hl::ConstantOp) VAST integral constant Syntax: operation ::= `hl.const` $value attr-dict VAST integral constant Traits: ConstantLike Interfaces: InferTypeOpInterface Attributes: Attribute MLIR Type Description value ::mlir::TypedAttr TypedAttr instance Results: Result Description result any type hl.base (::vast::hl::CxxBaseSpecifierOp) VAST base class specifier Syntax: operation ::= `hl.base` $type attr-dict $access (`virtual` $is_virtual^)? VAST base class specifier Interfaces: VastSymbol Attributes: Attribute MLIR Type Description type ::mlir::TypeAttr any type attribute access ::vast::hl::AccessSpecifierAttr Access specifier is_virtual ::mlir::UnitAttr unit attribute hl.cxxstruct (::vast::hl::CxxStructDeclOp) VAST C++ struct declaration Syntax: operation ::= `hl.cxxstruct` $name attr-dict `:` `bases` $bases $fields VAST C++ struct declaration Traits: NoTerminator Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute hl.ref (::vast::hl::DeclRefOp) VAST variable reference declaration Syntax: operation ::= `hl.ref` $decl attr-dict `:`type(operands) VAST variable reference declaration Interfaces: InferTypeOpInterface Operands: Operand Description decl any type Results: Result Description result lvalue to any type hl.deref (::vast::hl::Deref) VAST deref operation Syntax: operation ::= `hl.deref` $addr attr-dict `:` type($addr) `->` type($result) VAST deref operation Operands: Operand Description addr any type Results: Result Description result lvalue to any type hl.assign.fdiv (::vast::hl::DivFAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.fdiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.fdiv (::vast::hl::DivFOp) VAST arithmetic binary operation Syntax: operation ::= `hl.fdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.assign.sdiv (::vast::hl::DivSAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.sdiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.sdiv (::vast::hl::DivSOp) VAST arithmetic binary operation Syntax: operation ::= `hl.sdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.assign.udiv (::vast::hl::DivUAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.udiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.udiv (::vast::hl::DivUOp) VAST arithmetic binary operation Syntax: operation ::= `hl.udiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.enum.const (::vast::hl::EnumConstantOp) VAST enum constant declaration Syntax: operation ::= `hl.enum.const` $name `=` $value attr-dict (`init` $init^)? Enumeration constant servers to link name to an enum value. It is required to be scoped in Enum operation. For example: hl.enum.const \"F\" = 2 : !hl.int A constant can have a constant expression initializer: hl.enum.const \"G\" = #hl.integer<12> : !hl.int init { %0 = hl.enumref \"F\" : !hl.int %1 = hl.enumref \"C\" : !hl.int %2 = hl.add %0, %1 : !hl.int hl.value.yield %2 : !hl.int } Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute value ::mlir::TypedAttr TypedAttr instance hl.enum (::vast::hl::EnumDeclOp) VAST enum declaration Syntax: operation ::= `hl.enum` $name attr-dict `:` $type $constants Enum declaration serves to declare region for enum constant declarations. It also defines an underlying type. Traits: NoTerminator Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute hl.enumref (::vast::hl::EnumRefOp) VAST variable reference declaration Syntax: operation ::= `hl.enumref` $value attr-dict `:` type($result) VAST variable reference declaration Attributes: Attribute MLIR Type Description value ::mlir::StringAttr string attribute Results: Result Description result any type hl.expr (::vast::hl::ExprOp) VAST expression Syntax: operation ::= `hl.expr` attr-dict `:` type($result) $subexpr VAST expression Traits: SingleBlock Results: Result Description result any type hl.gnu.extension (::vast::hl::ExtensionOp) VAST extension ( extension ) keyword Syntax: operation ::= `hl.gnu.extension` $value attr-dict `:` type($value) `->` type($result) VAST op corresponding to GNU extension keyword. Operands: Operand Description value any type Results: Result Description result any type hl.fcmp (::vast::hl::FCmpOp) VAST flaoting point comparison operation Syntax: operation ::= `hl.fcmp` $predicate $lhs `,` $rhs attr-dict `:` type(operands) `->` type($result) VAST flaoting point comparison operation Attributes: Attribute MLIR Type Description predicate ::vast::hl::FPredicateAttr floating point comparison predicate Operands: Operand Description lhs float like type rhs float like type Results: Result Description result bool or integer like type hl.field (::vast::hl::FieldDeclOp) VAST record field declaration Syntax: operation ::= `hl.field` $name attr-dict (`bw` $bits^)? `:` $type VAST record field declaration Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute bits ::mlir::IntegerAttr 32-bit signless integer attribute hl.func (::vast::hl::FuncOp) VAST high-level function definintion or declaration Syntax: operation ::= `hl.func` $linkage $sym_name custom< FunctionSignatureAndBody >($function_type, attr-dict, $body) Inspired by cir::FuncOp and mlir::func::FuncOp : Operations within the function cannot implicitly capture values defined outside of the function, i.e. Functions are IsolatedFromAbove . All external references must use function arguments or attributes that establish a symbolic connection (e.g. symbols referenced by name via a string attribute like SymbolRefAttr). An external function declaration (used when referring to a function declared in some other module) has no body. The function linkage information is specified by linkage , as defined by GlobalLinkageKind attribute. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, Symbol Attributes: Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::hl::GlobalLinkageKindAttr Linkage type/kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes hl.funcref (::vast::hl::FuncRefOp) VAST function reference declaration Syntax: operation ::= `hl.funcref` $function attr-dict `:` type($result) VAST function reference declaration Attributes: Attribute MLIR Type Description function ::mlir::FlatSymbolRefAttr flat symbol reference attribute Results: Result Description result any type hl.globref (::vast::hl::GlobalRefOp) VAST global variable reference declaration Syntax: operation ::= `hl.globref` $global attr-dict `:` type($result) VAST global variable reference declaration Attributes: Attribute MLIR Type Description global ::mlir::StringAttr string attribute Results: Result Description result any type hl.break (::vast::hl::BreakOp) VAST break statement Syntax: operation ::= `hl.break` attr-dict VAST break statement Traits: NoRegionArguments, NoTerminator, soft_terminator hl.case (::vast::hl::CaseOp) VAST case statement Syntax: operation ::= `hl.case` $lhs $body attr-dict The operation represents a single case of a switch statement. The generic form of the operation is as follows: hl.case { ... / lhs/check region / hl.value.yield %val : !hl.type } { ... / body region / } It represents a C statement of form case lhs: body; . Traits: NoRegionArguments, NoTerminator hl.cond (::vast::hl::CondOp) VAST conditional statement Syntax: operation ::= `hl.cond` $condRegion `?` $thenRegion `:` $elseRegion attr-dict `:` type(results) The operation takes builders of three regions -- condition, true branch and false branch. Builders, given the location, build a particular region. The generic form of the operation is as follows: hl.cond { ... / condition region / hl.cond.yield %cond : !hl.bool } ? { ... / true region / } : { ... / false region / } Traits: NoRegionArguments, NoTerminator Results: Result Description result any type hl.cond.yield (::vast::hl::CondYieldOp) condition yield operation Syntax: operation ::= `hl.cond.yield` attr-dict $result `:` type($result) A condition yield operation is used to terminate the region representing condition expression of control flow operations IfOp , WhileOp , ForOp and DoOp . It yields a boolean value for the conditional branch. The custom assembly form of the operation is as follows: hl.cond.yield result : BoolType Traits: HasParent , Terminator Operands: Operand Description result any type hl.continue (::vast::hl::ContinueOp) VAST continue statement Syntax: operation ::= `hl.continue` attr-dict VAST continue statement Traits: NoRegionArguments, NoTerminator, soft_terminator hl.default (::vast::hl::DefaultOp) VAST default statement Syntax: operation ::= `hl.default` $body attr-dict VAST default statement Traits: NoRegionArguments, NoTerminator hl.do (::vast::hl::DoOp) VAST do-while statement Syntax: operation ::= `hl.do` $bodyRegion `while` $condRegion attr-dict The operation represents a do-while statement. The generic form of the operation is as follows: hl.do { ... / body region / } cond { ... / cond region / hl.cond.yield %cond : !hl.bool } Traits: NoRegionArguments, NoTerminator hl.for (::vast::hl::ForOp) VAST for statement Syntax: operation ::= `hl.for` $condRegion `incr` $incrRegion attr-dict `do` $bodyRegion Operation represents a for-loop statement. The generic form of the operation is as follows: hl.for { ... / cond region / hl.cond.yield %cond : !hl.bool } incr { ... / increment/update region / } do { ... / body region / } Traits: NoRegionArguments, NoTerminator hl.goto (::vast::hl::GotoStmt) Syntax: operation ::= `hl.goto` $label attr-dict Operands: Operand Description label hl.if (::vast::hl::IfOp) VAST if statement The operation takes builders of two mandatory regions -- condition and then region -- and one builder optional region representing else block of C if statement. Builders, given the location, build a particular region. The generic form of the operation is as follows: hl.if { ... / condition region / hl.cond.yield %cond : !hl.bool } then { ... / then region / } else { ... / else region / } Traits: NoRegionArguments, NoTerminator hl.label.decl (::vast::hl::LabelDeclOp) Syntax: operation ::= `hl.label.decl` $name attr-dict `:` type($result) Interfaces: InferTypeOpInterface Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute Results: Result Description result hl.label (::vast::hl::LabelStmt) VAST control flow operation Syntax: operation ::= `hl.label` $label $body attr-dict VAST control flow operation Traits: NoRegionArguments, NoTerminator Operands: Operand Description label hl.skip (::vast::hl::SkipStmt) VAST skip statement Syntax: operation ::= `hl.skip` attr-dict VAST skip statement hl.switch (::vast::hl::SwitchOp) VAST switch statement Syntax: operation ::= `hl.switch` $condRegion `cases` $cases attr-dict The operation represents a switch statement. The generic form of the operation is as follows: hl.switch { ... / cond region / hl.value.yield %val : !hl.type } cases { ... / casesregion / } Traits: NoRegionArguments, NoTerminator hl.value.yield (::vast::hl::ValueYieldOp) value yield operation Syntax: operation ::= `hl.value.yield` attr-dict $result `:` type($result) A value yield operation is used to terminate the case region of a switch statement. The yielded value triggers the parent case statement region. The custom assembly form of the operation is as follows: hl.value.yield result : type Traits: Terminator Operands: Operand Description result any type hl.var (::vast::hl::VarDeclOp) VAST variable declaration Syntax: operation ::= `hl.var` $name attr-dict ($storageClass^)? ($threadStorageClass^)? `:` type($result) (`=` $initializer^)? (`allocation_size` $allocation_size^)? VAST variable declaration Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute storageClass ::vast::hl::StorageClassAttr storage class threadStorageClass ::vast::hl::TSClassAttr thread storage class Results: Result Description result any type hl.while (::vast::hl::WhileOp) VAST while statement Syntax: operation ::= `hl.while` $condRegion `do` $bodyRegion attr-dict The operation takes builders of two mandatory regions -- condition and body region. Builders, given the location, build a particular region. The generic form of the operation is as follows: hl.while { ... / condition region / hl.cond.yield %cond : !hl.bool } do { ... / body region / } Traits: NoRegionArguments, NoTerminator hl.implicit_cast (::vast::hl::ImplicitCastOp) VAST cast operation Syntax: operation ::= `hl.implicit_cast` $value $kind attr-dict `:` type($value) `->` type($result) VAST cast operation Attributes: Attribute MLIR Type Description kind ::vast::hl::CastKindAttr cast kind Operands: Operand Description value any type Results: Result Description result any type hl.indirect_call (::vast::hl::IndirectCallOp) VAST call operation Syntax: operation ::= `hl.indirect_call` $callee `:` type($callee) `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results ) VAST call operation Interfaces: CallOpInterface Operands: Operand Description callee any type argOperands any type Results: Result Description results any type hl.initlist (::vast::hl::InitListExpr) VAST initializer list expression Syntax: operation ::= `hl.initlist` $elements attr-dict `:` functional-type($elements, results) VAST initializer list expression Operands: Operand Description elements any type Results: Result Description \u00abunnamed\u00bb any type hl.lnot (::vast::hl::LNotOp) VAST unary logical operation Syntax: operation ::= `hl.lnot` $arg attr-dict `:` type($arg) `->` type($res) High-level unary logical operation assures that result has the right type. The custom assembly form of the operation is as follows: %result = %arg : type -> ret_type Operands: Operand Description arg any type Results: Result Description res bool or integer like type hl.minus (::vast::hl::MinusOp) VAST unary type preserving operation Syntax: operation ::= `hl.minus` $arg attr-dict `:` type($result) Type preserving high-level unary operation assures that argument and result has the same type. The custom assembly form of the operation is as follows: %result = %arg : type Traits: SameOperandsAndResultType Interfaces: InferTypeOpInterface Operands: Operand Description arg any type Results: Result Description result any type hl.assign.fmul (::vast::hl::MulFAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.fmul` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.fmul (::vast::hl::MulFOp) VAST arithmetic binary operation Syntax: operation ::= `hl.fmul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.assign.mul (::vast::hl::MulIAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.mul` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.mul (::vast::hl::MulIOp) VAST arithmetic binary operation Syntax: operation ::= `hl.mul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Traits: Commutative Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.not (::vast::hl::NotOp) VAST unary type preserving operation Syntax: operation ::= `hl.not` $arg attr-dict `:` type($result) Type preserving high-level unary operation assures that argument and result has the same type. The custom assembly form of the operation is as follows: %result = %arg : type Traits: SameOperandsAndResultType Interfaces: InferTypeOpInterface Operands: Operand Description arg any type Results: Result Description result any type hl.plus (::vast::hl::PlusOp) VAST unary type preserving operation Syntax: operation ::= `hl.plus` $arg attr-dict `:` type($result) Type preserving high-level unary operation assures that argument and result has the same type. The custom assembly form of the operation is as follows: %result = %arg : type Traits: SameOperandsAndResultType Interfaces: InferTypeOpInterface Operands: Operand Description arg any type Results: Result Description result any type hl.post.dec (::vast::hl::PostDecOp) VAST unary inplace operation Syntax: operation ::= `hl.post.dec` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface Operands: Operand Description arg lvalue to any type Results: Result Description result any type hl.post.inc (::vast::hl::PostIncOp) VAST unary inplace operation Syntax: operation ::= `hl.post.inc` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface Operands: Operand Description arg lvalue to any type Results: Result Description result any type hl.pre.dec (::vast::hl::PreDecOp) VAST unary inplace operation Syntax: operation ::= `hl.pre.dec` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface Operands: Operand Description arg lvalue to any type Results: Result Description result any type hl.pre.inc (::vast::hl::PreIncOp) VAST unary inplace operation Syntax: operation ::= `hl.pre.inc` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface Operands: Operand Description arg lvalue to any type Results: Result Description result any type hl.predefined.expr (::vast::hl::PredefinedExpr) VAT predefined expr ( such as func ) Syntax: operation ::= `hl.predefined.expr` $value $kind attr-dict `:` type($value) `->` type($result) VAT predefined expr ( such as func ) Attributes: Attribute MLIR Type Description kind ::vast::hl::IdentKindAttr ident kind Operands: Operand Description value any type Results: Result Description result any type hl.member (::vast::hl::RecordMemberOp) VAST record element access operation Syntax: operation ::= `hl.member` $record `at` $name attr-dict `:` type($record) `->` type($element) VAST record element access operation Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute Operands: Operand Description record any type Results: Result Description element lvalue to any type hl.assign.frem (::vast::hl::RemFAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.frem` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.frem (::vast::hl::RemFOp) VAST arithmetic binary operation Syntax: operation ::= `hl.frem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.assign.srem (::vast::hl::RemSAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.srem` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.srem (::vast::hl::RemSOp) VAST arithmetic binary operation Syntax: operation ::= `hl.srem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.assign.urem (::vast::hl::RemUAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.urem` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.urem (::vast::hl::RemUOp) VAST arithmetic binary operation Syntax: operation ::= `hl.urem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.return (::vast::hl::ReturnOp) Syntax: operation ::= `hl.return` ($result^ `:` type($result))? attr-dict Traits: soft_terminator Operands: Operand Description result any type hl.scope (::vast::hl::ScopeOp) VAST scope declaration Syntax: operation ::= `hl.scope` $body attr-dict Scope operation servers to represent explicitly high-level code scope. Other control flow operations represent scopes implicitly. It is a single-region operation. Traits: NoTerminator hl.sizeof.expr (::vast::hl::SizeOfExprOp) VAST expr sizeof operator Syntax: operation ::= `hl.sizeof.expr` attr-dict `->` type($result) $expr VAST expr sizeof operator Results: Result Description result integer like type hl.sizeof.type (::vast::hl::SizeOfTypeOp) VAST type sizeof operator Syntax: operation ::= `hl.sizeof.type` $arg attr-dict `->` type($result) VAST type sizeof operator Attributes: Attribute MLIR Type Description arg ::mlir::TypeAttr any type attribute Results: Result Description result integer like type hl.stmt.expr (::vast::hl::StmtExprOp) VAST statement expression Syntax: operation ::= `hl.stmt.expr` attr-dict `:` type($result) $substmt VAST statement expression Traits: NoTerminator, SingleBlock Results: Result Description result any type hl.struct (::vast::hl::StructDeclOp) VAST struct declaration Syntax: operation ::= `hl.struct` $name attr-dict `:` $fields VAST struct declaration Traits: NoTerminator Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute hl.assign.fsub (::vast::hl::SubFAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.fsub` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.fsub (::vast::hl::SubFOp) VAST arithmetic binary operation Syntax: operation ::= `hl.fsub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.assign.sub (::vast::hl::SubIAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.sub` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.sub (::vast::hl::SubIOp) VAST arithmetic binary operation Syntax: operation ::= `hl.sub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.subscript (::vast::hl::SubscriptOp) VAST array subscript operator Syntax: operation ::= `hl.subscript` $array `at` ` ` `[` $index `:` type($index) `]` attr-dict `:` type($array) `->` type($result) VAST array subscript operator Operands: Operand Description array lvalue to subscriptable type index integer like type Results: Result Description result lvalue to any type hl.this (::vast::hl::ThisOp) VAST this operator Syntax: operation ::= `hl.this` attr-dict `:` type($result) VAST this operator Results: Result Description result any type hl.translation_unit (::vast::hl::TranslationUnitOp) VAST translation unit Syntax: operation ::= `hl.translation_unit` $body attr-dict VAST tranaslation unit Traits: IsolatedFromAbove, NoTerminator, SymbolTable hl.type (::vast::hl::TypeDeclOp) VAST type declaration Syntax: operation ::= `hl.type` $name attr-dict VAST type declaration Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute hl.typedef (::vast::hl::TypeDefOp) VAST typedef operation Syntax: operation ::= `hl.typedef` $name attr-dict `:` $type Typedef operation servers to declare named types. It creates a new type symbol in the current scope to be referenced as NamedType later. Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute hl.union (::vast::hl::UnionDeclOp) VAST record declaration Syntax: operation ::= `hl.union` $name attr-dict `:` $fields VAST record declaration Traits: NoTerminator Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute hl.unreachable (::vast::hl::UnreachableOp) VAST unreachable operation Syntax: operation ::= `hl.unreachable` attr-dict VAST unreachable operation Traits: Terminator Attribute definition AnnotationAttr Syntax: #hl.annotation< ::mlir::StringAttr # name > Parameters: Parameter C++ type Description name ::mlir::StringAttr BooleanAttr An Attribute containing a boolean value Syntax: #core.bool< ::mlir::Type, # type bool # value > An boolean attribute is a literal attribute that represents a boolean value. Parameters: Parameter C++ type Description type ::mlir::Type value bool CVQualifiersAttr Syntax: #hl.quals< bool, # is_const bool # is_volatile > Parameters: Parameter C++ type Description is_const bool const qualifier is_volatile bool volatile qualifier CVRQualifiersAttr Syntax: #hl.quals< bool, # is_const bool, # is_volatile bool # is_restrict > Parameters: Parameter C++ type Description is_const bool const qualifier is_volatile bool volatile qualifier is_restrict bool restrict qualifier FloatAttr An Attribute containing a floating point value Syntax: #core.float< ::mlir::Type, # type ::llvm::APFloat # value > A float attribute is a literal attribute that represents a floating point value of the specified floating point type. Parameters: Parameter C++ type Description type ::mlir::Type value ::llvm::APFloat IntegerAttr An Attribute containing a integer value Syntax: #core.integer< ::mlir::Type, # type ::llvm::APSInt # value > An integer attribute is a literal attribute that represents an integral value of the specified integer type. Parameters: Parameter C++ type Description type ::mlir::Type value ::llvm::APSInt StringAttr An Attribute containing a string Syntax: #core.str< ::llvm::StringRef, # value ::mlir::Type # type > Note: Temporarily copied from builtin dialect, because llvm-15 does not have TypedAttrInterface yet. Syntax: string-attribute ::= string-literal (`:` type)? A string attribute is an attribute that represents a string literal value. Examples: \"An important string\" \"string with a type\" : !dialect.string Parameters: Parameter C++ type Description value ::llvm::StringRef type ::mlir::Type StringLiteralAttr An Attribute containing an escaped string Syntax: string-attribute ::= string-literal (`:` type)? A string literal attribute is an attribute that represents an escaped string literal value. Examples: \"An important string\" \"string with a type\" : !dialect.string Parameters: Parameter C++ type Description value ::llvm::StringRef type ::mlir::Type UCVQualifiersAttr Syntax: #hl.quals< bool, # is_unsigned bool, # is_const bool # is_volatile > Parameters: Parameter C++ type Description is_unsigned bool unsigned qualifier is_const bool const qualifier is_volatile bool volatile qualifier Type definition AdjustedType Syntax: !hl.adjusted< Type, # original Type # adjusted > Parameters: Parameter C++ type Description original Type adjusted Type ArrayType Syntax: !hl.array< SizeParam, # size Type, # elementType CVRQualifiersAttr # quals > Parameters: Parameter C++ type Description size SizeParam size parameter for arrays elementType Type quals CVRQualifiersAttr AttributedType Syntax: !hl.attributed< Type # elementType > Parameters: Parameter C++ type Description elementType Type BFloat16Type Syntax: !hl.bfloat16< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr BoolType Syntax: !hl.bool< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr CharType Syntax: !hl.char< UCVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals UCVQualifiersAttr DecayedType Syntax: !hl.decayed< Type # elementType > Parameters: Parameter C++ type Description elementType Type DoubleType Syntax: !hl.double< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr ElaboratedType Syntax: !hl.elaborated< Type, # elementType CVRQualifiersAttr # quals > Parameters: Parameter C++ type Description elementType Type quals CVRQualifiersAttr EnumType Syntax: !hl.enum< ::llvm::StringRef, # name CVQualifiersAttr # quals > Parameters: Parameter C++ type Description name ::llvm::StringRef quals CVQualifiersAttr Float128Type Syntax: !hl.float128< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr FloatType Syntax: !hl.float< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr HalfType Syntax: !hl.half< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr Int128Type Syntax: !hl.int128< UCVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals UCVQualifiersAttr IntType Syntax: !hl.int< UCVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals UCVQualifiersAttr LValueType Syntax: !hl.lvalue< Type # elementType > Parameters: Parameter C++ type Description elementType Type LabelType Syntax: !hl.label LongDoubleType Syntax: !hl.longdouble< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr LongLongType Syntax: !hl.longlong< UCVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals UCVQualifiersAttr LongType Syntax: !hl.long< UCVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals UCVQualifiersAttr ParenType Syntax: !hl.paren< Type # elementType > Parameters: Parameter C++ type Description elementType Type PointerType Syntax: !hl.ptr< Type, # elementType CVRQualifiersAttr # quals > Parameters: Parameter C++ type Description elementType Type quals CVRQualifiersAttr RValueType Syntax: !hl.rvalue< Type # elementType > Parameters: Parameter C++ type Description elementType Type RecordType Syntax: !hl.record< ::llvm::StringRef, # name CVQualifiersAttr # quals > Parameters: Parameter C++ type Description name ::llvm::StringRef quals CVQualifiersAttr ReferenceType Syntax: !hl.reference< Type # elementType > Parameters: Parameter C++ type Description elementType Type ShortType Syntax: !hl.short< UCVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals UCVQualifiersAttr TypedefType Syntax: !hl.typedef< ::llvm::StringRef, # name CVRQualifiersAttr # quals > Parameters: Parameter C++ type Description name ::llvm::StringRef quals CVRQualifiersAttr VoidType Syntax: !hl.void< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr","title":"HighLevel"},{"location":"HighLevel/HighLevel/#hl-dialect","text":"A high-level verbose program analysis MLIR dialect. This dialect intends capture highevel constructs of C/C++ for further program analysis. 'hl' Dialect Operation definition hl.access (::vast::hl::AccessSpecifierOp) Attributes: hl.assign.fadd (::vast::hl::AddFAssignOp) Operands: Results: hl.fadd (::vast::hl::AddFOp) Operands: Results: hl.assign.add (::vast::hl::AddIAssignOp) Operands: Results: hl.add (::vast::hl::AddIOp) Operands: Results: hl.labeladdr (::vast::hl::AddrLabelExpr) Operands: Results: hl.addressof (::vast::hl::AddressOf) Operands: Results: hl.alignof.expr (::vast::hl::AlignOfExprOp) Results: hl.alignof.type (::vast::hl::AlignOfTypeOp) Attributes: Results: hl.assign (::vast::hl::AssignOp) Operands: Results: hl.assign.bin.and (::vast::hl::BinAndAssignOp) Operands: Results: hl.bin.and (::vast::hl::BinAndOp) Operands: Results: hl.bin.comma (::vast::hl::BinComma) Operands: Results: hl.bin.land (::vast::hl::BinLAndOp) Results: hl.bin.lor (::vast::hl::BinLOrOp) Results: hl.assign.bin.or (::vast::hl::BinOrAssignOp) Operands: Results: hl.bin.or (::vast::hl::BinOrOp) Operands: Results: hl.assign.bin.shl (::vast::hl::BinShlAssignOp) Operands: Results: hl.bin.shl (::vast::hl::BinShlOp) Operands: Results: hl.assign.bin.shr (::vast::hl::BinShrAssignOp) Operands: Results: hl.bin.shr (::vast::hl::BinShrOp) Operands: Results: hl.assign.bin.xor (::vast::hl::BinXorAssignOp) Operands: Results: hl.bin.xor (::vast::hl::BinXorOp) Operands: Results: hl.builtin_bitcast (::vast::hl::BuiltinBitCastOp) Attributes: Operands: Results: hl.cstyle_cast (::vast::hl::CStyleCastOp) Attributes: Operands: Results: hl.call (::vast::hl::CallOp) Attributes: Operands: Results: hl.class (::vast::hl::ClassDeclOp) Attributes: hl.cmp (::vast::hl::CmpOp) Attributes: Operands: Results: hl.const (::vast::hl::ConstantOp) Attributes: Results: hl.base (::vast::hl::CxxBaseSpecifierOp) Attributes: hl.cxxstruct (::vast::hl::CxxStructDeclOp) Attributes: hl.ref (::vast::hl::DeclRefOp) Operands: Results: hl.deref (::vast::hl::Deref) Operands: Results: hl.assign.fdiv (::vast::hl::DivFAssignOp) Operands: Results: hl.fdiv (::vast::hl::DivFOp) Operands: Results: hl.assign.sdiv (::vast::hl::DivSAssignOp) Operands: Results: hl.sdiv (::vast::hl::DivSOp) Operands: Results: hl.assign.udiv (::vast::hl::DivUAssignOp) Operands: Results: hl.udiv (::vast::hl::DivUOp) Operands: Results: hl.enum.const (::vast::hl::EnumConstantOp) Attributes: hl.enum (::vast::hl::EnumDeclOp) Attributes: hl.enumref (::vast::hl::EnumRefOp) Attributes: Results: hl.expr (::vast::hl::ExprOp) Results: hl.gnu.extension (::vast::hl::ExtensionOp) Operands: Results: hl.fcmp (::vast::hl::FCmpOp) Attributes: Operands: Results: hl.field (::vast::hl::FieldDeclOp) Attributes: hl.func (::vast::hl::FuncOp) Attributes: hl.funcref (::vast::hl::FuncRefOp) Attributes: Results: hl.globref (::vast::hl::GlobalRefOp) Attributes: Results: hl.break (::vast::hl::BreakOp) hl.case (::vast::hl::CaseOp) hl.cond (::vast::hl::CondOp) Results: hl.cond.yield (::vast::hl::CondYieldOp) Operands: hl.continue (::vast::hl::ContinueOp) hl.default (::vast::hl::DefaultOp) hl.do (::vast::hl::DoOp) hl.for (::vast::hl::ForOp) hl.goto (::vast::hl::GotoStmt) Operands: hl.if (::vast::hl::IfOp) hl.label.decl (::vast::hl::LabelDeclOp) Attributes: Results: hl.label (::vast::hl::LabelStmt) Operands: hl.skip (::vast::hl::SkipStmt) hl.switch (::vast::hl::SwitchOp) hl.value.yield (::vast::hl::ValueYieldOp) Operands: hl.var (::vast::hl::VarDeclOp) Attributes: Results: hl.while (::vast::hl::WhileOp) hl.implicit_cast (::vast::hl::ImplicitCastOp) Attributes: Operands: Results: hl.indirect_call (::vast::hl::IndirectCallOp) Operands: Results: hl.initlist (::vast::hl::InitListExpr) Operands: Results: hl.lnot (::vast::hl::LNotOp) Operands: Results: hl.minus (::vast::hl::MinusOp) Operands: Results: hl.assign.fmul (::vast::hl::MulFAssignOp) Operands: Results: hl.fmul (::vast::hl::MulFOp) Operands: Results: hl.assign.mul (::vast::hl::MulIAssignOp) Operands: Results: hl.mul (::vast::hl::MulIOp) Operands: Results: hl.not (::vast::hl::NotOp) Operands: Results: hl.plus (::vast::hl::PlusOp) Operands: Results: hl.post.dec (::vast::hl::PostDecOp) Operands: Results: hl.post.inc (::vast::hl::PostIncOp) Operands: Results: hl.pre.dec (::vast::hl::PreDecOp) Operands: Results: hl.pre.inc (::vast::hl::PreIncOp) Operands: Results: hl.predefined.expr (::vast::hl::PredefinedExpr) Attributes: Operands: Results: hl.member (::vast::hl::RecordMemberOp) Attributes: Operands: Results: hl.assign.frem (::vast::hl::RemFAssignOp) Operands: Results: hl.frem (::vast::hl::RemFOp) Operands: Results: hl.assign.srem (::vast::hl::RemSAssignOp) Operands: Results: hl.srem (::vast::hl::RemSOp) Operands: Results: hl.assign.urem (::vast::hl::RemUAssignOp) Operands: Results: hl.urem (::vast::hl::RemUOp) Operands: Results: hl.return (::vast::hl::ReturnOp) Operands: hl.scope (::vast::hl::ScopeOp) hl.sizeof.expr (::vast::hl::SizeOfExprOp) Results: hl.sizeof.type (::vast::hl::SizeOfTypeOp) Attributes: Results: hl.stmt.expr (::vast::hl::StmtExprOp) Results: hl.struct (::vast::hl::StructDeclOp) Attributes: hl.assign.fsub (::vast::hl::SubFAssignOp) Operands: Results: hl.fsub (::vast::hl::SubFOp) Operands: Results: hl.assign.sub (::vast::hl::SubIAssignOp) Operands: Results: hl.sub (::vast::hl::SubIOp) Operands: Results: hl.subscript (::vast::hl::SubscriptOp) Operands: Results: hl.this (::vast::hl::ThisOp) Results: hl.translation_unit (::vast::hl::TranslationUnitOp) hl.type (::vast::hl::TypeDeclOp) Attributes: hl.typedef (::vast::hl::TypeDefOp) Attributes: hl.union (::vast::hl::UnionDeclOp) Attributes: hl.unreachable (::vast::hl::UnreachableOp) Attribute definition AnnotationAttr Parameters: BooleanAttr Parameters: CVQualifiersAttr Parameters: CVRQualifiersAttr Parameters: FloatAttr Parameters: IntegerAttr Parameters: StringAttr Parameters: StringLiteralAttr Parameters: UCVQualifiersAttr Parameters: Type definition AdjustedType Parameters: ArrayType Parameters: AttributedType Parameters: BFloat16Type Parameters: BoolType Parameters: CharType Parameters: DecayedType Parameters: DoubleType Parameters: ElaboratedType Parameters: EnumType Parameters: Float128Type Parameters: FloatType Parameters: HalfType Parameters: Int128Type Parameters: IntType Parameters: LValueType Parameters: LabelType LongDoubleType Parameters: LongLongType Parameters: LongType Parameters: ParenType Parameters: PointerType Parameters: RValueType Parameters: RecordType Parameters: ReferenceType Parameters: ShortType Parameters: TypedefType Parameters: VoidType Parameters:","title":"'hl' Dialect"},{"location":"HighLevel/HighLevel/#operation-definition","text":"","title":"Operation definition"},{"location":"HighLevel/HighLevel/#hlaccess-vasthlaccessspecifierop","text":"VAST C++ access specifier declaration Syntax: operation ::= `hl.access` attr-dict $spec VAST C++ access specifier declaration","title":"hl.access (::vast::hl::AccessSpecifierOp)"},{"location":"HighLevel/HighLevel/#attributes","text":"Attribute MLIR Type Description spec ::vast::hl::AccessSpecifierAttr Access specifier","title":"Attributes:"},{"location":"HighLevel/HighLevel/#hlassignfadd-vasthladdfassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.fadd` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.fadd (::vast::hl::AddFAssignOp)"},{"location":"HighLevel/HighLevel/#operands","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlfadd-vasthladdfop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.fadd` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.fadd (::vast::hl::AddFOp)"},{"location":"HighLevel/HighLevel/#operands_1","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_1","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignadd-vasthladdiassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.add` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.add (::vast::hl::AddIAssignOp)"},{"location":"HighLevel/HighLevel/#operands_2","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_2","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hladd-vasthladdiop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.add` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Traits: Commutative","title":"hl.add (::vast::hl::AddIOp)"},{"location":"HighLevel/HighLevel/#operands_3","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_3","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hllabeladdr-vasthladdrlabelexpr","text":"VAST address of label extension Syntax: operation ::= `hl.labeladdr` $label attr-dict `:` type($result) VAST address of label extension","title":"hl.labeladdr (::vast::hl::AddrLabelExpr)"},{"location":"HighLevel/HighLevel/#operands_4","text":"Operand Description label","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_4","text":"Result Description result lvalue to pointer like type","title":"Results:"},{"location":"HighLevel/HighLevel/#hladdressof-vasthladdressof","text":"VAST addressof operation Syntax: operation ::= `hl.addressof` $value attr-dict `:` type($value) `->` type($result) VAST addressof operation","title":"hl.addressof (::vast::hl::AddressOf)"},{"location":"HighLevel/HighLevel/#operands_5","text":"Operand Description value lvalue to any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_5","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlalignofexpr-vasthlalignofexprop","text":"VAST expr alignof operator Syntax: operation ::= `hl.alignof.expr` attr-dict `->` type($result) $expr VAST expr alignof operator","title":"hl.alignof.expr (::vast::hl::AlignOfExprOp)"},{"location":"HighLevel/HighLevel/#results_6","text":"Result Description result integer like type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlalignoftype-vasthlalignoftypeop","text":"VAST type alignof operator Syntax: operation ::= `hl.alignof.type` $arg attr-dict `->` type($result) VAST type alignof operator","title":"hl.alignof.type (::vast::hl::AlignOfTypeOp)"},{"location":"HighLevel/HighLevel/#attributes_1","text":"Attribute MLIR Type Description arg ::mlir::TypeAttr any type attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#results_7","text":"Result Description result integer like type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassign-vasthlassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign (::vast::hl::AssignOp)"},{"location":"HighLevel/HighLevel/#operands_6","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_8","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignbinand-vasthlbinandassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.bin.and` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.bin.and (::vast::hl::BinAndAssignOp)"},{"location":"HighLevel/HighLevel/#operands_7","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_9","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlbinand-vasthlbinandop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.bin.and` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.bin.and (::vast::hl::BinAndOp)"},{"location":"HighLevel/HighLevel/#operands_8","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_10","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlbincomma-vasthlbincomma","text":"VAST binary operation Syntax: operation ::= `hl.bin.comma` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) Traits: AttrSizedOperandSegments","title":"hl.bin.comma (::vast::hl::BinComma)"},{"location":"HighLevel/HighLevel/#operands_9","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_11","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlbinland-vasthlbinlandop","text":"VAST logical binary operation Syntax: operation ::= `hl.bin.land` $lhs`,` $rhs attr-dict `:` type(results) High-level logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type","title":"hl.bin.land (::vast::hl::BinLAndOp)"},{"location":"HighLevel/HighLevel/#results_12","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlbinlor-vasthlbinlorop","text":"VAST logical binary operation Syntax: operation ::= `hl.bin.lor` $lhs`,` $rhs attr-dict `:` type(results) High-level logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type","title":"hl.bin.lor (::vast::hl::BinLOrOp)"},{"location":"HighLevel/HighLevel/#results_13","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignbinor-vasthlbinorassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.bin.or` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.bin.or (::vast::hl::BinOrAssignOp)"},{"location":"HighLevel/HighLevel/#operands_10","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_14","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlbinor-vasthlbinorop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.bin.or` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.bin.or (::vast::hl::BinOrOp)"},{"location":"HighLevel/HighLevel/#operands_11","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_15","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignbinshl-vasthlbinshlassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.bin.shl` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.bin.shl (::vast::hl::BinShlAssignOp)"},{"location":"HighLevel/HighLevel/#operands_12","text":"Operand Description src lvalue to integer like type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_16","text":"Result Description result integer like type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlbinshl-vasthlbinshlop","text":"VAST binary shift operation Syntax: operation ::= `hl.bin.shl` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level binary shift operation. This operation takes two operands and returns one result. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.bin.shl (::vast::hl::BinShlOp)"},{"location":"HighLevel/HighLevel/#operands_13","text":"Operand Description lhs integer like type rhs integer like type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_17","text":"Result Description result integer like type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignbinshr-vasthlbinshrassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.bin.shr` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.bin.shr (::vast::hl::BinShrAssignOp)"},{"location":"HighLevel/HighLevel/#operands_14","text":"Operand Description src lvalue to integer like type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_18","text":"Result Description result integer like type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlbinshr-vasthlbinshrop","text":"VAST binary shift operation Syntax: operation ::= `hl.bin.shr` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level binary shift operation. This operation takes two operands and returns one result. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.bin.shr (::vast::hl::BinShrOp)"},{"location":"HighLevel/HighLevel/#operands_15","text":"Operand Description lhs integer like type rhs integer like type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_19","text":"Result Description result integer like type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignbinxor-vasthlbinxorassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.bin.xor` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.bin.xor (::vast::hl::BinXorAssignOp)"},{"location":"HighLevel/HighLevel/#operands_16","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_20","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlbinxor-vasthlbinxorop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.bin.xor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.bin.xor (::vast::hl::BinXorOp)"},{"location":"HighLevel/HighLevel/#operands_17","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_21","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlbuiltin_bitcast-vasthlbuiltinbitcastop","text":"VAST cast operation Syntax: operation ::= `hl.builtin_bitcast` $value $kind attr-dict `:` type($value) `->` type($result) VAST cast operation","title":"hl.builtin_bitcast (::vast::hl::BuiltinBitCastOp)"},{"location":"HighLevel/HighLevel/#attributes_2","text":"Attribute MLIR Type Description kind ::vast::hl::CastKindAttr cast kind","title":"Attributes:"},{"location":"HighLevel/HighLevel/#operands_18","text":"Operand Description value any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_22","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlcstyle_cast-vasthlcstylecastop","text":"VAST cast operation Syntax: operation ::= `hl.cstyle_cast` $value $kind attr-dict `:` type($value) `->` type($result) VAST cast operation","title":"hl.cstyle_cast (::vast::hl::CStyleCastOp)"},{"location":"HighLevel/HighLevel/#attributes_3","text":"Attribute MLIR Type Description kind ::vast::hl::CastKindAttr cast kind","title":"Attributes:"},{"location":"HighLevel/HighLevel/#operands_19","text":"Operand Description value any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_23","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlcall-vasthlcallop","text":"VAST call operation Syntax: operation ::= `hl.call` $callee `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results ) VAST call operation Interfaces: CallOpInterface","title":"hl.call (::vast::hl::CallOp)"},{"location":"HighLevel/HighLevel/#attributes_4","text":"Attribute MLIR Type Description callee ::mlir::FlatSymbolRefAttr flat symbol reference attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#operands_20","text":"Operand Description argOperands any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_24","text":"Result Description results any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlclass-vasthlclassdeclop","text":"VAST C++ class declaration Syntax: operation ::= `hl.class` $name attr-dict `:` `bases` $bases $fields VAST C++ class declaration Traits: NoTerminator Interfaces: VastSymbol","title":"hl.class (::vast::hl::ClassDeclOp)"},{"location":"HighLevel/HighLevel/#attributes_5","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#hlcmp-vasthlcmpop","text":"VAST comparison operation Syntax: operation ::= `hl.cmp` $predicate $lhs `,` $rhs attr-dict `:` type(operands) `->` type($result) VAST comparison operation","title":"hl.cmp (::vast::hl::CmpOp)"},{"location":"HighLevel/HighLevel/#attributes_6","text":"Attribute MLIR Type Description predicate ::vast::hl::PredicateAttr comparison predicate","title":"Attributes:"},{"location":"HighLevel/HighLevel/#operands_21","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_25","text":"Result Description result bool or integer like type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlconst-vasthlconstantop","text":"VAST integral constant Syntax: operation ::= `hl.const` $value attr-dict VAST integral constant Traits: ConstantLike Interfaces: InferTypeOpInterface","title":"hl.const (::vast::hl::ConstantOp)"},{"location":"HighLevel/HighLevel/#attributes_7","text":"Attribute MLIR Type Description value ::mlir::TypedAttr TypedAttr instance","title":"Attributes:"},{"location":"HighLevel/HighLevel/#results_26","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlbase-vasthlcxxbasespecifierop","text":"VAST base class specifier Syntax: operation ::= `hl.base` $type attr-dict $access (`virtual` $is_virtual^)? VAST base class specifier Interfaces: VastSymbol","title":"hl.base (::vast::hl::CxxBaseSpecifierOp)"},{"location":"HighLevel/HighLevel/#attributes_8","text":"Attribute MLIR Type Description type ::mlir::TypeAttr any type attribute access ::vast::hl::AccessSpecifierAttr Access specifier is_virtual ::mlir::UnitAttr unit attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#hlcxxstruct-vasthlcxxstructdeclop","text":"VAST C++ struct declaration Syntax: operation ::= `hl.cxxstruct` $name attr-dict `:` `bases` $bases $fields VAST C++ struct declaration Traits: NoTerminator Interfaces: VastSymbol","title":"hl.cxxstruct (::vast::hl::CxxStructDeclOp)"},{"location":"HighLevel/HighLevel/#attributes_9","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#hlref-vasthldeclrefop","text":"VAST variable reference declaration Syntax: operation ::= `hl.ref` $decl attr-dict `:`type(operands) VAST variable reference declaration Interfaces: InferTypeOpInterface","title":"hl.ref (::vast::hl::DeclRefOp)"},{"location":"HighLevel/HighLevel/#operands_22","text":"Operand Description decl any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_27","text":"Result Description result lvalue to any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlderef-vasthlderef","text":"VAST deref operation Syntax: operation ::= `hl.deref` $addr attr-dict `:` type($addr) `->` type($result) VAST deref operation","title":"hl.deref (::vast::hl::Deref)"},{"location":"HighLevel/HighLevel/#operands_23","text":"Operand Description addr any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_28","text":"Result Description result lvalue to any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignfdiv-vasthldivfassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.fdiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.fdiv (::vast::hl::DivFAssignOp)"},{"location":"HighLevel/HighLevel/#operands_24","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_29","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlfdiv-vasthldivfop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.fdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.fdiv (::vast::hl::DivFOp)"},{"location":"HighLevel/HighLevel/#operands_25","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_30","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignsdiv-vasthldivsassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.sdiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.sdiv (::vast::hl::DivSAssignOp)"},{"location":"HighLevel/HighLevel/#operands_26","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_31","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlsdiv-vasthldivsop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.sdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.sdiv (::vast::hl::DivSOp)"},{"location":"HighLevel/HighLevel/#operands_27","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_32","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignudiv-vasthldivuassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.udiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.udiv (::vast::hl::DivUAssignOp)"},{"location":"HighLevel/HighLevel/#operands_28","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_33","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hludiv-vasthldivuop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.udiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.udiv (::vast::hl::DivUOp)"},{"location":"HighLevel/HighLevel/#operands_29","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_34","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlenumconst-vasthlenumconstantop","text":"VAST enum constant declaration Syntax: operation ::= `hl.enum.const` $name `=` $value attr-dict (`init` $init^)? Enumeration constant servers to link name to an enum value. It is required to be scoped in Enum operation. For example: hl.enum.const \"F\" = 2 : !hl.int A constant can have a constant expression initializer: hl.enum.const \"G\" = #hl.integer<12> : !hl.int init { %0 = hl.enumref \"F\" : !hl.int %1 = hl.enumref \"C\" : !hl.int %2 = hl.add %0, %1 : !hl.int hl.value.yield %2 : !hl.int }","title":"hl.enum.const (::vast::hl::EnumConstantOp)"},{"location":"HighLevel/HighLevel/#attributes_10","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute value ::mlir::TypedAttr TypedAttr instance","title":"Attributes:"},{"location":"HighLevel/HighLevel/#hlenum-vasthlenumdeclop","text":"VAST enum declaration Syntax: operation ::= `hl.enum` $name attr-dict `:` $type $constants Enum declaration serves to declare region for enum constant declarations. It also defines an underlying type. Traits: NoTerminator Interfaces: VastSymbol","title":"hl.enum (::vast::hl::EnumDeclOp)"},{"location":"HighLevel/HighLevel/#attributes_11","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#hlenumref-vasthlenumrefop","text":"VAST variable reference declaration Syntax: operation ::= `hl.enumref` $value attr-dict `:` type($result) VAST variable reference declaration","title":"hl.enumref (::vast::hl::EnumRefOp)"},{"location":"HighLevel/HighLevel/#attributes_12","text":"Attribute MLIR Type Description value ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#results_35","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlexpr-vasthlexprop","text":"VAST expression Syntax: operation ::= `hl.expr` attr-dict `:` type($result) $subexpr VAST expression Traits: SingleBlock","title":"hl.expr (::vast::hl::ExprOp)"},{"location":"HighLevel/HighLevel/#results_36","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlgnuextension-vasthlextensionop","text":"VAST extension ( extension ) keyword Syntax: operation ::= `hl.gnu.extension` $value attr-dict `:` type($value) `->` type($result) VAST op corresponding to GNU extension keyword.","title":"hl.gnu.extension (::vast::hl::ExtensionOp)"},{"location":"HighLevel/HighLevel/#operands_30","text":"Operand Description value any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_37","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlfcmp-vasthlfcmpop","text":"VAST flaoting point comparison operation Syntax: operation ::= `hl.fcmp` $predicate $lhs `,` $rhs attr-dict `:` type(operands) `->` type($result) VAST flaoting point comparison operation","title":"hl.fcmp (::vast::hl::FCmpOp)"},{"location":"HighLevel/HighLevel/#attributes_13","text":"Attribute MLIR Type Description predicate ::vast::hl::FPredicateAttr floating point comparison predicate","title":"Attributes:"},{"location":"HighLevel/HighLevel/#operands_31","text":"Operand Description lhs float like type rhs float like type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_38","text":"Result Description result bool or integer like type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlfield-vasthlfielddeclop","text":"VAST record field declaration Syntax: operation ::= `hl.field` $name attr-dict (`bw` $bits^)? `:` $type VAST record field declaration Interfaces: VastSymbol","title":"hl.field (::vast::hl::FieldDeclOp)"},{"location":"HighLevel/HighLevel/#attributes_14","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute bits ::mlir::IntegerAttr 32-bit signless integer attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#hlfunc-vasthlfuncop","text":"VAST high-level function definintion or declaration Syntax: operation ::= `hl.func` $linkage $sym_name custom< FunctionSignatureAndBody >($function_type, attr-dict, $body) Inspired by cir::FuncOp and mlir::func::FuncOp : Operations within the function cannot implicitly capture values defined outside of the function, i.e. Functions are IsolatedFromAbove . All external references must use function arguments or attributes that establish a symbolic connection (e.g. symbols referenced by name via a string attribute like SymbolRefAttr). An external function declaration (used when referring to a function declared in some other module) has no body. The function linkage information is specified by linkage , as defined by GlobalLinkageKind attribute. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, Symbol","title":"hl.func (::vast::hl::FuncOp)"},{"location":"HighLevel/HighLevel/#attributes_15","text":"Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::hl::GlobalLinkageKindAttr Linkage type/kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes","title":"Attributes:"},{"location":"HighLevel/HighLevel/#hlfuncref-vasthlfuncrefop","text":"VAST function reference declaration Syntax: operation ::= `hl.funcref` $function attr-dict `:` type($result) VAST function reference declaration","title":"hl.funcref (::vast::hl::FuncRefOp)"},{"location":"HighLevel/HighLevel/#attributes_16","text":"Attribute MLIR Type Description function ::mlir::FlatSymbolRefAttr flat symbol reference attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#results_39","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlglobref-vasthlglobalrefop","text":"VAST global variable reference declaration Syntax: operation ::= `hl.globref` $global attr-dict `:` type($result) VAST global variable reference declaration","title":"hl.globref (::vast::hl::GlobalRefOp)"},{"location":"HighLevel/HighLevel/#attributes_17","text":"Attribute MLIR Type Description global ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#results_40","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlbreak-vasthlbreakop","text":"VAST break statement Syntax: operation ::= `hl.break` attr-dict VAST break statement Traits: NoRegionArguments, NoTerminator, soft_terminator","title":"hl.break (::vast::hl::BreakOp)"},{"location":"HighLevel/HighLevel/#hlcase-vasthlcaseop","text":"VAST case statement Syntax: operation ::= `hl.case` $lhs $body attr-dict The operation represents a single case of a switch statement. The generic form of the operation is as follows: hl.case { ... / lhs/check region / hl.value.yield %val : !hl.type } { ... / body region / } It represents a C statement of form case lhs: body; . Traits: NoRegionArguments, NoTerminator","title":"hl.case (::vast::hl::CaseOp)"},{"location":"HighLevel/HighLevel/#hlcond-vasthlcondop","text":"VAST conditional statement Syntax: operation ::= `hl.cond` $condRegion `?` $thenRegion `:` $elseRegion attr-dict `:` type(results) The operation takes builders of three regions -- condition, true branch and false branch. Builders, given the location, build a particular region. The generic form of the operation is as follows: hl.cond { ... / condition region / hl.cond.yield %cond : !hl.bool } ? { ... / true region / } : { ... / false region / } Traits: NoRegionArguments, NoTerminator","title":"hl.cond (::vast::hl::CondOp)"},{"location":"HighLevel/HighLevel/#results_41","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlcondyield-vasthlcondyieldop","text":"condition yield operation Syntax: operation ::= `hl.cond.yield` attr-dict $result `:` type($result) A condition yield operation is used to terminate the region representing condition expression of control flow operations IfOp , WhileOp , ForOp and DoOp . It yields a boolean value for the conditional branch. The custom assembly form of the operation is as follows: hl.cond.yield result : BoolType Traits: HasParent , Terminator","title":"hl.cond.yield (::vast::hl::CondYieldOp)"},{"location":"HighLevel/HighLevel/#operands_32","text":"Operand Description result any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#hlcontinue-vasthlcontinueop","text":"VAST continue statement Syntax: operation ::= `hl.continue` attr-dict VAST continue statement Traits: NoRegionArguments, NoTerminator, soft_terminator","title":"hl.continue (::vast::hl::ContinueOp)"},{"location":"HighLevel/HighLevel/#hldefault-vasthldefaultop","text":"VAST default statement Syntax: operation ::= `hl.default` $body attr-dict VAST default statement Traits: NoRegionArguments, NoTerminator","title":"hl.default (::vast::hl::DefaultOp)"},{"location":"HighLevel/HighLevel/#hldo-vasthldoop","text":"VAST do-while statement Syntax: operation ::= `hl.do` $bodyRegion `while` $condRegion attr-dict The operation represents a do-while statement. The generic form of the operation is as follows: hl.do { ... / body region / } cond { ... / cond region / hl.cond.yield %cond : !hl.bool } Traits: NoRegionArguments, NoTerminator","title":"hl.do (::vast::hl::DoOp)"},{"location":"HighLevel/HighLevel/#hlfor-vasthlforop","text":"VAST for statement Syntax: operation ::= `hl.for` $condRegion `incr` $incrRegion attr-dict `do` $bodyRegion Operation represents a for-loop statement. The generic form of the operation is as follows: hl.for { ... / cond region / hl.cond.yield %cond : !hl.bool } incr { ... / increment/update region / } do { ... / body region / } Traits: NoRegionArguments, NoTerminator","title":"hl.for (::vast::hl::ForOp)"},{"location":"HighLevel/HighLevel/#hlgoto-vasthlgotostmt","text":"Syntax: operation ::= `hl.goto` $label attr-dict","title":"hl.goto (::vast::hl::GotoStmt)"},{"location":"HighLevel/HighLevel/#operands_33","text":"Operand Description label","title":"Operands:"},{"location":"HighLevel/HighLevel/#hlif-vasthlifop","text":"VAST if statement The operation takes builders of two mandatory regions -- condition and then region -- and one builder optional region representing else block of C if statement. Builders, given the location, build a particular region. The generic form of the operation is as follows: hl.if { ... / condition region / hl.cond.yield %cond : !hl.bool } then { ... / then region / } else { ... / else region / } Traits: NoRegionArguments, NoTerminator","title":"hl.if (::vast::hl::IfOp)"},{"location":"HighLevel/HighLevel/#hllabeldecl-vasthllabeldeclop","text":"Syntax: operation ::= `hl.label.decl` $name attr-dict `:` type($result) Interfaces: InferTypeOpInterface","title":"hl.label.decl (::vast::hl::LabelDeclOp)"},{"location":"HighLevel/HighLevel/#attributes_18","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#results_42","text":"Result Description result","title":"Results:"},{"location":"HighLevel/HighLevel/#hllabel-vasthllabelstmt","text":"VAST control flow operation Syntax: operation ::= `hl.label` $label $body attr-dict VAST control flow operation Traits: NoRegionArguments, NoTerminator","title":"hl.label (::vast::hl::LabelStmt)"},{"location":"HighLevel/HighLevel/#operands_34","text":"Operand Description label","title":"Operands:"},{"location":"HighLevel/HighLevel/#hlskip-vasthlskipstmt","text":"VAST skip statement Syntax: operation ::= `hl.skip` attr-dict VAST skip statement","title":"hl.skip (::vast::hl::SkipStmt)"},{"location":"HighLevel/HighLevel/#hlswitch-vasthlswitchop","text":"VAST switch statement Syntax: operation ::= `hl.switch` $condRegion `cases` $cases attr-dict The operation represents a switch statement. The generic form of the operation is as follows: hl.switch { ... / cond region / hl.value.yield %val : !hl.type } cases { ... / casesregion / } Traits: NoRegionArguments, NoTerminator","title":"hl.switch (::vast::hl::SwitchOp)"},{"location":"HighLevel/HighLevel/#hlvalueyield-vasthlvalueyieldop","text":"value yield operation Syntax: operation ::= `hl.value.yield` attr-dict $result `:` type($result) A value yield operation is used to terminate the case region of a switch statement. The yielded value triggers the parent case statement region. The custom assembly form of the operation is as follows: hl.value.yield result : type Traits: Terminator","title":"hl.value.yield (::vast::hl::ValueYieldOp)"},{"location":"HighLevel/HighLevel/#operands_35","text":"Operand Description result any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#hlvar-vasthlvardeclop","text":"VAST variable declaration Syntax: operation ::= `hl.var` $name attr-dict ($storageClass^)? ($threadStorageClass^)? `:` type($result) (`=` $initializer^)? (`allocation_size` $allocation_size^)? VAST variable declaration Interfaces: VastSymbol","title":"hl.var (::vast::hl::VarDeclOp)"},{"location":"HighLevel/HighLevel/#attributes_19","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute storageClass ::vast::hl::StorageClassAttr storage class threadStorageClass ::vast::hl::TSClassAttr thread storage class","title":"Attributes:"},{"location":"HighLevel/HighLevel/#results_43","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlwhile-vasthlwhileop","text":"VAST while statement Syntax: operation ::= `hl.while` $condRegion `do` $bodyRegion attr-dict The operation takes builders of two mandatory regions -- condition and body region. Builders, given the location, build a particular region. The generic form of the operation is as follows: hl.while { ... / condition region / hl.cond.yield %cond : !hl.bool } do { ... / body region / } Traits: NoRegionArguments, NoTerminator","title":"hl.while (::vast::hl::WhileOp)"},{"location":"HighLevel/HighLevel/#hlimplicit_cast-vasthlimplicitcastop","text":"VAST cast operation Syntax: operation ::= `hl.implicit_cast` $value $kind attr-dict `:` type($value) `->` type($result) VAST cast operation","title":"hl.implicit_cast (::vast::hl::ImplicitCastOp)"},{"location":"HighLevel/HighLevel/#attributes_20","text":"Attribute MLIR Type Description kind ::vast::hl::CastKindAttr cast kind","title":"Attributes:"},{"location":"HighLevel/HighLevel/#operands_36","text":"Operand Description value any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_44","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlindirect_call-vasthlindirectcallop","text":"VAST call operation Syntax: operation ::= `hl.indirect_call` $callee `:` type($callee) `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results ) VAST call operation Interfaces: CallOpInterface","title":"hl.indirect_call (::vast::hl::IndirectCallOp)"},{"location":"HighLevel/HighLevel/#operands_37","text":"Operand Description callee any type argOperands any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_45","text":"Result Description results any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlinitlist-vasthlinitlistexpr","text":"VAST initializer list expression Syntax: operation ::= `hl.initlist` $elements attr-dict `:` functional-type($elements, results) VAST initializer list expression","title":"hl.initlist (::vast::hl::InitListExpr)"},{"location":"HighLevel/HighLevel/#operands_38","text":"Operand Description elements any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_46","text":"Result Description \u00abunnamed\u00bb any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hllnot-vasthllnotop","text":"VAST unary logical operation Syntax: operation ::= `hl.lnot` $arg attr-dict `:` type($arg) `->` type($res) High-level unary logical operation assures that result has the right type. The custom assembly form of the operation is as follows: %result = %arg : type -> ret_type","title":"hl.lnot (::vast::hl::LNotOp)"},{"location":"HighLevel/HighLevel/#operands_39","text":"Operand Description arg any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_47","text":"Result Description res bool or integer like type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlminus-vasthlminusop","text":"VAST unary type preserving operation Syntax: operation ::= `hl.minus` $arg attr-dict `:` type($result) Type preserving high-level unary operation assures that argument and result has the same type. The custom assembly form of the operation is as follows: %result = %arg : type Traits: SameOperandsAndResultType Interfaces: InferTypeOpInterface","title":"hl.minus (::vast::hl::MinusOp)"},{"location":"HighLevel/HighLevel/#operands_40","text":"Operand Description arg any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_48","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignfmul-vasthlmulfassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.fmul` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.fmul (::vast::hl::MulFAssignOp)"},{"location":"HighLevel/HighLevel/#operands_41","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_49","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlfmul-vasthlmulfop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.fmul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.fmul (::vast::hl::MulFOp)"},{"location":"HighLevel/HighLevel/#operands_42","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_50","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignmul-vasthlmuliassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.mul` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.mul (::vast::hl::MulIAssignOp)"},{"location":"HighLevel/HighLevel/#operands_43","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_51","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlmul-vasthlmuliop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.mul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Traits: Commutative","title":"hl.mul (::vast::hl::MulIOp)"},{"location":"HighLevel/HighLevel/#operands_44","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_52","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlnot-vasthlnotop","text":"VAST unary type preserving operation Syntax: operation ::= `hl.not` $arg attr-dict `:` type($result) Type preserving high-level unary operation assures that argument and result has the same type. The custom assembly form of the operation is as follows: %result = %arg : type Traits: SameOperandsAndResultType Interfaces: InferTypeOpInterface","title":"hl.not (::vast::hl::NotOp)"},{"location":"HighLevel/HighLevel/#operands_45","text":"Operand Description arg any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_53","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlplus-vasthlplusop","text":"VAST unary type preserving operation Syntax: operation ::= `hl.plus` $arg attr-dict `:` type($result) Type preserving high-level unary operation assures that argument and result has the same type. The custom assembly form of the operation is as follows: %result = %arg : type Traits: SameOperandsAndResultType Interfaces: InferTypeOpInterface","title":"hl.plus (::vast::hl::PlusOp)"},{"location":"HighLevel/HighLevel/#operands_46","text":"Operand Description arg any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_54","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlpostdec-vasthlpostdecop","text":"VAST unary inplace operation Syntax: operation ::= `hl.post.dec` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface","title":"hl.post.dec (::vast::hl::PostDecOp)"},{"location":"HighLevel/HighLevel/#operands_47","text":"Operand Description arg lvalue to any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_55","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlpostinc-vasthlpostincop","text":"VAST unary inplace operation Syntax: operation ::= `hl.post.inc` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface","title":"hl.post.inc (::vast::hl::PostIncOp)"},{"location":"HighLevel/HighLevel/#operands_48","text":"Operand Description arg lvalue to any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_56","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlpredec-vasthlpredecop","text":"VAST unary inplace operation Syntax: operation ::= `hl.pre.dec` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface","title":"hl.pre.dec (::vast::hl::PreDecOp)"},{"location":"HighLevel/HighLevel/#operands_49","text":"Operand Description arg lvalue to any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_57","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlpreinc-vasthlpreincop","text":"VAST unary inplace operation Syntax: operation ::= `hl.pre.inc` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface","title":"hl.pre.inc (::vast::hl::PreIncOp)"},{"location":"HighLevel/HighLevel/#operands_50","text":"Operand Description arg lvalue to any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_58","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlpredefinedexpr-vasthlpredefinedexpr","text":"VAT predefined expr ( such as func ) Syntax: operation ::= `hl.predefined.expr` $value $kind attr-dict `:` type($value) `->` type($result) VAT predefined expr ( such as func )","title":"hl.predefined.expr (::vast::hl::PredefinedExpr)"},{"location":"HighLevel/HighLevel/#attributes_21","text":"Attribute MLIR Type Description kind ::vast::hl::IdentKindAttr ident kind","title":"Attributes:"},{"location":"HighLevel/HighLevel/#operands_51","text":"Operand Description value any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_59","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlmember-vasthlrecordmemberop","text":"VAST record element access operation Syntax: operation ::= `hl.member` $record `at` $name attr-dict `:` type($record) `->` type($element) VAST record element access operation","title":"hl.member (::vast::hl::RecordMemberOp)"},{"location":"HighLevel/HighLevel/#attributes_22","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#operands_52","text":"Operand Description record any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_60","text":"Result Description element lvalue to any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignfrem-vasthlremfassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.frem` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.frem (::vast::hl::RemFAssignOp)"},{"location":"HighLevel/HighLevel/#operands_53","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_61","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlfrem-vasthlremfop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.frem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.frem (::vast::hl::RemFOp)"},{"location":"HighLevel/HighLevel/#operands_54","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_62","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignsrem-vasthlremsassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.srem` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.srem (::vast::hl::RemSAssignOp)"},{"location":"HighLevel/HighLevel/#operands_55","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_63","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlsrem-vasthlremsop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.srem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.srem (::vast::hl::RemSOp)"},{"location":"HighLevel/HighLevel/#operands_56","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_64","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignurem-vasthlremuassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.urem` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.urem (::vast::hl::RemUAssignOp)"},{"location":"HighLevel/HighLevel/#operands_57","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_65","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlurem-vasthlremuop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.urem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.urem (::vast::hl::RemUOp)"},{"location":"HighLevel/HighLevel/#operands_58","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_66","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlreturn-vasthlreturnop","text":"Syntax: operation ::= `hl.return` ($result^ `:` type($result))? attr-dict Traits: soft_terminator","title":"hl.return (::vast::hl::ReturnOp)"},{"location":"HighLevel/HighLevel/#operands_59","text":"Operand Description result any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#hlscope-vasthlscopeop","text":"VAST scope declaration Syntax: operation ::= `hl.scope` $body attr-dict Scope operation servers to represent explicitly high-level code scope. Other control flow operations represent scopes implicitly. It is a single-region operation. Traits: NoTerminator","title":"hl.scope (::vast::hl::ScopeOp)"},{"location":"HighLevel/HighLevel/#hlsizeofexpr-vasthlsizeofexprop","text":"VAST expr sizeof operator Syntax: operation ::= `hl.sizeof.expr` attr-dict `->` type($result) $expr VAST expr sizeof operator","title":"hl.sizeof.expr (::vast::hl::SizeOfExprOp)"},{"location":"HighLevel/HighLevel/#results_67","text":"Result Description result integer like type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlsizeoftype-vasthlsizeoftypeop","text":"VAST type sizeof operator Syntax: operation ::= `hl.sizeof.type` $arg attr-dict `->` type($result) VAST type sizeof operator","title":"hl.sizeof.type (::vast::hl::SizeOfTypeOp)"},{"location":"HighLevel/HighLevel/#attributes_23","text":"Attribute MLIR Type Description arg ::mlir::TypeAttr any type attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#results_68","text":"Result Description result integer like type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlstmtexpr-vasthlstmtexprop","text":"VAST statement expression Syntax: operation ::= `hl.stmt.expr` attr-dict `:` type($result) $substmt VAST statement expression Traits: NoTerminator, SingleBlock","title":"hl.stmt.expr (::vast::hl::StmtExprOp)"},{"location":"HighLevel/HighLevel/#results_69","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlstruct-vasthlstructdeclop","text":"VAST struct declaration Syntax: operation ::= `hl.struct` $name attr-dict `:` $fields VAST struct declaration Traits: NoTerminator Interfaces: VastSymbol","title":"hl.struct (::vast::hl::StructDeclOp)"},{"location":"HighLevel/HighLevel/#attributes_24","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#hlassignfsub-vasthlsubfassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.fsub` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.fsub (::vast::hl::SubFAssignOp)"},{"location":"HighLevel/HighLevel/#operands_60","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_70","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlfsub-vasthlsubfop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.fsub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.fsub (::vast::hl::SubFOp)"},{"location":"HighLevel/HighLevel/#operands_61","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_71","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlassignsub-vasthlsubiassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.sub` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.sub (::vast::hl::SubIAssignOp)"},{"location":"HighLevel/HighLevel/#operands_62","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_72","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlsub-vasthlsubiop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.sub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.sub (::vast::hl::SubIOp)"},{"location":"HighLevel/HighLevel/#operands_63","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_73","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlsubscript-vasthlsubscriptop","text":"VAST array subscript operator Syntax: operation ::= `hl.subscript` $array `at` ` ` `[` $index `:` type($index) `]` attr-dict `:` type($array) `->` type($result) VAST array subscript operator","title":"hl.subscript (::vast::hl::SubscriptOp)"},{"location":"HighLevel/HighLevel/#operands_64","text":"Operand Description array lvalue to subscriptable type index integer like type","title":"Operands:"},{"location":"HighLevel/HighLevel/#results_74","text":"Result Description result lvalue to any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hlthis-vasthlthisop","text":"VAST this operator Syntax: operation ::= `hl.this` attr-dict `:` type($result) VAST this operator","title":"hl.this (::vast::hl::ThisOp)"},{"location":"HighLevel/HighLevel/#results_75","text":"Result Description result any type","title":"Results:"},{"location":"HighLevel/HighLevel/#hltranslation_unit-vasthltranslationunitop","text":"VAST translation unit Syntax: operation ::= `hl.translation_unit` $body attr-dict VAST tranaslation unit Traits: IsolatedFromAbove, NoTerminator, SymbolTable","title":"hl.translation_unit (::vast::hl::TranslationUnitOp)"},{"location":"HighLevel/HighLevel/#hltype-vasthltypedeclop","text":"VAST type declaration Syntax: operation ::= `hl.type` $name attr-dict VAST type declaration Interfaces: VastSymbol","title":"hl.type (::vast::hl::TypeDeclOp)"},{"location":"HighLevel/HighLevel/#attributes_25","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#hltypedef-vasthltypedefop","text":"VAST typedef operation Syntax: operation ::= `hl.typedef` $name attr-dict `:` $type Typedef operation servers to declare named types. It creates a new type symbol in the current scope to be referenced as NamedType later. Interfaces: VastSymbol","title":"hl.typedef (::vast::hl::TypeDefOp)"},{"location":"HighLevel/HighLevel/#attributes_26","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#hlunion-vasthluniondeclop","text":"VAST record declaration Syntax: operation ::= `hl.union` $name attr-dict `:` $fields VAST record declaration Traits: NoTerminator Interfaces: VastSymbol","title":"hl.union (::vast::hl::UnionDeclOp)"},{"location":"HighLevel/HighLevel/#attributes_27","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"HighLevel/HighLevel/#hlunreachable-vasthlunreachableop","text":"VAST unreachable operation Syntax: operation ::= `hl.unreachable` attr-dict VAST unreachable operation Traits: Terminator","title":"hl.unreachable (::vast::hl::UnreachableOp)"},{"location":"HighLevel/HighLevel/#attribute-definition","text":"","title":"Attribute definition"},{"location":"HighLevel/HighLevel/#annotationattr","text":"Syntax: #hl.annotation< ::mlir::StringAttr # name >","title":"AnnotationAttr"},{"location":"HighLevel/HighLevel/#parameters","text":"Parameter C++ type Description name ::mlir::StringAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#booleanattr","text":"An Attribute containing a boolean value Syntax: #core.bool< ::mlir::Type, # type bool # value > An boolean attribute is a literal attribute that represents a boolean value.","title":"BooleanAttr"},{"location":"HighLevel/HighLevel/#parameters_1","text":"Parameter C++ type Description type ::mlir::Type value bool","title":"Parameters:"},{"location":"HighLevel/HighLevel/#cvqualifiersattr","text":"Syntax: #hl.quals< bool, # is_const bool # is_volatile >","title":"CVQualifiersAttr"},{"location":"HighLevel/HighLevel/#parameters_2","text":"Parameter C++ type Description is_const bool const qualifier is_volatile bool volatile qualifier","title":"Parameters:"},{"location":"HighLevel/HighLevel/#cvrqualifiersattr","text":"Syntax: #hl.quals< bool, # is_const bool, # is_volatile bool # is_restrict >","title":"CVRQualifiersAttr"},{"location":"HighLevel/HighLevel/#parameters_3","text":"Parameter C++ type Description is_const bool const qualifier is_volatile bool volatile qualifier is_restrict bool restrict qualifier","title":"Parameters:"},{"location":"HighLevel/HighLevel/#floatattr","text":"An Attribute containing a floating point value Syntax: #core.float< ::mlir::Type, # type ::llvm::APFloat # value > A float attribute is a literal attribute that represents a floating point value of the specified floating point type.","title":"FloatAttr"},{"location":"HighLevel/HighLevel/#parameters_4","text":"Parameter C++ type Description type ::mlir::Type value ::llvm::APFloat","title":"Parameters:"},{"location":"HighLevel/HighLevel/#integerattr","text":"An Attribute containing a integer value Syntax: #core.integer< ::mlir::Type, # type ::llvm::APSInt # value > An integer attribute is a literal attribute that represents an integral value of the specified integer type.","title":"IntegerAttr"},{"location":"HighLevel/HighLevel/#parameters_5","text":"Parameter C++ type Description type ::mlir::Type value ::llvm::APSInt","title":"Parameters:"},{"location":"HighLevel/HighLevel/#stringattr","text":"An Attribute containing a string Syntax: #core.str< ::llvm::StringRef, # value ::mlir::Type # type > Note: Temporarily copied from builtin dialect, because llvm-15 does not have TypedAttrInterface yet. Syntax: string-attribute ::= string-literal (`:` type)? A string attribute is an attribute that represents a string literal value. Examples: \"An important string\" \"string with a type\" : !dialect.string","title":"StringAttr"},{"location":"HighLevel/HighLevel/#parameters_6","text":"Parameter C++ type Description value ::llvm::StringRef type ::mlir::Type","title":"Parameters:"},{"location":"HighLevel/HighLevel/#stringliteralattr","text":"An Attribute containing an escaped string Syntax: string-attribute ::= string-literal (`:` type)? A string literal attribute is an attribute that represents an escaped string literal value. Examples: \"An important string\" \"string with a type\" : !dialect.string","title":"StringLiteralAttr"},{"location":"HighLevel/HighLevel/#parameters_7","text":"Parameter C++ type Description value ::llvm::StringRef type ::mlir::Type","title":"Parameters:"},{"location":"HighLevel/HighLevel/#ucvqualifiersattr","text":"Syntax: #hl.quals< bool, # is_unsigned bool, # is_const bool # is_volatile >","title":"UCVQualifiersAttr"},{"location":"HighLevel/HighLevel/#parameters_8","text":"Parameter C++ type Description is_unsigned bool unsigned qualifier is_const bool const qualifier is_volatile bool volatile qualifier","title":"Parameters:"},{"location":"HighLevel/HighLevel/#type-definition","text":"","title":"Type definition"},{"location":"HighLevel/HighLevel/#adjustedtype","text":"Syntax: !hl.adjusted< Type, # original Type # adjusted >","title":"AdjustedType"},{"location":"HighLevel/HighLevel/#parameters_9","text":"Parameter C++ type Description original Type adjusted Type","title":"Parameters:"},{"location":"HighLevel/HighLevel/#arraytype","text":"Syntax: !hl.array< SizeParam, # size Type, # elementType CVRQualifiersAttr # quals >","title":"ArrayType"},{"location":"HighLevel/HighLevel/#parameters_10","text":"Parameter C++ type Description size SizeParam size parameter for arrays elementType Type quals CVRQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#attributedtype","text":"Syntax: !hl.attributed< Type # elementType >","title":"AttributedType"},{"location":"HighLevel/HighLevel/#parameters_11","text":"Parameter C++ type Description elementType Type","title":"Parameters:"},{"location":"HighLevel/HighLevel/#bfloat16type","text":"Syntax: !hl.bfloat16< CVQualifiersAttr # quals >","title":"BFloat16Type"},{"location":"HighLevel/HighLevel/#parameters_12","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#booltype","text":"Syntax: !hl.bool< CVQualifiersAttr # quals >","title":"BoolType"},{"location":"HighLevel/HighLevel/#parameters_13","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#chartype","text":"Syntax: !hl.char< UCVQualifiersAttr # quals >","title":"CharType"},{"location":"HighLevel/HighLevel/#parameters_14","text":"Parameter C++ type Description quals UCVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#decayedtype","text":"Syntax: !hl.decayed< Type # elementType >","title":"DecayedType"},{"location":"HighLevel/HighLevel/#parameters_15","text":"Parameter C++ type Description elementType Type","title":"Parameters:"},{"location":"HighLevel/HighLevel/#doubletype","text":"Syntax: !hl.double< CVQualifiersAttr # quals >","title":"DoubleType"},{"location":"HighLevel/HighLevel/#parameters_16","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#elaboratedtype","text":"Syntax: !hl.elaborated< Type, # elementType CVRQualifiersAttr # quals >","title":"ElaboratedType"},{"location":"HighLevel/HighLevel/#parameters_17","text":"Parameter C++ type Description elementType Type quals CVRQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#enumtype","text":"Syntax: !hl.enum< ::llvm::StringRef, # name CVQualifiersAttr # quals >","title":"EnumType"},{"location":"HighLevel/HighLevel/#parameters_18","text":"Parameter C++ type Description name ::llvm::StringRef quals CVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#float128type","text":"Syntax: !hl.float128< CVQualifiersAttr # quals >","title":"Float128Type"},{"location":"HighLevel/HighLevel/#parameters_19","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#floattype","text":"Syntax: !hl.float< CVQualifiersAttr # quals >","title":"FloatType"},{"location":"HighLevel/HighLevel/#parameters_20","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#halftype","text":"Syntax: !hl.half< CVQualifiersAttr # quals >","title":"HalfType"},{"location":"HighLevel/HighLevel/#parameters_21","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#int128type","text":"Syntax: !hl.int128< UCVQualifiersAttr # quals >","title":"Int128Type"},{"location":"HighLevel/HighLevel/#parameters_22","text":"Parameter C++ type Description quals UCVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#inttype","text":"Syntax: !hl.int< UCVQualifiersAttr # quals >","title":"IntType"},{"location":"HighLevel/HighLevel/#parameters_23","text":"Parameter C++ type Description quals UCVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#lvaluetype","text":"Syntax: !hl.lvalue< Type # elementType >","title":"LValueType"},{"location":"HighLevel/HighLevel/#parameters_24","text":"Parameter C++ type Description elementType Type","title":"Parameters:"},{"location":"HighLevel/HighLevel/#labeltype","text":"Syntax: !hl.label","title":"LabelType"},{"location":"HighLevel/HighLevel/#longdoubletype","text":"Syntax: !hl.longdouble< CVQualifiersAttr # quals >","title":"LongDoubleType"},{"location":"HighLevel/HighLevel/#parameters_25","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#longlongtype","text":"Syntax: !hl.longlong< UCVQualifiersAttr # quals >","title":"LongLongType"},{"location":"HighLevel/HighLevel/#parameters_26","text":"Parameter C++ type Description quals UCVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#longtype","text":"Syntax: !hl.long< UCVQualifiersAttr # quals >","title":"LongType"},{"location":"HighLevel/HighLevel/#parameters_27","text":"Parameter C++ type Description quals UCVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#parentype","text":"Syntax: !hl.paren< Type # elementType >","title":"ParenType"},{"location":"HighLevel/HighLevel/#parameters_28","text":"Parameter C++ type Description elementType Type","title":"Parameters:"},{"location":"HighLevel/HighLevel/#pointertype","text":"Syntax: !hl.ptr< Type, # elementType CVRQualifiersAttr # quals >","title":"PointerType"},{"location":"HighLevel/HighLevel/#parameters_29","text":"Parameter C++ type Description elementType Type quals CVRQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#rvaluetype","text":"Syntax: !hl.rvalue< Type # elementType >","title":"RValueType"},{"location":"HighLevel/HighLevel/#parameters_30","text":"Parameter C++ type Description elementType Type","title":"Parameters:"},{"location":"HighLevel/HighLevel/#recordtype","text":"Syntax: !hl.record< ::llvm::StringRef, # name CVQualifiersAttr # quals >","title":"RecordType"},{"location":"HighLevel/HighLevel/#parameters_31","text":"Parameter C++ type Description name ::llvm::StringRef quals CVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#referencetype","text":"Syntax: !hl.reference< Type # elementType >","title":"ReferenceType"},{"location":"HighLevel/HighLevel/#parameters_32","text":"Parameter C++ type Description elementType Type","title":"Parameters:"},{"location":"HighLevel/HighLevel/#shorttype","text":"Syntax: !hl.short< UCVQualifiersAttr # quals >","title":"ShortType"},{"location":"HighLevel/HighLevel/#parameters_33","text":"Parameter C++ type Description quals UCVQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#typedeftype","text":"Syntax: !hl.typedef< ::llvm::StringRef, # name CVRQualifiersAttr # quals >","title":"TypedefType"},{"location":"HighLevel/HighLevel/#parameters_34","text":"Parameter C++ type Description name ::llvm::StringRef quals CVRQualifiersAttr","title":"Parameters:"},{"location":"HighLevel/HighLevel/#voidtype","text":"Syntax: !hl.void< CVQualifiersAttr # quals >","title":"VoidType"},{"location":"HighLevel/HighLevel/#parameters_35","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"LowLevel/LowLevel/","text":"'ll' Dialect A vast low-level dialect. This dialect serves as a bottom layer in VAST dialect tower. There should always exist a pass that lowers this dialect into LLVM Dialect. Work in progress - new operations are still being added and existing can be changed or removed. 'll' Dialect Operation definition ll.br (::vast::ll::Br) Operands: Successors: ll.cond_br (::vast::ll::CondBr) Operands: Successors: ll.cond_scope_ret (::vast::ll::CondScopeRet) Operands: Successors: ll.initialize (::vast::ll::InitializeVar) Operands: Results: ll.inline_scope (::vast::ll::InlineScope) ll.gep (::vast::ll::StructGEPOp) Attributes: Operands: Results: ll.return (::vast::ll::ReturnOp) Operands: ll.scope (::vast::ll::Scope) ll.scope_recurse (::vast::ll::ScopeRecurse) ll.scope_ret (::vast::ll::ScopeRet) ll.uninitialized_var (::vast::ll::UninitializedVar) Results: Operation definition ll.br (::vast::ll::Br) Direct branch. Syntax: operation ::= `ll.br` $dest (`(` $operands^ `:` type($operands) `)`)? attr-dict Direct branch Traits: Terminator Interfaces: BranchOpInterface Operands: Operand Description operands any type Successors: Successor Description dest any successor ll.cond_br (::vast::ll::CondBr) Conditional branch. Syntax: operation ::= `ll.cond_br` $cond `:` type($cond) `,` $trueDest (`(` $trueOperands^ `:` type($trueOperands) `)`)? `,` $falseDest (`(` $falseOperands^ `:` type($falseOperands) `)`)? attr-dict Direct branch Traits: AttrSizedOperandSegments, Terminator Operands: Operand Description cond any type trueOperands any type falseOperands any type Successors: Successor Description trueDest any successor falseDest any successor ll.cond_scope_ret (::vast::ll::CondScopeRet) Terminator of scope if condition is met, otherwise branch. Syntax: operation ::= `ll.cond_scope_ret` $cond `:` type($cond) `,` $dest (`(` $dest_operands^ `:` type($dest_operands) `)`)? attr-dict Terminate or branch. Traits: Terminator Operands: Operand Description cond any type dest_operands any type Successors: Successor Description dest any successor ll.initialize (::vast::ll::InitializeVar) Initialize a variable. Syntax: operation ::= `ll.initialize` operands attr-dict `:` functional-type(operands, results) Initialize a variable - for now this operation is a direct lowering from hl.var initialization section. Later there will be need to discover how this ties to constructors. Operands: Operand Description var any type elements any type Results: Result Description result any type ll.inline_scope (::vast::ll::InlineScope) Scope, that forwards (cond)scope return up. Result of inlined if. Traits: NoRegionArguments ll.gep (::vast::ll::StructGEPOp) VAST struct gep operation VAST struct gep operation Attributes: Attribute MLIR Type Description idx ::mlir::IntegerAttr 32-bit signless integer attribute name ::mlir::StringAttr string attribute Operands: Operand Description record any type Results: Result Description element any type ll.return (::vast::ll::ReturnOp) Syntax: operation ::= `ll.return` ($result^ `:` type($result))? attr-dict Traits: Terminator Operands: Operand Description result any type ll.scope (::vast::ll::Scope) Scope, holds one region. Syntax: operation ::= `ll.scope` $body attr-dict Scope that holds one region, each block should be terminated with either branch, scope return or their conditional variants. Traits: NoRegionArguments ll.scope_recurse (::vast::ll::ScopeRecurse) Jump to first block of scope. Syntax: operation ::= `ll.scope_recurse` attr-dict Modelling continue. Traits: Terminator ll.scope_ret (::vast::ll::ScopeRet) Terminator of scope. Syntax: operation ::= `ll.scope_ret` attr-dict Terminator of scopes (for example during lowering of loops). Traits: Terminator ll.uninitialized_var (::vast::ll::UninitializedVar) Declaration of variable that have not been initialized yet. Syntax: operation ::= `ll.uninitialized_var` attr-dict `:` type($result) Declaration of variable that have not been initialized yet. Interfaces: VastSymbol Results: Result Description result any type","title":"LowLevel"},{"location":"LowLevel/LowLevel/#ll-dialect","text":"A vast low-level dialect. This dialect serves as a bottom layer in VAST dialect tower. There should always exist a pass that lowers this dialect into LLVM Dialect. Work in progress - new operations are still being added and existing can be changed or removed. 'll' Dialect Operation definition ll.br (::vast::ll::Br) Operands: Successors: ll.cond_br (::vast::ll::CondBr) Operands: Successors: ll.cond_scope_ret (::vast::ll::CondScopeRet) Operands: Successors: ll.initialize (::vast::ll::InitializeVar) Operands: Results: ll.inline_scope (::vast::ll::InlineScope) ll.gep (::vast::ll::StructGEPOp) Attributes: Operands: Results: ll.return (::vast::ll::ReturnOp) Operands: ll.scope (::vast::ll::Scope) ll.scope_recurse (::vast::ll::ScopeRecurse) ll.scope_ret (::vast::ll::ScopeRet) ll.uninitialized_var (::vast::ll::UninitializedVar) Results:","title":"'ll' Dialect"},{"location":"LowLevel/LowLevel/#operation-definition","text":"","title":"Operation definition"},{"location":"LowLevel/LowLevel/#llbr-vastllbr","text":"Direct branch. Syntax: operation ::= `ll.br` $dest (`(` $operands^ `:` type($operands) `)`)? attr-dict Direct branch Traits: Terminator Interfaces: BranchOpInterface","title":"ll.br (::vast::ll::Br)"},{"location":"LowLevel/LowLevel/#operands","text":"Operand Description operands any type","title":"Operands:"},{"location":"LowLevel/LowLevel/#successors","text":"Successor Description dest any successor","title":"Successors:"},{"location":"LowLevel/LowLevel/#llcond_br-vastllcondbr","text":"Conditional branch. Syntax: operation ::= `ll.cond_br` $cond `:` type($cond) `,` $trueDest (`(` $trueOperands^ `:` type($trueOperands) `)`)? `,` $falseDest (`(` $falseOperands^ `:` type($falseOperands) `)`)? attr-dict Direct branch Traits: AttrSizedOperandSegments, Terminator","title":"ll.cond_br (::vast::ll::CondBr)"},{"location":"LowLevel/LowLevel/#operands_1","text":"Operand Description cond any type trueOperands any type falseOperands any type","title":"Operands:"},{"location":"LowLevel/LowLevel/#successors_1","text":"Successor Description trueDest any successor falseDest any successor","title":"Successors:"},{"location":"LowLevel/LowLevel/#llcond_scope_ret-vastllcondscoperet","text":"Terminator of scope if condition is met, otherwise branch. Syntax: operation ::= `ll.cond_scope_ret` $cond `:` type($cond) `,` $dest (`(` $dest_operands^ `:` type($dest_operands) `)`)? attr-dict Terminate or branch. Traits: Terminator","title":"ll.cond_scope_ret (::vast::ll::CondScopeRet)"},{"location":"LowLevel/LowLevel/#operands_2","text":"Operand Description cond any type dest_operands any type","title":"Operands:"},{"location":"LowLevel/LowLevel/#successors_2","text":"Successor Description dest any successor","title":"Successors:"},{"location":"LowLevel/LowLevel/#llinitialize-vastllinitializevar","text":"Initialize a variable. Syntax: operation ::= `ll.initialize` operands attr-dict `:` functional-type(operands, results) Initialize a variable - for now this operation is a direct lowering from hl.var initialization section. Later there will be need to discover how this ties to constructors.","title":"ll.initialize (::vast::ll::InitializeVar)"},{"location":"LowLevel/LowLevel/#operands_3","text":"Operand Description var any type elements any type","title":"Operands:"},{"location":"LowLevel/LowLevel/#results","text":"Result Description result any type","title":"Results:"},{"location":"LowLevel/LowLevel/#llinline_scope-vastllinlinescope","text":"Scope, that forwards (cond)scope return up. Result of inlined if. Traits: NoRegionArguments","title":"ll.inline_scope (::vast::ll::InlineScope)"},{"location":"LowLevel/LowLevel/#llgep-vastllstructgepop","text":"VAST struct gep operation VAST struct gep operation","title":"ll.gep (::vast::ll::StructGEPOp)"},{"location":"LowLevel/LowLevel/#attributes","text":"Attribute MLIR Type Description idx ::mlir::IntegerAttr 32-bit signless integer attribute name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"LowLevel/LowLevel/#operands_4","text":"Operand Description record any type","title":"Operands:"},{"location":"LowLevel/LowLevel/#results_1","text":"Result Description element any type","title":"Results:"},{"location":"LowLevel/LowLevel/#llreturn-vastllreturnop","text":"Syntax: operation ::= `ll.return` ($result^ `:` type($result))? attr-dict Traits: Terminator","title":"ll.return (::vast::ll::ReturnOp)"},{"location":"LowLevel/LowLevel/#operands_5","text":"Operand Description result any type","title":"Operands:"},{"location":"LowLevel/LowLevel/#llscope-vastllscope","text":"Scope, holds one region. Syntax: operation ::= `ll.scope` $body attr-dict Scope that holds one region, each block should be terminated with either branch, scope return or their conditional variants. Traits: NoRegionArguments","title":"ll.scope (::vast::ll::Scope)"},{"location":"LowLevel/LowLevel/#llscope_recurse-vastllscoperecurse","text":"Jump to first block of scope. Syntax: operation ::= `ll.scope_recurse` attr-dict Modelling continue. Traits: Terminator","title":"ll.scope_recurse (::vast::ll::ScopeRecurse)"},{"location":"LowLevel/LowLevel/#llscope_ret-vastllscoperet","text":"Terminator of scope. Syntax: operation ::= `ll.scope_ret` attr-dict Terminator of scopes (for example during lowering of loops). Traits: Terminator","title":"ll.scope_ret (::vast::ll::ScopeRet)"},{"location":"LowLevel/LowLevel/#lluninitialized_var-vastlluninitializedvar","text":"Declaration of variable that have not been initialized yet. Syntax: operation ::= `ll.uninitialized_var` attr-dict `:` type($result) Declaration of variable that have not been initialized yet. Interfaces: VastSymbol","title":"ll.uninitialized_var (::vast::ll::UninitializedVar)"},{"location":"LowLevel/LowLevel/#results_2","text":"Result Description result any type","title":"Results:"},{"location":"Meta/Meta/","text":"'meta' Dialect A vast metadata dialect. This dialect intends capture user metadata that are kept accross transformations. 'meta' Dialect Attribute definition IdentifierAttr Parameters: Attribute definition IdentifierAttr A metadata identifier. Syntax: #meta.id< identifier_t # value > A metadata identifier can be used to relate operations to external metadata storage. #meta.id<\"0x3A28213A\"> Parameters: Parameter C++ type Description value identifier_t","title":"Meta"},{"location":"Meta/Meta/#meta-dialect","text":"A vast metadata dialect. This dialect intends capture user metadata that are kept accross transformations. 'meta' Dialect Attribute definition IdentifierAttr Parameters:","title":"'meta' Dialect"},{"location":"Meta/Meta/#attribute-definition","text":"","title":"Attribute definition"},{"location":"Meta/Meta/#identifierattr","text":"A metadata identifier. Syntax: #meta.id< identifier_t # value > A metadata identifier can be used to relate operations to external metadata storage. #meta.id<\"0x3A28213A\">","title":"IdentifierAttr"},{"location":"Meta/Meta/#parameters","text":"Parameter C++ type Description value identifier_t","title":"Parameters:"},{"location":"Tools/vast-cc/","text":"VAST: Compiler To compile c or c++ code use vast-cc tool: vast-cc --from-source <source.c> The tool compiles source.c to clang ast and emits mlir in the high-level dialect. To pass additional compiler options use --ccopts option. For further information see vast-cc --help .","title":"Vast cc"},{"location":"Tools/vast-cc/#vast-compiler","text":"To compile c or c++ code use vast-cc tool: vast-cc --from-source <source.c> The tool compiles source.c to clang ast and emits mlir in the high-level dialect. To pass additional compiler options use --ccopts option. For further information see vast-cc --help .","title":"VAST: Compiler"},{"location":"Tools/vast-lsp-server/","text":"VAST: Language Server Protocol VAST provides an implementation of LSP language server in the form of the vast-lsp-server tool. This tool interacts with the MLIR C++ API to support rich language queries, such as \u201cFind Definition\u201d. The tool easily integrates with VSCode extension MLIR . The user needs to point the extension to mlir-lsp-server . To do so, one can create a symbolic link named mlir-lsp-server to point to built vast-lsp-server . Build To build vast-lsp-server use: cmake --build <build-dir> --target vast-lsp-server","title":"VAST: Language Server Protocol"},{"location":"Tools/vast-lsp-server/#vast-language-server-protocol","text":"VAST provides an implementation of LSP language server in the form of the vast-lsp-server tool. This tool interacts with the MLIR C++ API to support rich language queries, such as \u201cFind Definition\u201d. The tool easily integrates with VSCode extension MLIR . The user needs to point the extension to mlir-lsp-server . To do so, one can create a symbolic link named mlir-lsp-server to point to built vast-lsp-server .","title":"VAST: Language Server Protocol"},{"location":"Tools/vast-lsp-server/#build","text":"To build vast-lsp-server use: cmake --build <build-dir> --target vast-lsp-server","title":"Build"},{"location":"Tools/vast-opt/","text":"VAST: Optimizer After mlir module from vast-cc is produced, we can leverage our optimisation pipeline to transform module in various ways. The lowest level we can do is LLVM dialect, from which we can dump LLVM IR if desired. Overall design philosophy is that passes try to be really modular, self-contained and doing one thing properly - all while trying to preserve provenance metadata. Sometimes this does not exactly hold (transformation from HL into LL is huge) but it is what we strive for. Passes will more often than not have some dependencies between themselves - always consult documentation if unsure and report an issue if wiki is out of date on this. Metadata and passes TODO (lukas): Improve once we have examples TL;DR : Vast provided passes always try to keep metadata (and they should do a good job), but for passes from other sources this does not hold and probably some heuristic will be used to re-compute them in best-effort. Passes Passes we have implemented can be roughly grouped into several categories. We also note some of the native mlir passes that are needed to continue with transformations to reach LLVM dialect. Type lowering A common prerequisite for other passes is to lower HL types into standard types. This can be done in two steps: * --vast-hl-lower-types - Converts simple (non-struct) types according to provided data layout (embedded in the mlir module metadata). * --vast-hl-structs-to-tuples - Converts HL struct types into standard tuples While these should be commutative, the preferred order is --vast-hl-lower-types --vast-hl-structs-to-tuples HL -> SCF --vast-hl-to-scf Requires: Type lowering Conversion of HL control flow ops (currently only hl.if and hl.while ) into their scf equivalents. Since scf requires i1 in their conditions, additional casts may be inserted to satisfy this requirement (currently they are emitted in HL however this behaviour should customisable eventually. To produce an LLVM following addition passes must be run --convert-scf-to-std --convert-std-to-llvm and possibly --vast-hl-to-ll as well (or some equivalent, depending on how conditions are coerced) HL -> LL --vast-hl-to-ll Requires: Type lowering Some form of control flow lowering Lower all HL operation into their LLVM dialect equivalents - this is a rather huge pass, for details see its documentation. LLVM Dump --vast-llvm-dump Requires: Entire module must be in LLVM dialect (or have operation for which conversion hooks are provided) LLVM bitcode is dumped to llvm::errs() in human readable form. Since passes can run in parallel, dump to file is non-trivial. Example Usage Let's say we have file main.c which we want to lower into some dialect. First let's have a look at some generic invocations we may find handy: To get mlir module via vast-cc vast-cc --ccopts -xc --from-source main.c A quick remainder * --ccopts -xc says we are doing C not C++ * --from-source file says that source code comes from the file Once we have the module, we can invoke vast-opt , with easiest way being a simple pipe vast-cc --ccopts -xc --from-source main.c | vast-opt pass-we-want another-pass-we-want If we want, we can also chain pipes vast-cc --ccopts -xc --from-source main.c | vast-opt pass | vast-opt another-pass | ... Now, let's say we want to lower into LLVM bitcode, therefore the invocation will look as follows vast-cc --ccopts -xc --from-source main.c | vast-opt --vast-hl-lower-types --vast-hl-structs-to-tuples --vast-hl-to-scf --convert-scf-to-std --convert-std-to-llvm --vast-hl-to-ll","title":"VAST: Optimizer"},{"location":"Tools/vast-opt/#vast-optimizer","text":"After mlir module from vast-cc is produced, we can leverage our optimisation pipeline to transform module in various ways. The lowest level we can do is LLVM dialect, from which we can dump LLVM IR if desired. Overall design philosophy is that passes try to be really modular, self-contained and doing one thing properly - all while trying to preserve provenance metadata. Sometimes this does not exactly hold (transformation from HL into LL is huge) but it is what we strive for. Passes will more often than not have some dependencies between themselves - always consult documentation if unsure and report an issue if wiki is out of date on this.","title":"VAST: Optimizer"},{"location":"Tools/vast-opt/#metadata-and-passes","text":"TODO (lukas): Improve once we have examples TL;DR : Vast provided passes always try to keep metadata (and they should do a good job), but for passes from other sources this does not hold and probably some heuristic will be used to re-compute them in best-effort.","title":"Metadata and passes"},{"location":"Tools/vast-opt/#passes","text":"Passes we have implemented can be roughly grouped into several categories. We also note some of the native mlir passes that are needed to continue with transformations to reach LLVM dialect.","title":"Passes"},{"location":"Tools/vast-opt/#type-lowering","text":"A common prerequisite for other passes is to lower HL types into standard types. This can be done in two steps: * --vast-hl-lower-types - Converts simple (non-struct) types according to provided data layout (embedded in the mlir module metadata). * --vast-hl-structs-to-tuples - Converts HL struct types into standard tuples While these should be commutative, the preferred order is --vast-hl-lower-types --vast-hl-structs-to-tuples","title":"Type lowering"},{"location":"Tools/vast-opt/#hl-scf","text":"--vast-hl-to-scf Requires: Type lowering Conversion of HL control flow ops (currently only hl.if and hl.while ) into their scf equivalents. Since scf requires i1 in their conditions, additional casts may be inserted to satisfy this requirement (currently they are emitted in HL however this behaviour should customisable eventually. To produce an LLVM following addition passes must be run --convert-scf-to-std --convert-std-to-llvm and possibly --vast-hl-to-ll as well (or some equivalent, depending on how conditions are coerced)","title":"HL -&gt; SCF"},{"location":"Tools/vast-opt/#hl-ll","text":"--vast-hl-to-ll Requires: Type lowering Some form of control flow lowering Lower all HL operation into their LLVM dialect equivalents - this is a rather huge pass, for details see its documentation.","title":"HL -&gt; LL"},{"location":"Tools/vast-opt/#llvm-dump","text":"--vast-llvm-dump Requires: Entire module must be in LLVM dialect (or have operation for which conversion hooks are provided) LLVM bitcode is dumped to llvm::errs() in human readable form. Since passes can run in parallel, dump to file is non-trivial.","title":"LLVM Dump"},{"location":"Tools/vast-opt/#example-usage","text":"Let's say we have file main.c which we want to lower into some dialect. First let's have a look at some generic invocations we may find handy: To get mlir module via vast-cc vast-cc --ccopts -xc --from-source main.c A quick remainder * --ccopts -xc says we are doing C not C++ * --from-source file says that source code comes from the file Once we have the module, we can invoke vast-opt , with easiest way being a simple pipe vast-cc --ccopts -xc --from-source main.c | vast-opt pass-we-want another-pass-we-want If we want, we can also chain pipes vast-cc --ccopts -xc --from-source main.c | vast-opt pass | vast-opt another-pass | ... Now, let's say we want to lower into LLVM bitcode, therefore the invocation will look as follows vast-cc --ccopts -xc --from-source main.c | vast-opt --vast-hl-lower-types --vast-hl-structs-to-tuples --vast-hl-to-scf --convert-scf-to-std --convert-std-to-llvm --vast-hl-to-ll","title":"Example Usage"},{"location":"Tools/vast-query/","text":"VAST: Query vast-query is a command line tool to query symbols in the vast generated MLIR. Its primary purpose is to test symbols and their use edges in the produced MLIR. Example of usage: vast-query [options] <input file> Options: --scope=<function name> - Show values from scope of a given function --show-symbols=<value> - Show MLIR symbols =functions - show function symbols =types - show type symbols =records - show record symbols =vars - show variable symbols =globs - show global variable symbols =all - show all symbols --symbol-users=<symbol name> - Show users of a given symbol","title":"VAST: Query"},{"location":"Tools/vast-query/#vast-query","text":"vast-query is a command line tool to query symbols in the vast generated MLIR. Its primary purpose is to test symbols and their use edges in the produced MLIR. Example of usage: vast-query [options] <input file> Options: --scope=<function name> - Show values from scope of a given function --show-symbols=<value> - Show MLIR symbols =functions - show function symbols =types - show type symbols =records - show record symbols =vars - show variable symbols =globs - show global variable symbols =all - show all symbols --symbol-users=<symbol name> - Show users of a given symbol","title":"VAST: Query"},{"location":"Tools/vast-repl/","text":"VAST: REPL WIP vast-repl is an interactive MLIR query and modification tool. Commands: exit - exits repl help - prints help load <filename> - loads source from file show <value> - displays queried value =source - loaded source code =ast - clang ast =module - current VAST MLIR module =symbols - present symbols in the module meta <action> - operates on metadata for given symbol =add <symbol> <id> - adds <id> meta to <symbol> =get <id> - gets symbol with <id> meta","title":"VAST: REPL"},{"location":"Tools/vast-repl/#vast-repl","text":"WIP vast-repl is an interactive MLIR query and modification tool. Commands: exit - exits repl help - prints help load <filename> - loads source from file show <value> - displays queried value =source - loaded source code =ast - clang ast =module - current VAST MLIR module =symbols - present symbols in the module meta <action> - operates on metadata for given symbol =add <symbol> <id> - adds <id> meta to <symbol> =get <id> - gets symbol with <id> meta","title":"VAST: REPL"},{"location":"dialects/HighLevelPasses/","text":"-vast-export-fn-info Create JSON that exports information about function arguments. Lowers module into llvm IR and dumps it on stderr. Options -o : Output JSON file to be created. -vast-hl-canonicalize Canonicalize hl dialect. This pass inserts returns with void values where missing and removes surplus skips. -vast-hl-dce Trim dead code Removes unreachable code, such as code after return or break/continue. -vast-hl-lower-typedefs Replace hl::TypeDef type by its underlying aliased type. Replaces hl::TypeDef types by its underlying aliased types. The conversion resolves nested typedefs. All hl::TypeDef are marked illegal and converted by this pass. -vast-hl-lower-types Lower high-level types to standard types Lower high-level types into standard types which is usually required first step by other passes in the pipeline. Information about bit sizes of high level types is inferred from the data layout of the module, which is derived from the information provided by clang and emitted automatically by vast-cc . TODO: Named types are not yet supported. -vast-hl-splice-trailing-scopes Remove trailing hl::Scope s. Removes trailing scopes.","title":"HighLevelPasses"},{"location":"dialects/HighLevelPasses/#-vast-export-fn-info","text":"Create JSON that exports information about function arguments. Lowers module into llvm IR and dumps it on stderr.","title":"-vast-export-fn-info"},{"location":"dialects/HighLevelPasses/#options","text":"-o : Output JSON file to be created.","title":"Options"},{"location":"dialects/HighLevelPasses/#-vast-hl-canonicalize","text":"Canonicalize hl dialect. This pass inserts returns with void values where missing and removes surplus skips.","title":"-vast-hl-canonicalize"},{"location":"dialects/HighLevelPasses/#-vast-hl-dce","text":"Trim dead code Removes unreachable code, such as code after return or break/continue.","title":"-vast-hl-dce"},{"location":"dialects/HighLevelPasses/#-vast-hl-lower-typedefs","text":"Replace hl::TypeDef type by its underlying aliased type. Replaces hl::TypeDef types by its underlying aliased types. The conversion resolves nested typedefs. All hl::TypeDef are marked illegal and converted by this pass.","title":"-vast-hl-lower-typedefs"},{"location":"dialects/HighLevelPasses/#-vast-hl-lower-types","text":"Lower high-level types to standard types Lower high-level types into standard types which is usually required first step by other passes in the pipeline. Information about bit sizes of high level types is inferred from the data layout of the module, which is derived from the information provided by clang and emitted automatically by vast-cc . TODO: Named types are not yet supported.","title":"-vast-hl-lower-types"},{"location":"dialects/HighLevelPasses/#-vast-hl-splice-trailing-scopes","text":"Remove trailing hl::Scope s. Removes trailing scopes.","title":"-vast-hl-splice-trailing-scopes"},{"location":"dialects/LowLevelPasses/","text":"-vast-ll-to-llvm Convert low level operations to LLVM dialect. Work in progess.","title":"LowLevelPasses"},{"location":"dialects/LowLevelPasses/#-vast-ll-to-llvm","text":"Convert low level operations to LLVM dialect. Work in progess.","title":"-vast-ll-to-llvm"},{"location":"dialects/ABI/ABI/","text":"'abi' Dialect A vast ABI dialect. Dialect provides operations to describe how arguments and return values are transformed to better model target abi. 'abi' Dialect Operation definition abi.call (::vast::abi::CallOp) Attributes: Operands: Results: abi.call_args (::vast::abi::CallArgsOp) Results: abi.call_exec (::vast::abi::CallExecutionOp) Attributes: Operands: Results: abi.call_rets (::vast::abi::CallRetsOp) Results: abi.direct (::vast::abi::DirectOp) Operands: Results: abi.epilogue (::vast::abi::EpilogueOp) Results: abi.func (::vast::abi::FuncOp) Attributes: abi.prologue (::vast::abi::PrologueOp) Results: abi.ret_direct (::vast::abi::RetDirectOp) Operands: Results: abi.todo (::vast::abi::TodoOp) Operands: Results: abi.wrap_fn (::vast::abi::WrapFuncOp) Attributes: abi.yield (::vast::abi::YieldOp) Operands: Results: Operation definition abi.call (::vast::abi::CallOp) ABI call operation Syntax: operation ::= `abi.call` $callee `(` $args `)` attr-dict `:` functional-type( $args, $results ) ABI call operation Interfaces: CallOpInterface Attributes: Attribute MLIR Type Description callee ::mlir::FlatSymbolRefAttr flat symbol reference attribute Operands: Operand Description args any type Results: Result Description results any type abi.call_args (::vast::abi::CallArgsOp) Not implement yet. Syntax: operation ::= `abi.call_args` $body attr-dict `:` type($results) WIP Results: Result Description results any type abi.call_exec (::vast::abi::CallExecutionOp) WIP Syntax: operation ::= `abi.call_exec` $callee `(` $args `)` $body attr-dict `:` functional-type($args, $result) WIP Interfaces: CallOpInterface Attributes: Attribute MLIR Type Description callee ::mlir::FlatSymbolRefAttr flat symbol reference attribute Operands: Operand Description args any type Results: Result Description result any type abi.call_rets (::vast::abi::CallRetsOp) Not implement yet. Syntax: operation ::= `abi.call_rets` $body attr-dict `:` type($results) WIP Results: Result Description results any type abi.direct (::vast::abi::DirectOp) Pass value directly - usually means by register Syntax: operation ::= `abi.direct` $value attr-dict `:` type($value) `->` type($result) Pass value directly - usually means by register. Operands: Operand Description value any type Results: Result Description result any type abi.epilogue (::vast::abi::EpilogueOp) WIP Syntax: operation ::= `abi.epilogue` $body attr-dict `:` type($results) WIP Results: Result Description results any type abi.func (::vast::abi::FuncOp) _ Function with transformed type. _ Syntax: operation ::= `abi.func` $sym_name custom< FunctionSignatureAndBody >($function_type, attr-dict, $body) Placeholder. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, RegionKindInterface, Symbol Attributes: Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::core::GlobalLinkageKindAttr global linkage kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes abi.prologue (::vast::abi::PrologueOp) WIP Syntax: operation ::= `abi.prologue` $body attr-dict `:` type($results) WIP Results: Result Description results any type abi.ret_direct (::vast::abi::RetDirectOp) Value is returned directly. Syntax: operation ::= `abi.ret_direct` $value attr-dict `:` type($value) `->` type($result) Value is returned directly. Operands: Operand Description value any type Results: Result Description result any type abi.todo (::vast::abi::TodoOp) Not implement yet. Syntax: operation ::= `abi.todo` $value attr-dict `:` type($value) `->` type($result) Not implemented yet Operands: Operand Description value any type Results: Result Description result any type abi.wrap_fn (::vast::abi::WrapFuncOp) _ Function that defines abi transformation of args. _ Syntax: operation ::= `abi.wrap_fn` $sym_name custom< FunctionSignatureAndBody >($function_type, attr-dict, $body) Placeholder. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, RegionKindInterface, Symbol Attributes: Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::core::GlobalLinkageKindAttr global linkage kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes abi.yield (::vast::abi::YieldOp) WIP Syntax: operation ::= `abi.yield` $values attr-dict `:` type($values) `->` type($result) WIP Traits: Terminator Operands: Operand Description values any type Results: Result Description result any type","title":"ABI"},{"location":"dialects/ABI/ABI/#abi-dialect","text":"A vast ABI dialect. Dialect provides operations to describe how arguments and return values are transformed to better model target abi. 'abi' Dialect Operation definition abi.call (::vast::abi::CallOp) Attributes: Operands: Results: abi.call_args (::vast::abi::CallArgsOp) Results: abi.call_exec (::vast::abi::CallExecutionOp) Attributes: Operands: Results: abi.call_rets (::vast::abi::CallRetsOp) Results: abi.direct (::vast::abi::DirectOp) Operands: Results: abi.epilogue (::vast::abi::EpilogueOp) Results: abi.func (::vast::abi::FuncOp) Attributes: abi.prologue (::vast::abi::PrologueOp) Results: abi.ret_direct (::vast::abi::RetDirectOp) Operands: Results: abi.todo (::vast::abi::TodoOp) Operands: Results: abi.wrap_fn (::vast::abi::WrapFuncOp) Attributes: abi.yield (::vast::abi::YieldOp) Operands: Results:","title":"'abi' Dialect"},{"location":"dialects/ABI/ABI/#operation-definition","text":"","title":"Operation definition"},{"location":"dialects/ABI/ABI/#abicall-vastabicallop","text":"ABI call operation Syntax: operation ::= `abi.call` $callee `(` $args `)` attr-dict `:` functional-type( $args, $results ) ABI call operation Interfaces: CallOpInterface","title":"abi.call (::vast::abi::CallOp)"},{"location":"dialects/ABI/ABI/#attributes","text":"Attribute MLIR Type Description callee ::mlir::FlatSymbolRefAttr flat symbol reference attribute","title":"Attributes:"},{"location":"dialects/ABI/ABI/#operands","text":"Operand Description args any type","title":"Operands:"},{"location":"dialects/ABI/ABI/#results","text":"Result Description results any type","title":"Results:"},{"location":"dialects/ABI/ABI/#abicall_args-vastabicallargsop","text":"Not implement yet. Syntax: operation ::= `abi.call_args` $body attr-dict `:` type($results) WIP","title":"abi.call_args (::vast::abi::CallArgsOp)"},{"location":"dialects/ABI/ABI/#results_1","text":"Result Description results any type","title":"Results:"},{"location":"dialects/ABI/ABI/#abicall_exec-vastabicallexecutionop","text":"WIP Syntax: operation ::= `abi.call_exec` $callee `(` $args `)` $body attr-dict `:` functional-type($args, $result) WIP Interfaces: CallOpInterface","title":"abi.call_exec (::vast::abi::CallExecutionOp)"},{"location":"dialects/ABI/ABI/#attributes_1","text":"Attribute MLIR Type Description callee ::mlir::FlatSymbolRefAttr flat symbol reference attribute","title":"Attributes:"},{"location":"dialects/ABI/ABI/#operands_1","text":"Operand Description args any type","title":"Operands:"},{"location":"dialects/ABI/ABI/#results_2","text":"Result Description result any type","title":"Results:"},{"location":"dialects/ABI/ABI/#abicall_rets-vastabicallretsop","text":"Not implement yet. Syntax: operation ::= `abi.call_rets` $body attr-dict `:` type($results) WIP","title":"abi.call_rets (::vast::abi::CallRetsOp)"},{"location":"dialects/ABI/ABI/#results_3","text":"Result Description results any type","title":"Results:"},{"location":"dialects/ABI/ABI/#abidirect-vastabidirectop","text":"Pass value directly - usually means by register Syntax: operation ::= `abi.direct` $value attr-dict `:` type($value) `->` type($result) Pass value directly - usually means by register.","title":"abi.direct (::vast::abi::DirectOp)"},{"location":"dialects/ABI/ABI/#operands_2","text":"Operand Description value any type","title":"Operands:"},{"location":"dialects/ABI/ABI/#results_4","text":"Result Description result any type","title":"Results:"},{"location":"dialects/ABI/ABI/#abiepilogue-vastabiepilogueop","text":"WIP Syntax: operation ::= `abi.epilogue` $body attr-dict `:` type($results) WIP","title":"abi.epilogue (::vast::abi::EpilogueOp)"},{"location":"dialects/ABI/ABI/#results_5","text":"Result Description results any type","title":"Results:"},{"location":"dialects/ABI/ABI/#abifunc-vastabifuncop","text":"_ Function with transformed type. _ Syntax: operation ::= `abi.func` $sym_name custom< FunctionSignatureAndBody >($function_type, attr-dict, $body) Placeholder. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, RegionKindInterface, Symbol","title":"abi.func (::vast::abi::FuncOp)"},{"location":"dialects/ABI/ABI/#attributes_2","text":"Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::core::GlobalLinkageKindAttr global linkage kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes","title":"Attributes:"},{"location":"dialects/ABI/ABI/#abiprologue-vastabiprologueop","text":"WIP Syntax: operation ::= `abi.prologue` $body attr-dict `:` type($results) WIP","title":"abi.prologue (::vast::abi::PrologueOp)"},{"location":"dialects/ABI/ABI/#results_6","text":"Result Description results any type","title":"Results:"},{"location":"dialects/ABI/ABI/#abiret_direct-vastabiretdirectop","text":"Value is returned directly. Syntax: operation ::= `abi.ret_direct` $value attr-dict `:` type($value) `->` type($result) Value is returned directly.","title":"abi.ret_direct (::vast::abi::RetDirectOp)"},{"location":"dialects/ABI/ABI/#operands_3","text":"Operand Description value any type","title":"Operands:"},{"location":"dialects/ABI/ABI/#results_7","text":"Result Description result any type","title":"Results:"},{"location":"dialects/ABI/ABI/#abitodo-vastabitodoop","text":"Not implement yet. Syntax: operation ::= `abi.todo` $value attr-dict `:` type($value) `->` type($result) Not implemented yet","title":"abi.todo (::vast::abi::TodoOp)"},{"location":"dialects/ABI/ABI/#operands_4","text":"Operand Description value any type","title":"Operands:"},{"location":"dialects/ABI/ABI/#results_8","text":"Result Description result any type","title":"Results:"},{"location":"dialects/ABI/ABI/#abiwrap_fn-vastabiwrapfuncop","text":"_ Function that defines abi transformation of args. _ Syntax: operation ::= `abi.wrap_fn` $sym_name custom< FunctionSignatureAndBody >($function_type, attr-dict, $body) Placeholder. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, RegionKindInterface, Symbol","title":"abi.wrap_fn (::vast::abi::WrapFuncOp)"},{"location":"dialects/ABI/ABI/#attributes_3","text":"Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::core::GlobalLinkageKindAttr global linkage kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes","title":"Attributes:"},{"location":"dialects/ABI/ABI/#abiyield-vastabiyieldop","text":"WIP Syntax: operation ::= `abi.yield` $values attr-dict `:` type($values) `->` type($result) WIP Traits: Terminator","title":"abi.yield (::vast::abi::YieldOp)"},{"location":"dialects/ABI/ABI/#operands_5","text":"Operand Description values any type","title":"Operands:"},{"location":"dialects/ABI/ABI/#results_9","text":"Result Description result any type","title":"Results:"},{"location":"dialects/Core/Core/","text":"'core' Dialect Utility dialect to provide common features for other dialects. Dialect providing features that may be used by other dialects. These features can be used by including \"vast/Dialect/Core/Utils.td\" It also provides lazy.op for lazy evaluation of expressions and binary logical operations that make use of it. 'core' Dialect Operation definition core.bin.land (::vast::core::BinLAndOp) Operands: Results: core.bin.lor (::vast::core::BinLOrOp) Operands: Results: core.implicit.return (::vast::core::ImplicitReturnOp) Operands: core.lazy.op (::vast::core::LazyOp) Results: core.scope (::vast::core::ScopeOp) core.select (::vast::core::SelectOp) Operands: Results: Attribute definition BooleanAttr Parameters: FloatAttr Parameters: IntegerAttr Parameters: SourceLanguageAttr Parameters: StringLiteralAttr Parameters: VoidAttr Parameters: Type definition FunctionType Parameters: Operation definition core.bin.land (::vast::core::BinLAndOp) VAST core dialect logical binary operation Syntax: operation ::= `core.bin.land` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) Core dialect logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type Operands: Operand Description lhs any type rhs any type Results: Result Description result any type core.bin.lor (::vast::core::BinLOrOp) VAST core dialect logical binary operation Syntax: operation ::= `core.bin.lor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) Core dialect logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type Operands: Operand Description lhs any type rhs any type Results: Result Description result any type core.implicit.return (::vast::core::ImplicitReturnOp) VAST implicit return Syntax: operation ::= `core.implicit.return` $result `:` type($result) attr-dict Op representing return that wasn't explicitely written in the source (e.g. in void fun(){}). Traits: return_trait, soft_terminator Operands: Operand Description result any type core.lazy.op (::vast::core::LazyOp) Lazily evaluate a region. Syntax: operation ::= `core.lazy.op` $lazy attr-dict `:` type(results) The operation serves to encapsulate delayed evaluation in its region. Traits: NoTerminator Results: Result Description result any type core.scope (::vast::core::ScopeOp) VAST scope declaration Syntax: operation ::= `core.scope` $body attr-dict Scope operation servers to represent explicitly high-level code scope. Other control flow operations represent scopes implicitly. It is a single-region operation. Traits: NoTerminator Interfaces: RegionKindInterface core.select (::vast::core::SelectOp) Select a value based on condition. Syntax: operation ::= `core.select` $cond `,` $thenRegion `,` $elseRegion attr-dict `:` functional-type(operands, results) Usual select operation. First operand is selected if predicate is true, second otherwise (to mirror how ternary works in C). %result = %cond %lhs, %rhs : type Operands: Operand Description cond any type thenRegion any type elseRegion any type Results: Result Description results any type Attribute definition BooleanAttr An Attribute containing a boolean value Syntax: #core.bool< ::mlir::Type, # type bool # value > An boolean attribute is a literal attribute that represents a boolean value. Parameters: Parameter C++ type Description type ::mlir::Type value bool FloatAttr An Attribute containing a floating point value Syntax: #core.float< ::mlir::Type, # type ::llvm::APFloat # value > A float attribute is a literal attribute that represents a floating point value of the specified floating point type. Parameters: Parameter C++ type Description type ::mlir::Type value ::llvm::APFloat IntegerAttr An Attribute containing a integer value Syntax: #core.integer< ::mlir::Type, # type ::llvm::APSInt # value > An integer attribute is a literal attribute that represents an integral value of the specified integer type. Parameters: Parameter C++ type Description type ::mlir::Type value ::llvm::APSInt SourceLanguageAttr Module source language Syntax: #core.lang< ::vast::core::SourceLanguage # value > Represents the source language used to generate the module. Example: // Module compiled from C. module attributes {vast.core.lang = vast.core.lang<c>} {} // Module compiled from C++. module attributes {vast.core.lang = vast.core.lang<cxx>} {} Parameters: Parameter C++ type Description value ::vast::core::SourceLanguage an enum of type SourceLanguage StringLiteralAttr An Attribute containing an escaped string Syntax: string-attribute ::= string-literal (`:` type)? A string literal attribute is an attribute that represents an escaped string literal value. Examples: \"An important string\" \"string with a type\" : !dialect.string Parameters: Parameter C++ type Description value ::llvm::StringRef type ::mlir::Type VoidAttr Attribute to represent void value. Syntax: #core.void< ::mlir::Type # type > The VoidAttr is used to return void from statements uniformly. Parameters: Parameter C++ type Description type ::mlir::Type Type definition FunctionType Vast function type Syntax: !core.fn< ::llvm::ArrayRef<Type>, # inputs ::llvm::ArrayRef<Type>, # results bool # varArg > The !core.fn is a function type. It consists of a variadic return type, and list of parameter types and can optionally be variadic. Example: !core.fn<!hl.bool ()> !core.fn<!hl.int (!hl.char, !hl.char)> !core.fn<!i32 (!i32, ...)> Parameters: Parameter C++ type Description inputs ::llvm::ArrayRef<Type> results ::llvm::ArrayRef<Type> varArg bool","title":"Core"},{"location":"dialects/Core/Core/#core-dialect","text":"Utility dialect to provide common features for other dialects. Dialect providing features that may be used by other dialects. These features can be used by including \"vast/Dialect/Core/Utils.td\" It also provides lazy.op for lazy evaluation of expressions and binary logical operations that make use of it. 'core' Dialect Operation definition core.bin.land (::vast::core::BinLAndOp) Operands: Results: core.bin.lor (::vast::core::BinLOrOp) Operands: Results: core.implicit.return (::vast::core::ImplicitReturnOp) Operands: core.lazy.op (::vast::core::LazyOp) Results: core.scope (::vast::core::ScopeOp) core.select (::vast::core::SelectOp) Operands: Results: Attribute definition BooleanAttr Parameters: FloatAttr Parameters: IntegerAttr Parameters: SourceLanguageAttr Parameters: StringLiteralAttr Parameters: VoidAttr Parameters: Type definition FunctionType Parameters:","title":"'core' Dialect"},{"location":"dialects/Core/Core/#operation-definition","text":"","title":"Operation definition"},{"location":"dialects/Core/Core/#corebinland-vastcorebinlandop","text":"VAST core dialect logical binary operation Syntax: operation ::= `core.bin.land` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) Core dialect logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type","title":"core.bin.land (::vast::core::BinLAndOp)"},{"location":"dialects/Core/Core/#operands","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/Core/Core/#results","text":"Result Description result any type","title":"Results:"},{"location":"dialects/Core/Core/#corebinlor-vastcorebinlorop","text":"VAST core dialect logical binary operation Syntax: operation ::= `core.bin.lor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) Core dialect logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type","title":"core.bin.lor (::vast::core::BinLOrOp)"},{"location":"dialects/Core/Core/#operands_1","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/Core/Core/#results_1","text":"Result Description result any type","title":"Results:"},{"location":"dialects/Core/Core/#coreimplicitreturn-vastcoreimplicitreturnop","text":"VAST implicit return Syntax: operation ::= `core.implicit.return` $result `:` type($result) attr-dict Op representing return that wasn't explicitely written in the source (e.g. in void fun(){}). Traits: return_trait, soft_terminator","title":"core.implicit.return (::vast::core::ImplicitReturnOp)"},{"location":"dialects/Core/Core/#operands_2","text":"Operand Description result any type","title":"Operands:"},{"location":"dialects/Core/Core/#corelazyop-vastcorelazyop","text":"Lazily evaluate a region. Syntax: operation ::= `core.lazy.op` $lazy attr-dict `:` type(results) The operation serves to encapsulate delayed evaluation in its region. Traits: NoTerminator","title":"core.lazy.op (::vast::core::LazyOp)"},{"location":"dialects/Core/Core/#results_2","text":"Result Description result any type","title":"Results:"},{"location":"dialects/Core/Core/#corescope-vastcorescopeop","text":"VAST scope declaration Syntax: operation ::= `core.scope` $body attr-dict Scope operation servers to represent explicitly high-level code scope. Other control flow operations represent scopes implicitly. It is a single-region operation. Traits: NoTerminator Interfaces: RegionKindInterface","title":"core.scope (::vast::core::ScopeOp)"},{"location":"dialects/Core/Core/#coreselect-vastcoreselectop","text":"Select a value based on condition. Syntax: operation ::= `core.select` $cond `,` $thenRegion `,` $elseRegion attr-dict `:` functional-type(operands, results) Usual select operation. First operand is selected if predicate is true, second otherwise (to mirror how ternary works in C). %result = %cond %lhs, %rhs : type","title":"core.select (::vast::core::SelectOp)"},{"location":"dialects/Core/Core/#operands_3","text":"Operand Description cond any type thenRegion any type elseRegion any type","title":"Operands:"},{"location":"dialects/Core/Core/#results_3","text":"Result Description results any type","title":"Results:"},{"location":"dialects/Core/Core/#attribute-definition","text":"","title":"Attribute definition"},{"location":"dialects/Core/Core/#booleanattr","text":"An Attribute containing a boolean value Syntax: #core.bool< ::mlir::Type, # type bool # value > An boolean attribute is a literal attribute that represents a boolean value.","title":"BooleanAttr"},{"location":"dialects/Core/Core/#parameters","text":"Parameter C++ type Description type ::mlir::Type value bool","title":"Parameters:"},{"location":"dialects/Core/Core/#floatattr","text":"An Attribute containing a floating point value Syntax: #core.float< ::mlir::Type, # type ::llvm::APFloat # value > A float attribute is a literal attribute that represents a floating point value of the specified floating point type.","title":"FloatAttr"},{"location":"dialects/Core/Core/#parameters_1","text":"Parameter C++ type Description type ::mlir::Type value ::llvm::APFloat","title":"Parameters:"},{"location":"dialects/Core/Core/#integerattr","text":"An Attribute containing a integer value Syntax: #core.integer< ::mlir::Type, # type ::llvm::APSInt # value > An integer attribute is a literal attribute that represents an integral value of the specified integer type.","title":"IntegerAttr"},{"location":"dialects/Core/Core/#parameters_2","text":"Parameter C++ type Description type ::mlir::Type value ::llvm::APSInt","title":"Parameters:"},{"location":"dialects/Core/Core/#sourcelanguageattr","text":"Module source language Syntax: #core.lang< ::vast::core::SourceLanguage # value > Represents the source language used to generate the module. Example: // Module compiled from C. module attributes {vast.core.lang = vast.core.lang<c>} {} // Module compiled from C++. module attributes {vast.core.lang = vast.core.lang<cxx>} {}","title":"SourceLanguageAttr"},{"location":"dialects/Core/Core/#parameters_3","text":"Parameter C++ type Description value ::vast::core::SourceLanguage an enum of type SourceLanguage","title":"Parameters:"},{"location":"dialects/Core/Core/#stringliteralattr","text":"An Attribute containing an escaped string Syntax: string-attribute ::= string-literal (`:` type)? A string literal attribute is an attribute that represents an escaped string literal value. Examples: \"An important string\" \"string with a type\" : !dialect.string","title":"StringLiteralAttr"},{"location":"dialects/Core/Core/#parameters_4","text":"Parameter C++ type Description value ::llvm::StringRef type ::mlir::Type","title":"Parameters:"},{"location":"dialects/Core/Core/#voidattr","text":"Attribute to represent void value. Syntax: #core.void< ::mlir::Type # type > The VoidAttr is used to return void from statements uniformly.","title":"VoidAttr"},{"location":"dialects/Core/Core/#parameters_5","text":"Parameter C++ type Description type ::mlir::Type","title":"Parameters:"},{"location":"dialects/Core/Core/#type-definition","text":"","title":"Type definition"},{"location":"dialects/Core/Core/#functiontype","text":"Vast function type Syntax: !core.fn< ::llvm::ArrayRef<Type>, # inputs ::llvm::ArrayRef<Type>, # results bool # varArg > The !core.fn is a function type. It consists of a variadic return type, and list of parameter types and can optionally be variadic. Example: !core.fn<!hl.bool ()> !core.fn<!hl.int (!hl.char, !hl.char)> !core.fn<!i32 (!i32, ...)>","title":"FunctionType"},{"location":"dialects/Core/Core/#parameters_6","text":"Parameter C++ type Description inputs ::llvm::ArrayRef<Type> results ::llvm::ArrayRef<Type> varArg bool","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/","text":"'hl' Dialect A high-level verbose program analysis MLIR dialect. This dialect intends capture highevel constructs of C/C++ for further program analysis. 'hl' Dialect Operation definition hl.access (::vast::hl::AccessSpecifierOp) Attributes: hl.add (::vast::hl::AddIOp) Operands: Results: hl.addressof (::vast::hl::AddressOf) Operands: Results: hl.alignof.expr (::vast::hl::AlignOfExprOp) Results: hl.alignof.type (::vast::hl::AlignOfTypeOp) Attributes: Results: hl.assign (::vast::hl::AssignOp) Operands: Results: hl.assign.add (::vast::hl::AddIAssignOp) Operands: Results: hl.assign.bin.and (::vast::hl::BinAndAssignOp) Operands: Results: hl.assign.bin.ashr (::vast::hl::BinAShrAssignOp) Operands: Results: hl.assign.bin.lshr (::vast::hl::BinLShrAssignOp) Operands: Results: hl.assign.bin.or (::vast::hl::BinOrAssignOp) Operands: Results: hl.assign.bin.shl (::vast::hl::BinShlAssignOp) Operands: Results: hl.assign.bin.xor (::vast::hl::BinXorAssignOp) Operands: Results: hl.assign.fadd (::vast::hl::AddFAssignOp) Operands: Results: hl.assign.fdiv (::vast::hl::DivFAssignOp) Operands: Results: hl.assign.fmul (::vast::hl::MulFAssignOp) Operands: Results: hl.assign.frem (::vast::hl::RemFAssignOp) Operands: Results: hl.assign.fsub (::vast::hl::SubFAssignOp) Operands: Results: hl.assign.mul (::vast::hl::MulIAssignOp) Operands: Results: hl.assign.sdiv (::vast::hl::DivSAssignOp) Operands: Results: hl.assign.srem (::vast::hl::RemSAssignOp) Operands: Results: hl.assign.sub (::vast::hl::SubIAssignOp) Operands: Results: hl.assign.udiv (::vast::hl::DivUAssignOp) Operands: Results: hl.assign.urem (::vast::hl::RemUAssignOp) Operands: Results: hl.base (::vast::hl::CxxBaseSpecifierOp) Attributes: hl.bin.and (::vast::hl::BinAndOp) Operands: Results: hl.bin.ashr (::vast::hl::BinAShrOp) Operands: Results: hl.bin.comma (::vast::hl::BinComma) Operands: Results: hl.bin.land (::vast::hl::BinLAndOp) Results: hl.bin.lor (::vast::hl::BinLOrOp) Results: hl.bin.lshr (::vast::hl::BinLShrOp) Operands: Results: hl.bin.or (::vast::hl::BinOrOp) Operands: Results: hl.bin.shl (::vast::hl::BinShlOp) Operands: Results: hl.bin.xor (::vast::hl::BinXorOp) Operands: Results: hl.break (::vast::hl::BreakOp) hl.builtin_bitcast (::vast::hl::BuiltinBitCastOp) Attributes: Operands: Results: hl.call (::vast::hl::CallOp) Attributes: Operands: Results: hl.case (::vast::hl::CaseOp) hl.class (::vast::hl::ClassDeclOp) Attributes: hl.cmp (::vast::hl::CmpOp) Attributes: Operands: Results: hl.cond (::vast::hl::CondOp) Results: hl.cond.yield (::vast::hl::CondYieldOp) Operands: hl.const (::vast::hl::ConstantOp) Attributes: Results: hl.continue (::vast::hl::ContinueOp) hl.cstyle_cast (::vast::hl::CStyleCastOp) Attributes: Operands: Results: hl.cxxstruct (::vast::hl::CxxStructDeclOp) Attributes: hl.default (::vast::hl::DefaultOp) hl.deref (::vast::hl::Deref) Operands: Results: hl.do (::vast::hl::DoOp) hl.empty.decl (::vast::hl::EmptyDeclOp) hl.enum (::vast::hl::EnumDeclOp) Attributes: hl.enum.const (::vast::hl::EnumConstantOp) Attributes: hl.enumref (::vast::hl::EnumRefOp) Attributes: Results: hl.expr (::vast::hl::ExprOp) Results: hl.fadd (::vast::hl::AddFOp) Operands: Results: hl.fcmp (::vast::hl::FCmpOp) Attributes: Operands: Results: hl.fdiv (::vast::hl::DivFOp) Operands: Results: hl.field (::vast::hl::FieldDeclOp) Attributes: hl.fmul (::vast::hl::MulFOp) Operands: Results: hl.for (::vast::hl::ForOp) hl.frem (::vast::hl::RemFOp) Operands: Results: hl.fsub (::vast::hl::SubFOp) Operands: Results: hl.func (::vast::hl::FuncOp) Attributes: hl.funcref (::vast::hl::FuncRefOp) Attributes: Results: hl.globref (::vast::hl::GlobalRefOp) Attributes: Results: hl.gnu.extension (::vast::hl::ExtensionOp) Operands: Results: hl.goto (::vast::hl::GotoStmt) Operands: hl.if (::vast::hl::IfOp) hl.implicit_cast (::vast::hl::ImplicitCastOp) Attributes: Operands: Results: hl.indirect_call (::vast::hl::IndirectCallOp) Operands: Results: hl.initlist (::vast::hl::InitListExpr) Operands: Results: hl.label (::vast::hl::LabelStmt) Operands: hl.label.decl (::vast::hl::LabelDeclOp) Attributes: Results: hl.labeladdr (::vast::hl::AddrLabelExpr) Operands: Results: hl.lnot (::vast::hl::LNotOp) Operands: Results: hl.member (::vast::hl::RecordMemberOp) Attributes: Operands: Results: hl.minus (::vast::hl::MinusOp) Operands: Results: hl.mul (::vast::hl::MulIOp) Operands: Results: hl.not (::vast::hl::NotOp) Operands: Results: hl.plus (::vast::hl::PlusOp) Operands: Results: hl.post.dec (::vast::hl::PostDecOp) Operands: Results: hl.post.inc (::vast::hl::PostIncOp) Operands: Results: hl.pre.dec (::vast::hl::PreDecOp) Operands: Results: hl.pre.inc (::vast::hl::PreIncOp) Operands: Results: hl.predefined.expr (::vast::hl::PredefinedExpr) Attributes: Operands: Results: hl.ref (::vast::hl::DeclRefOp) Operands: Results: hl.return (::vast::hl::ReturnOp) Operands: hl.sdiv (::vast::hl::DivSOp) Operands: Results: hl.sizeof.expr (::vast::hl::SizeOfExprOp) Results: hl.sizeof.type (::vast::hl::SizeOfTypeOp) Attributes: Results: hl.skip (::vast::hl::SkipStmt) hl.srem (::vast::hl::RemSOp) Operands: Results: hl.stmt.expr (::vast::hl::StmtExprOp) Results: hl.struct (::vast::hl::StructDeclOp) Attributes: hl.sub (::vast::hl::SubIOp) Operands: Results: hl.subscript (::vast::hl::SubscriptOp) Operands: Results: hl.switch (::vast::hl::SwitchOp) hl.this (::vast::hl::ThisOp) Results: hl.translation_unit (::vast::hl::TranslationUnitOp) hl.type (::vast::hl::TypeDeclOp) Attributes: hl.type.yield (::vast::hl::TypeYieldOp) Operands: hl.typedef (::vast::hl::TypeDefOp) Attributes: hl.typeof.expr (::vast::hl::TypeOfExprOp) Attributes: hl.typeof.type (::vast::hl::TypeOfTypeOp) Attributes: hl.udiv (::vast::hl::DivUOp) Operands: Results: hl.union (::vast::hl::UnionDeclOp) Attributes: hl.unreachable (::vast::hl::UnreachableOp) hl.urem (::vast::hl::RemUOp) Operands: Results: hl.value.yield (::vast::hl::ValueYieldOp) Operands: hl.var (::vast::hl::VarDeclOp) Attributes: Results: hl.while (::vast::hl::WhileOp) Attribute definition AllocAlignAttr Parameters: AllocSizeAttr Parameters: AnnotationAttr Parameters: AsmLabelAttr Parameters: BuiltinAttr Parameters: CVQualifiersAttr Parameters: CVRQualifiersAttr Parameters: ConstAttr FormatAttr Parameters: LoaderUninitializedAttr ModeAttr Parameters: NoInstrumentFunctionAttr NoThrowAttr NonNullAttr PackedAttr PureAttr RestrictAttr SectionAttr Parameters: UCVQualifiersAttr Parameters: WarnUnusedResultAttr Type definition AdjustedType Parameters: ArrayType Parameters: AttributedType Parameters: BFloat16Type Parameters: BoolType Parameters: CharType Parameters: DecayedType Parameters: DoubleType Parameters: ElaboratedType Parameters: EnumType Parameters: Float128Type Parameters: FloatType Parameters: HalfType Parameters: Int128Type Parameters: IntType Parameters: LValueType Parameters: LabelType LongDoubleType Parameters: LongLongType Parameters: LongType Parameters: ParenType Parameters: PointerType Parameters: RValueType Parameters: RecordType Parameters: ReferenceType Parameters: ShortType Parameters: TypeOfExprType Parameters: TypeOfTypeType Parameters: TypedefType Parameters: VoidType Parameters: Operation definition hl.access (::vast::hl::AccessSpecifierOp) VAST C++ access specifier declaration Syntax: operation ::= `hl.access` attr-dict $spec VAST C++ access specifier declaration Attributes: Attribute MLIR Type Description spec ::vast::hl::AccessSpecifierAttr Access specifier hl.add (::vast::hl::AddIOp) VAST arithmetic binary operation Syntax: operation ::= `hl.add` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Traits: Commutative Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.addressof (::vast::hl::AddressOf) VAST addressof operation Syntax: operation ::= `hl.addressof` $value attr-dict `:` type($value) `->` type($result) VAST addressof operation Operands: Operand Description value lvalue to any type Results: Result Description result any type hl.alignof.expr (::vast::hl::AlignOfExprOp) VAST expr alignof operator Syntax: operation ::= `hl.alignof.expr` attr-dict `->` type($result) $expr VAST expr alignof operator Results: Result Description result integer like type hl.alignof.type (::vast::hl::AlignOfTypeOp) VAST type alignof operator Syntax: operation ::= `hl.alignof.type` $arg attr-dict `->` type($result) VAST type alignof operator Attributes: Attribute MLIR Type Description arg ::mlir::TypeAttr any type attribute Results: Result Description result integer like type hl.assign (::vast::hl::AssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.add (::vast::hl::AddIAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.add` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.bin.and (::vast::hl::BinAndAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.bin.and` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.bin.ashr (::vast::hl::BinAShrAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.bin.ashr` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to integer like type dst any type Results: Result Description result integer like type hl.assign.bin.lshr (::vast::hl::BinLShrAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.bin.lshr` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to integer like type dst any type Results: Result Description result integer like type hl.assign.bin.or (::vast::hl::BinOrAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.bin.or` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.bin.shl (::vast::hl::BinShlAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.bin.shl` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to integer like type dst any type Results: Result Description result integer like type hl.assign.bin.xor (::vast::hl::BinXorAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.bin.xor` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.fadd (::vast::hl::AddFAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.fadd` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.fdiv (::vast::hl::DivFAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.fdiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.fmul (::vast::hl::MulFAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.fmul` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.frem (::vast::hl::RemFAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.frem` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.fsub (::vast::hl::SubFAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.fsub` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.mul (::vast::hl::MulIAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.mul` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.sdiv (::vast::hl::DivSAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.sdiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.srem (::vast::hl::RemSAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.srem` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.sub (::vast::hl::SubIAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.sub` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.udiv (::vast::hl::DivUAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.udiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.assign.urem (::vast::hl::RemUAssignOp) VAST compound assign operation Syntax: operation ::= `hl.assign.urem` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface Operands: Operand Description src lvalue to any type dst any type Results: Result Description result any type hl.base (::vast::hl::CxxBaseSpecifierOp) VAST base class specifier Syntax: operation ::= `hl.base` $type attr-dict $access (`virtual` $is_virtual^)? VAST base class specifier Interfaces: VastSymbol Attributes: Attribute MLIR Type Description type ::mlir::TypeAttr any type attribute access ::vast::hl::AccessSpecifierAttr Access specifier is_virtual ::mlir::UnitAttr unit attribute hl.bin.and (::vast::hl::BinAndOp) VAST arithmetic binary operation Syntax: operation ::= `hl.bin.and` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.bin.ashr (::vast::hl::BinAShrOp) VAST binary shift operation Syntax: operation ::= `hl.bin.ashr` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level binary shift operation. This operation takes two operands and returns one result. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs integer like type rhs integer like type Results: Result Description result integer like type hl.bin.comma (::vast::hl::BinComma) VAST binary operation Syntax: operation ::= `hl.bin.comma` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.bin.land (::vast::hl::BinLAndOp) VAST logical binary operation Syntax: operation ::= `hl.bin.land` $lhs`,` $rhs attr-dict `:` type(results) High-level logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type Results: Result Description result any type hl.bin.lor (::vast::hl::BinLOrOp) VAST logical binary operation Syntax: operation ::= `hl.bin.lor` $lhs`,` $rhs attr-dict `:` type(results) High-level logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type Results: Result Description result any type hl.bin.lshr (::vast::hl::BinLShrOp) VAST binary shift operation Syntax: operation ::= `hl.bin.lshr` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level binary shift operation. This operation takes two operands and returns one result. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs integer like type rhs integer like type Results: Result Description result integer like type hl.bin.or (::vast::hl::BinOrOp) VAST arithmetic binary operation Syntax: operation ::= `hl.bin.or` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.bin.shl (::vast::hl::BinShlOp) VAST binary shift operation Syntax: operation ::= `hl.bin.shl` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level binary shift operation. This operation takes two operands and returns one result. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs integer like type rhs integer like type Results: Result Description result integer like type hl.bin.xor (::vast::hl::BinXorOp) VAST arithmetic binary operation Syntax: operation ::= `hl.bin.xor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.break (::vast::hl::BreakOp) VAST break statement Syntax: operation ::= `hl.break` attr-dict VAST break statement Traits: NoRegionArguments, NoTerminator, soft_terminator Interfaces: RegionKindInterface hl.builtin_bitcast (::vast::hl::BuiltinBitCastOp) VAST cast operation Syntax: operation ::= `hl.builtin_bitcast` $value $kind attr-dict `:` type($value) `->` type($result) VAST cast operation Attributes: Attribute MLIR Type Description kind ::vast::hl::CastKindAttr cast kind Operands: Operand Description value any type Results: Result Description result any type hl.call (::vast::hl::CallOp) VAST call operation Syntax: operation ::= `hl.call` $callee `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results ) VAST call operation Interfaces: CallOpInterface Attributes: Attribute MLIR Type Description callee ::mlir::FlatSymbolRefAttr flat symbol reference attribute Operands: Operand Description argOperands any type Results: Result Description results any type hl.case (::vast::hl::CaseOp) VAST case statement Syntax: operation ::= `hl.case` $lhs $body attr-dict The operation represents a single case of a switch statement. The generic form of the operation is as follows: hl.case { ... / lhs/check region / hl.value.yield %val : !hl.type } { ... / body region / } It represents a C statement of form case lhs: body; . Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface hl.class (::vast::hl::ClassDeclOp) VAST C++ class declaration Syntax: operation ::= `hl.class` $name attr-dict `:` `bases` $bases $fields VAST C++ class declaration Traits: NoTerminator Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute hl.cmp (::vast::hl::CmpOp) VAST comparison operation Syntax: operation ::= `hl.cmp` $predicate $lhs `,` $rhs attr-dict `:` type(operands) `->` type($result) VAST comparison operation Attributes: Attribute MLIR Type Description predicate ::vast::hl::PredicateAttr comparison predicate Operands: Operand Description lhs any type rhs any type Results: Result Description result bool or integer like type hl.cond (::vast::hl::CondOp) VAST conditional statement Syntax: operation ::= `hl.cond` $condRegion `?` $thenRegion `:` $elseRegion attr-dict `:` type(results) The operation takes builders of three regions -- condition, true branch and false branch. Builders, given the location, build a particular region. The generic form of the operation is as follows: hl.cond { ... / condition region / hl.cond.yield %cond : !hl.bool } ? { ... / true region / } : { ... / false region / } Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface Results: Result Description result any type hl.cond.yield (::vast::hl::CondYieldOp) Condition yield operation Syntax: operation ::= `hl.cond.yield` attr-dict $result `:` type($result) A condition yield operation is used to terminate the region representing condition expression of control flow operations IfOp , WhileOp , ForOp and DoOp . It yields a boolean value for the conditional branch. The custom assembly form of the operation is as follows: hl.cond.yield result : BoolType Traits: HasParent , Terminator Operands: Operand Description result any type hl.const (::vast::hl::ConstantOp) VAST value constant Syntax: operation ::= `hl.const` $value attr-dict VAST value constant Traits: ConstantLike Interfaces: InferTypeOpInterface Attributes: Attribute MLIR Type Description value ::mlir::TypedAttr TypedAttr instance Results: Result Description result any type hl.continue (::vast::hl::ContinueOp) VAST continue statement Syntax: operation ::= `hl.continue` attr-dict VAST continue statement Traits: NoRegionArguments, NoTerminator, soft_terminator Interfaces: RegionKindInterface hl.cstyle_cast (::vast::hl::CStyleCastOp) VAST cast operation Syntax: operation ::= `hl.cstyle_cast` $value $kind attr-dict `:` type($value) `->` type($result) VAST cast operation Attributes: Attribute MLIR Type Description kind ::vast::hl::CastKindAttr cast kind Operands: Operand Description value any type Results: Result Description result any type hl.cxxstruct (::vast::hl::CxxStructDeclOp) VAST C++ struct declaration Syntax: operation ::= `hl.cxxstruct` $name attr-dict `:` `bases` $bases $fields VAST C++ struct declaration Traits: NoTerminator Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute hl.default (::vast::hl::DefaultOp) VAST default statement Syntax: operation ::= `hl.default` $body attr-dict VAST default statement Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface hl.deref (::vast::hl::Deref) VAST deref operation Syntax: operation ::= `hl.deref` $addr attr-dict `:` type($addr) `->` type($result) VAST deref operation Operands: Operand Description addr any type Results: Result Description result lvalue to any type hl.do (::vast::hl::DoOp) VAST do-while statement Syntax: operation ::= `hl.do` $bodyRegion `while` $condRegion attr-dict The operation represents a do-while statement. The generic form of the operation is as follows: hl.do { ... / body region / } cond { ... / cond region / hl.cond.yield %cond : !hl.bool } Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface hl.empty.decl (::vast::hl::EmptyDeclOp) Syntax: operation ::= `hl.empty.decl` attr-dict hl.enum (::vast::hl::EnumDeclOp) VAST enum declaration Syntax: operation ::= `hl.enum` $name attr-dict `:` ($type^ $constants)? Enum declaration serves to declare region for enum constant declarations. It also defines an underlying type. Traits: NoTerminator Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute hl.enum.const (::vast::hl::EnumConstantOp) VAST enum constant declaration Syntax: operation ::= `hl.enum.const` $name `=` $value attr-dict (`init` $init^)? Enumeration constant servers to link name to an enum value. It is required to be scoped in Enum operation. For example: hl.enum.const \"F\" = 2 : !hl.int A constant can have a constant expression initializer: hl.enum.const \"G\" = #core.integer<12> : !hl.int init { %0 = hl.enumref \"F\" : !hl.int %1 = hl.enumref \"C\" : !hl.int %2 = hl.add %0, %1 : !hl.int hl.value.yield %2 : !hl.int } Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute value ::mlir::TypedAttr TypedAttr instance hl.enumref (::vast::hl::EnumRefOp) VAST variable reference declaration Syntax: operation ::= `hl.enumref` $value attr-dict `:` type($result) VAST variable reference declaration Attributes: Attribute MLIR Type Description value ::mlir::StringAttr string attribute Results: Result Description result any type hl.expr (::vast::hl::ExprOp) VAST expression Syntax: operation ::= `hl.expr` attr-dict `:` type($result) $subexpr VAST expression Traits: SingleBlock Results: Result Description result any type hl.fadd (::vast::hl::AddFOp) VAST arithmetic binary operation Syntax: operation ::= `hl.fadd` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.fcmp (::vast::hl::FCmpOp) VAST flaoting point comparison operation Syntax: operation ::= `hl.fcmp` $predicate $lhs `,` $rhs attr-dict `:` type(operands) `->` type($result) VAST floating point comparison operation Attributes: Attribute MLIR Type Description predicate ::vast::hl::FPredicateAttr floating point comparison predicate Operands: Operand Description lhs float like type rhs float like type Results: Result Description result bool or integer like type hl.fdiv (::vast::hl::DivFOp) VAST arithmetic binary operation Syntax: operation ::= `hl.fdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.field (::vast::hl::FieldDeclOp) VAST record field declaration Syntax: operation ::= `hl.field` $name attr-dict (`bw` $bits^)? `:` $type VAST record field declaration Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute bits ::mlir::IntegerAttr 32-bit signless integer attribute hl.fmul (::vast::hl::MulFOp) VAST arithmetic binary operation Syntax: operation ::= `hl.fmul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.for (::vast::hl::ForOp) VAST for statement Syntax: operation ::= `hl.for` $condRegion `incr` $incrRegion attr-dict `do` $bodyRegion Operation represents a for-loop statement. The generic form of the operation is as follows: hl.for { ... / cond region / hl.cond.yield %cond : !hl.bool } incr { ... / increment/update region / } do { ... / body region / } Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface hl.frem (::vast::hl::RemFOp) VAST arithmetic binary operation Syntax: operation ::= `hl.frem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.fsub (::vast::hl::SubFOp) VAST arithmetic binary operation Syntax: operation ::= `hl.fsub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.func (::vast::hl::FuncOp) VAST function template Syntax: operation ::= `hl.func` $sym_name custom< FunctionSignatureAndBody >($function_type, attr-dict, $body) Inspired by cir::FuncOp and mlir::func::FuncOp : Operations within the function cannot implicitly capture values defined outside of the function, i.e. Functions are IsolatedFromAbove . All external references must use function arguments or attributes that establish a symbolic connection (e.g. symbols referenced by name via a string attribute like SymbolRefAttr). An external function declaration (used when referring to a function declared in some other module) has no body. The function linkage information is specified by linkage , as defined by GlobalLinkageKind attribute. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, RegionKindInterface, Symbol Attributes: Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::core::GlobalLinkageKindAttr global linkage kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes hl.funcref (::vast::hl::FuncRefOp) VAST function reference declaration Syntax: operation ::= `hl.funcref` $function attr-dict `:` type($result) VAST function reference declaration Attributes: Attribute MLIR Type Description function ::mlir::FlatSymbolRefAttr flat symbol reference attribute Results: Result Description result any type hl.globref (::vast::hl::GlobalRefOp) VAST global variable reference declaration Syntax: operation ::= `hl.globref` $global attr-dict `:` type($result) VAST global variable reference declaration Attributes: Attribute MLIR Type Description global ::mlir::StringAttr string attribute Results: Result Description result any type hl.gnu.extension (::vast::hl::ExtensionOp) VAST extension (__extension__) keyword Syntax: operation ::= `hl.gnu.extension` $value attr-dict `:` type($value) `->` type($result) VAST op corresponding to GNU extension keyword. Operands: Operand Description value any type Results: Result Description result any type hl.goto (::vast::hl::GotoStmt) Syntax: operation ::= `hl.goto` $label attr-dict Operands: Operand Description label hl.if (::vast::hl::IfOp) VAST if statement The operation takes builders of two mandatory regions -- condition and then region -- and one builder optional region representing else block of C if statement. Builders, given the location, build a particular region. The generic form of the operation is as follows: hl.if { ... / condition region / hl.cond.yield %cond : !hl.bool } then { ... / then region / } else { ... / else region / } Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface hl.implicit_cast (::vast::hl::ImplicitCastOp) VAST cast operation Syntax: operation ::= `hl.implicit_cast` $value $kind attr-dict `:` type($value) `->` type($result) VAST cast operation Attributes: Attribute MLIR Type Description kind ::vast::hl::CastKindAttr cast kind Operands: Operand Description value any type Results: Result Description result any type hl.indirect_call (::vast::hl::IndirectCallOp) VAST call operation Syntax: operation ::= `hl.indirect_call` $callee `:` type($callee) `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results ) VAST call operation Interfaces: CallOpInterface Operands: Operand Description callee any type argOperands any type Results: Result Description results any type hl.initlist (::vast::hl::InitListExpr) VAST initializer list expression Syntax: operation ::= `hl.initlist` $elements attr-dict `:` functional-type($elements, results) VAST initializer list expression Operands: Operand Description elements any type Results: Result Description \u00abunnamed\u00bb any type hl.label (::vast::hl::LabelStmt) VAST control flow operation Syntax: operation ::= `hl.label` $label $body attr-dict VAST control flow operation Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface Operands: Operand Description label hl.label.decl (::vast::hl::LabelDeclOp) Syntax: operation ::= `hl.label.decl` $name attr-dict `:` type($result) Interfaces: InferTypeOpInterface Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute Results: Result Description result hl.labeladdr (::vast::hl::AddrLabelExpr) VAST address of label extension Syntax: operation ::= `hl.labeladdr` $label attr-dict `:` type($result) VAST address of label extension Operands: Operand Description label Results: Result Description result lvalue to pointer like type hl.lnot (::vast::hl::LNotOp) VAST unary logical operation Syntax: operation ::= `hl.lnot` $arg attr-dict `:` type($arg) `->` type($res) High-level unary logical operation assures that result has the right type. The custom assembly form of the operation is as follows: %result = %arg : type -> ret_type Operands: Operand Description arg any type Results: Result Description res bool or integer like type hl.member (::vast::hl::RecordMemberOp) VAST record element access operation Syntax: operation ::= `hl.member` $record `at` $name attr-dict `:` type($record) `->` type($element) VAST record element access operation Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute Operands: Operand Description record any type Results: Result Description element lvalue to any type hl.minus (::vast::hl::MinusOp) VAST unary type preserving operation Syntax: operation ::= `hl.minus` $arg attr-dict `:` type($result) Type preserving high-level unary operation assures that argument and result has the same type. The custom assembly form of the operation is as follows: %result = %arg : type Traits: SameOperandsAndResultType Interfaces: InferTypeOpInterface Operands: Operand Description arg any type Results: Result Description result any type hl.mul (::vast::hl::MulIOp) VAST arithmetic binary operation Syntax: operation ::= `hl.mul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Traits: Commutative Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.not (::vast::hl::NotOp) VAST unary type preserving operation Syntax: operation ::= `hl.not` $arg attr-dict `:` type($result) Type preserving high-level unary operation assures that argument and result has the same type. The custom assembly form of the operation is as follows: %result = %arg : type Traits: SameOperandsAndResultType Interfaces: InferTypeOpInterface Operands: Operand Description arg any type Results: Result Description result any type hl.plus (::vast::hl::PlusOp) VAST unary type preserving operation Syntax: operation ::= `hl.plus` $arg attr-dict `:` type($result) Type preserving high-level unary operation assures that argument and result has the same type. The custom assembly form of the operation is as follows: %result = %arg : type Traits: SameOperandsAndResultType Interfaces: InferTypeOpInterface Operands: Operand Description arg any type Results: Result Description result any type hl.post.dec (::vast::hl::PostDecOp) VAST unary inplace operation Syntax: operation ::= `hl.post.dec` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface Operands: Operand Description arg lvalue to any type Results: Result Description result any type hl.post.inc (::vast::hl::PostIncOp) VAST unary inplace operation Syntax: operation ::= `hl.post.inc` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface Operands: Operand Description arg lvalue to any type Results: Result Description result any type hl.pre.dec (::vast::hl::PreDecOp) VAST unary inplace operation Syntax: operation ::= `hl.pre.dec` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface Operands: Operand Description arg lvalue to any type Results: Result Description result any type hl.pre.inc (::vast::hl::PreIncOp) VAST unary inplace operation Syntax: operation ::= `hl.pre.inc` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface Operands: Operand Description arg lvalue to any type Results: Result Description result any type hl.predefined.expr (::vast::hl::PredefinedExpr) VAT predefined expr ( such as __func__ ) Syntax: operation ::= `hl.predefined.expr` $value $kind attr-dict `:` type($value) `->` type($result) VAT predefined expr ( such as func ) Attributes: Attribute MLIR Type Description kind ::vast::hl::IdentKindAttr ident kind Operands: Operand Description value any type Results: Result Description result any type hl.ref (::vast::hl::DeclRefOp) VAST variable reference declaration Syntax: operation ::= `hl.ref` $decl attr-dict `:` functional-type(operands, results) VAST variable reference declaration Operands: Operand Description decl any type Results: Result Description result lvalue to any type hl.return (::vast::hl::ReturnOp) Syntax: operation ::= `hl.return` ($result^ `:` type($result))? attr-dict Traits: return_trait, soft_terminator Operands: Operand Description result any type hl.sdiv (::vast::hl::DivSOp) VAST arithmetic binary operation Syntax: operation ::= `hl.sdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.sizeof.expr (::vast::hl::SizeOfExprOp) VAST expr sizeof operator Syntax: operation ::= `hl.sizeof.expr` attr-dict `->` type($result) $expr VAST expr sizeof operator Results: Result Description result integer like type hl.sizeof.type (::vast::hl::SizeOfTypeOp) VAST type sizeof operator Syntax: operation ::= `hl.sizeof.type` $arg attr-dict `->` type($result) VAST type sizeof operator Attributes: Attribute MLIR Type Description arg ::mlir::TypeAttr any type attribute Results: Result Description result integer like type hl.skip (::vast::hl::SkipStmt) VAST skip statement Syntax: operation ::= `hl.skip` attr-dict VAST skip statement hl.srem (::vast::hl::RemSOp) VAST arithmetic binary operation Syntax: operation ::= `hl.srem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.stmt.expr (::vast::hl::StmtExprOp) VAST statement expression Syntax: operation ::= `hl.stmt.expr` attr-dict `:` type($result) $substmt VAST statement expression Traits: SingleBlock Interfaces: RegionKindInterface Results: Result Description result any type hl.struct (::vast::hl::StructDeclOp) VAST struct declaration Syntax: operation ::= `hl.struct` $name attr-dict `:` $fields VAST struct declaration Traits: NoTerminator Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute hl.sub (::vast::hl::SubIOp) VAST arithmetic binary operation Syntax: operation ::= `hl.sub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.subscript (::vast::hl::SubscriptOp) VAST array subscript operator Syntax: operation ::= `hl.subscript` $array `at` ` ` `[` $index `:` type($index) `]` attr-dict `:` type($array) `->` type($result) VAST array subscript operator Operands: Operand Description array lvalue to subscriptable type index integer like type Results: Result Description result lvalue to any type hl.switch (::vast::hl::SwitchOp) VAST switch statement Syntax: operation ::= `hl.switch` $condRegion `cases` $cases attr-dict The operation represents a switch statement. The generic form of the operation is as follows: hl.switch { ... / cond region / hl.value.yield %val : !hl.type } cases { ... / casesregion / } Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface hl.this (::vast::hl::ThisOp) VAST this operator Syntax: operation ::= `hl.this` attr-dict `:` type($result) VAST this operator Results: Result Description result any type hl.translation_unit (::vast::hl::TranslationUnitOp) VAST translation unit Syntax: operation ::= `hl.translation_unit` $body attr-dict VAST tranaslation unit Traits: IsolatedFromAbove, NoTerminator, SymbolTable hl.type (::vast::hl::TypeDeclOp) VAST type declaration Syntax: operation ::= `hl.type` $name attr-dict VAST type declaration Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute hl.type.yield (::vast::hl::TypeYieldOp) Type yield operation Syntax: operation ::= `hl.type.yield` attr-dict $result `:` type($result) A type yield operation is used to terminate the underlying expression region of a typeof(expr) statement. The custom assembly form of the operation is as follows: hl.type.yield result : type Traits: Terminator Operands: Operand Description result any type hl.typedef (::vast::hl::TypeDefOp) VAST typedef operation Syntax: operation ::= `hl.typedef` $name attr-dict `:` $type Typedef operation servers to declare named types. It creates a new type symbol in the current scope to be referenced as NamedType later. Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute hl.typeof.expr (::vast::hl::TypeOfExprOp) VAST typeof(expr) operation Syntax: operation ::= `hl.typeof.expr` $name $expr `:` $type attr-dict The Typeof operation serves to declare a type using type introspection. It evaluates its underlying expression, creates a new type symbol in the current scope, assigns it to the type of the underlying expression, and returns the type symbol to be referenced later Traits: SingleBlock Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute hl.typeof.type (::vast::hl::TypeOfTypeOp) VAST typeof(type) operation Syntax: operation ::= `hl.typeof.type` attr-dict `:` $type Interfaces: VastSymbol Attributes: Attribute MLIR Type Description type ::mlir::TypeAttr any type attribute hl.udiv (::vast::hl::DivUOp) VAST arithmetic binary operation Syntax: operation ::= `hl.udiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.union (::vast::hl::UnionDeclOp) VAST record declaration Syntax: operation ::= `hl.union` $name attr-dict `:` $fields VAST record declaration Traits: NoTerminator Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute hl.unreachable (::vast::hl::UnreachableOp) VAST unreachable operation Syntax: operation ::= `hl.unreachable` attr-dict VAST unreachable operation Traits: Terminator hl.urem (::vast::hl::RemUOp) VAST arithmetic binary operation Syntax: operation ::= `hl.urem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Operands: Operand Description lhs any type rhs any type Results: Result Description result any type hl.value.yield (::vast::hl::ValueYieldOp) Value yield operation Syntax: operation ::= `hl.value.yield` attr-dict $result `:` type($result) A value yield operation is used to terminate the case region of a switch statement. The yielded value triggers the parent case statement region. The custom assembly form of the operation is as follows: hl.value.yield result : type Traits: Terminator Operands: Operand Description result any type hl.var (::vast::hl::VarDeclOp) VAST variable declaration Syntax: operation ::= `hl.var` $name attr-dict ($storageClass^)? ($threadStorageClass^)? `:` type($result) (`=` $initializer^)? (`allocation_size` $allocation_size^)? VAST variable declaration Interfaces: VastSymbol Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute storageClass ::vast::hl::StorageClassAttr storage class threadStorageClass ::vast::hl::TSClassAttr thread storage class Results: Result Description result any type hl.while (::vast::hl::WhileOp) VAST while statement Syntax: operation ::= `hl.while` $condRegion `do` $bodyRegion attr-dict The operation takes builders of two mandatory regions -- condition and body region. Builders, given the location, build a particular region. The generic form of the operation is as follows: hl.while { ... / condition region / hl.cond.yield %cond : !hl.bool } do { ... / body region / } Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface Attribute definition AllocAlignAttr Syntax: #hl.alloc_align< int # alignment > Parameters: Parameter C++ type Description alignment int AllocSizeAttr Syntax: #hl.alloc_size< int, # size_arg_pos int # num_arg_pos > Parameters: Parameter C++ type Description size_arg_pos int num_arg_pos int AnnotationAttr Syntax: #hl.annotation< ::mlir::StringAttr # name > Parameters: Parameter C++ type Description name ::mlir::StringAttr AsmLabelAttr Syntax: #hl.asm< ::mlir::StringAttr, # label bool # isLiteral > Parameters: Parameter C++ type Description label ::mlir::StringAttr isLiteral bool BuiltinAttr Syntax: #hl.builtin< unsigned # ID > Parameters: Parameter C++ type Description ID unsigned CVQualifiersAttr Syntax: #hl.quals< bool, # is_const bool # is_volatile > Parameters: Parameter C++ type Description is_const bool const qualifier is_volatile bool volatile qualifier CVRQualifiersAttr Syntax: #hl.quals< bool, # is_const bool, # is_volatile bool # is_restrict > Parameters: Parameter C++ type Description is_const bool const qualifier is_volatile bool volatile qualifier is_restrict bool restrict qualifier ConstAttr Syntax: #hl.const FormatAttr Syntax: #hl.format< ::mlir::StringAttr # name > Parameters: Parameter C++ type Description name ::mlir::StringAttr LoaderUninitializedAttr Syntax: #hl.loader_uninitialized ModeAttr Syntax: #hl.mode< ::mlir::StringAttr # mode > Parameters: Parameter C++ type Description mode ::mlir::StringAttr NoInstrumentFunctionAttr Syntax: #hl.no_instrument_function NoThrowAttr Syntax: #hl.nothrow NonNullAttr Syntax: #hl.nonnull PackedAttr Syntax: #hl.packed PureAttr Syntax: #hl.pure RestrictAttr Syntax: #hl.restrict SectionAttr Syntax: #hl.section< ::mlir::StringAttr # name > Parameters: Parameter C++ type Description name ::mlir::StringAttr UCVQualifiersAttr Syntax: #hl.quals< bool, # is_unsigned bool, # is_const bool # is_volatile > Parameters: Parameter C++ type Description is_unsigned bool unsigned qualifier is_const bool const qualifier is_volatile bool volatile qualifier WarnUnusedResultAttr Syntax: #hl.warn_unused_result Type definition AdjustedType Syntax: !hl.adjusted< Type, # original Type # adjusted > Parameters: Parameter C++ type Description original Type adjusted Type ArrayType Syntax: !hl.array< SizeParam, # size Type, # elementType CVRQualifiersAttr # quals > Parameters: Parameter C++ type Description size SizeParam size parameter for arrays elementType Type quals CVRQualifiersAttr AttributedType Syntax: !hl.attributed< Type # elementType > Parameters: Parameter C++ type Description elementType Type BFloat16Type Syntax: !hl.bfloat16< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr BoolType Syntax: !hl.bool< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr CharType Syntax: !hl.char< UCVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals UCVQualifiersAttr DecayedType Syntax: !hl.decayed< Type # elementType > Parameters: Parameter C++ type Description elementType Type DoubleType Syntax: !hl.double< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr ElaboratedType Syntax: !hl.elaborated< Type, # elementType CVRQualifiersAttr # quals > Parameters: Parameter C++ type Description elementType Type quals CVRQualifiersAttr EnumType Syntax: !hl.enum< ::llvm::StringRef, # name CVQualifiersAttr # quals > Parameters: Parameter C++ type Description name ::llvm::StringRef quals CVQualifiersAttr Float128Type Syntax: !hl.float128< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr FloatType Syntax: !hl.float< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr HalfType Syntax: !hl.half< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr Int128Type Syntax: !hl.int128< UCVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals UCVQualifiersAttr IntType Syntax: !hl.int< UCVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals UCVQualifiersAttr LValueType Syntax: !hl.lvalue< Type # elementType > Parameters: Parameter C++ type Description elementType Type LabelType Syntax: !hl.label LongDoubleType Syntax: !hl.longdouble< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr LongLongType Syntax: !hl.longlong< UCVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals UCVQualifiersAttr LongType Syntax: !hl.long< UCVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals UCVQualifiersAttr ParenType Syntax: !hl.paren< Type # elementType > Parameters: Parameter C++ type Description elementType Type PointerType Syntax: !hl.ptr< Type, # elementType CVRQualifiersAttr # quals > Parameters: Parameter C++ type Description elementType Type quals CVRQualifiersAttr RValueType Syntax: !hl.rvalue< Type # elementType > Parameters: Parameter C++ type Description elementType Type RecordType Syntax: !hl.record< ::llvm::StringRef, # name CVQualifiersAttr # quals > Parameters: Parameter C++ type Description name ::llvm::StringRef quals CVQualifiersAttr ReferenceType Syntax: !hl.reference< Type # elementType > Parameters: Parameter C++ type Description elementType Type ShortType Syntax: !hl.short< UCVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals UCVQualifiersAttr TypeOfExprType Syntax: !hl.typeof.expr< ::llvm::StringRef, # name CVRQualifiersAttr # quals > Parameters: Parameter C++ type Description name ::llvm::StringRef quals CVRQualifiersAttr TypeOfTypeType Syntax: !hl.typeof.type< Type, # unmodifiedType CVRQualifiersAttr # quals > Parameters: Parameter C++ type Description unmodifiedType Type quals CVRQualifiersAttr TypedefType Syntax: !hl.typedef< ::llvm::StringRef, # name CVRQualifiersAttr # quals > Parameters: Parameter C++ type Description name ::llvm::StringRef quals CVRQualifiersAttr VoidType Syntax: !hl.void< CVQualifiersAttr # quals > Parameters: Parameter C++ type Description quals CVQualifiersAttr","title":"HighLevel"},{"location":"dialects/HighLevel/HighLevel/#hl-dialect","text":"A high-level verbose program analysis MLIR dialect. This dialect intends capture highevel constructs of C/C++ for further program analysis. 'hl' Dialect Operation definition hl.access (::vast::hl::AccessSpecifierOp) Attributes: hl.add (::vast::hl::AddIOp) Operands: Results: hl.addressof (::vast::hl::AddressOf) Operands: Results: hl.alignof.expr (::vast::hl::AlignOfExprOp) Results: hl.alignof.type (::vast::hl::AlignOfTypeOp) Attributes: Results: hl.assign (::vast::hl::AssignOp) Operands: Results: hl.assign.add (::vast::hl::AddIAssignOp) Operands: Results: hl.assign.bin.and (::vast::hl::BinAndAssignOp) Operands: Results: hl.assign.bin.ashr (::vast::hl::BinAShrAssignOp) Operands: Results: hl.assign.bin.lshr (::vast::hl::BinLShrAssignOp) Operands: Results: hl.assign.bin.or (::vast::hl::BinOrAssignOp) Operands: Results: hl.assign.bin.shl (::vast::hl::BinShlAssignOp) Operands: Results: hl.assign.bin.xor (::vast::hl::BinXorAssignOp) Operands: Results: hl.assign.fadd (::vast::hl::AddFAssignOp) Operands: Results: hl.assign.fdiv (::vast::hl::DivFAssignOp) Operands: Results: hl.assign.fmul (::vast::hl::MulFAssignOp) Operands: Results: hl.assign.frem (::vast::hl::RemFAssignOp) Operands: Results: hl.assign.fsub (::vast::hl::SubFAssignOp) Operands: Results: hl.assign.mul (::vast::hl::MulIAssignOp) Operands: Results: hl.assign.sdiv (::vast::hl::DivSAssignOp) Operands: Results: hl.assign.srem (::vast::hl::RemSAssignOp) Operands: Results: hl.assign.sub (::vast::hl::SubIAssignOp) Operands: Results: hl.assign.udiv (::vast::hl::DivUAssignOp) Operands: Results: hl.assign.urem (::vast::hl::RemUAssignOp) Operands: Results: hl.base (::vast::hl::CxxBaseSpecifierOp) Attributes: hl.bin.and (::vast::hl::BinAndOp) Operands: Results: hl.bin.ashr (::vast::hl::BinAShrOp) Operands: Results: hl.bin.comma (::vast::hl::BinComma) Operands: Results: hl.bin.land (::vast::hl::BinLAndOp) Results: hl.bin.lor (::vast::hl::BinLOrOp) Results: hl.bin.lshr (::vast::hl::BinLShrOp) Operands: Results: hl.bin.or (::vast::hl::BinOrOp) Operands: Results: hl.bin.shl (::vast::hl::BinShlOp) Operands: Results: hl.bin.xor (::vast::hl::BinXorOp) Operands: Results: hl.break (::vast::hl::BreakOp) hl.builtin_bitcast (::vast::hl::BuiltinBitCastOp) Attributes: Operands: Results: hl.call (::vast::hl::CallOp) Attributes: Operands: Results: hl.case (::vast::hl::CaseOp) hl.class (::vast::hl::ClassDeclOp) Attributes: hl.cmp (::vast::hl::CmpOp) Attributes: Operands: Results: hl.cond (::vast::hl::CondOp) Results: hl.cond.yield (::vast::hl::CondYieldOp) Operands: hl.const (::vast::hl::ConstantOp) Attributes: Results: hl.continue (::vast::hl::ContinueOp) hl.cstyle_cast (::vast::hl::CStyleCastOp) Attributes: Operands: Results: hl.cxxstruct (::vast::hl::CxxStructDeclOp) Attributes: hl.default (::vast::hl::DefaultOp) hl.deref (::vast::hl::Deref) Operands: Results: hl.do (::vast::hl::DoOp) hl.empty.decl (::vast::hl::EmptyDeclOp) hl.enum (::vast::hl::EnumDeclOp) Attributes: hl.enum.const (::vast::hl::EnumConstantOp) Attributes: hl.enumref (::vast::hl::EnumRefOp) Attributes: Results: hl.expr (::vast::hl::ExprOp) Results: hl.fadd (::vast::hl::AddFOp) Operands: Results: hl.fcmp (::vast::hl::FCmpOp) Attributes: Operands: Results: hl.fdiv (::vast::hl::DivFOp) Operands: Results: hl.field (::vast::hl::FieldDeclOp) Attributes: hl.fmul (::vast::hl::MulFOp) Operands: Results: hl.for (::vast::hl::ForOp) hl.frem (::vast::hl::RemFOp) Operands: Results: hl.fsub (::vast::hl::SubFOp) Operands: Results: hl.func (::vast::hl::FuncOp) Attributes: hl.funcref (::vast::hl::FuncRefOp) Attributes: Results: hl.globref (::vast::hl::GlobalRefOp) Attributes: Results: hl.gnu.extension (::vast::hl::ExtensionOp) Operands: Results: hl.goto (::vast::hl::GotoStmt) Operands: hl.if (::vast::hl::IfOp) hl.implicit_cast (::vast::hl::ImplicitCastOp) Attributes: Operands: Results: hl.indirect_call (::vast::hl::IndirectCallOp) Operands: Results: hl.initlist (::vast::hl::InitListExpr) Operands: Results: hl.label (::vast::hl::LabelStmt) Operands: hl.label.decl (::vast::hl::LabelDeclOp) Attributes: Results: hl.labeladdr (::vast::hl::AddrLabelExpr) Operands: Results: hl.lnot (::vast::hl::LNotOp) Operands: Results: hl.member (::vast::hl::RecordMemberOp) Attributes: Operands: Results: hl.minus (::vast::hl::MinusOp) Operands: Results: hl.mul (::vast::hl::MulIOp) Operands: Results: hl.not (::vast::hl::NotOp) Operands: Results: hl.plus (::vast::hl::PlusOp) Operands: Results: hl.post.dec (::vast::hl::PostDecOp) Operands: Results: hl.post.inc (::vast::hl::PostIncOp) Operands: Results: hl.pre.dec (::vast::hl::PreDecOp) Operands: Results: hl.pre.inc (::vast::hl::PreIncOp) Operands: Results: hl.predefined.expr (::vast::hl::PredefinedExpr) Attributes: Operands: Results: hl.ref (::vast::hl::DeclRefOp) Operands: Results: hl.return (::vast::hl::ReturnOp) Operands: hl.sdiv (::vast::hl::DivSOp) Operands: Results: hl.sizeof.expr (::vast::hl::SizeOfExprOp) Results: hl.sizeof.type (::vast::hl::SizeOfTypeOp) Attributes: Results: hl.skip (::vast::hl::SkipStmt) hl.srem (::vast::hl::RemSOp) Operands: Results: hl.stmt.expr (::vast::hl::StmtExprOp) Results: hl.struct (::vast::hl::StructDeclOp) Attributes: hl.sub (::vast::hl::SubIOp) Operands: Results: hl.subscript (::vast::hl::SubscriptOp) Operands: Results: hl.switch (::vast::hl::SwitchOp) hl.this (::vast::hl::ThisOp) Results: hl.translation_unit (::vast::hl::TranslationUnitOp) hl.type (::vast::hl::TypeDeclOp) Attributes: hl.type.yield (::vast::hl::TypeYieldOp) Operands: hl.typedef (::vast::hl::TypeDefOp) Attributes: hl.typeof.expr (::vast::hl::TypeOfExprOp) Attributes: hl.typeof.type (::vast::hl::TypeOfTypeOp) Attributes: hl.udiv (::vast::hl::DivUOp) Operands: Results: hl.union (::vast::hl::UnionDeclOp) Attributes: hl.unreachable (::vast::hl::UnreachableOp) hl.urem (::vast::hl::RemUOp) Operands: Results: hl.value.yield (::vast::hl::ValueYieldOp) Operands: hl.var (::vast::hl::VarDeclOp) Attributes: Results: hl.while (::vast::hl::WhileOp) Attribute definition AllocAlignAttr Parameters: AllocSizeAttr Parameters: AnnotationAttr Parameters: AsmLabelAttr Parameters: BuiltinAttr Parameters: CVQualifiersAttr Parameters: CVRQualifiersAttr Parameters: ConstAttr FormatAttr Parameters: LoaderUninitializedAttr ModeAttr Parameters: NoInstrumentFunctionAttr NoThrowAttr NonNullAttr PackedAttr PureAttr RestrictAttr SectionAttr Parameters: UCVQualifiersAttr Parameters: WarnUnusedResultAttr Type definition AdjustedType Parameters: ArrayType Parameters: AttributedType Parameters: BFloat16Type Parameters: BoolType Parameters: CharType Parameters: DecayedType Parameters: DoubleType Parameters: ElaboratedType Parameters: EnumType Parameters: Float128Type Parameters: FloatType Parameters: HalfType Parameters: Int128Type Parameters: IntType Parameters: LValueType Parameters: LabelType LongDoubleType Parameters: LongLongType Parameters: LongType Parameters: ParenType Parameters: PointerType Parameters: RValueType Parameters: RecordType Parameters: ReferenceType Parameters: ShortType Parameters: TypeOfExprType Parameters: TypeOfTypeType Parameters: TypedefType Parameters: VoidType Parameters:","title":"'hl' Dialect"},{"location":"dialects/HighLevel/HighLevel/#operation-definition","text":"","title":"Operation definition"},{"location":"dialects/HighLevel/HighLevel/#hlaccess-vasthlaccessspecifierop","text":"VAST C++ access specifier declaration Syntax: operation ::= `hl.access` attr-dict $spec VAST C++ access specifier declaration","title":"hl.access (::vast::hl::AccessSpecifierOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes","text":"Attribute MLIR Type Description spec ::vast::hl::AccessSpecifierAttr Access specifier","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hladd-vasthladdiop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.add` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Traits: Commutative","title":"hl.add (::vast::hl::AddIOp)"},{"location":"dialects/HighLevel/HighLevel/#operands","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hladdressof-vasthladdressof","text":"VAST addressof operation Syntax: operation ::= `hl.addressof` $value attr-dict `:` type($value) `->` type($result) VAST addressof operation","title":"hl.addressof (::vast::hl::AddressOf)"},{"location":"dialects/HighLevel/HighLevel/#operands_1","text":"Operand Description value lvalue to any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_1","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlalignofexpr-vasthlalignofexprop","text":"VAST expr alignof operator Syntax: operation ::= `hl.alignof.expr` attr-dict `->` type($result) $expr VAST expr alignof operator","title":"hl.alignof.expr (::vast::hl::AlignOfExprOp)"},{"location":"dialects/HighLevel/HighLevel/#results_2","text":"Result Description result integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlalignoftype-vasthlalignoftypeop","text":"VAST type alignof operator Syntax: operation ::= `hl.alignof.type` $arg attr-dict `->` type($result) VAST type alignof operator","title":"hl.alignof.type (::vast::hl::AlignOfTypeOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_1","text":"Attribute MLIR Type Description arg ::mlir::TypeAttr any type attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#results_3","text":"Result Description result integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassign-vasthlassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign (::vast::hl::AssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_2","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_4","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignadd-vasthladdiassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.add` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.add (::vast::hl::AddIAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_3","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_5","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignbinand-vasthlbinandassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.bin.and` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.bin.and (::vast::hl::BinAndAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_4","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_6","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignbinashr-vasthlbinashrassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.bin.ashr` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.bin.ashr (::vast::hl::BinAShrAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_5","text":"Operand Description src lvalue to integer like type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_7","text":"Result Description result integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignbinlshr-vasthlbinlshrassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.bin.lshr` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.bin.lshr (::vast::hl::BinLShrAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_6","text":"Operand Description src lvalue to integer like type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_8","text":"Result Description result integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignbinor-vasthlbinorassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.bin.or` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.bin.or (::vast::hl::BinOrAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_7","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_9","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignbinshl-vasthlbinshlassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.bin.shl` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.bin.shl (::vast::hl::BinShlAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_8","text":"Operand Description src lvalue to integer like type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_10","text":"Result Description result integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignbinxor-vasthlbinxorassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.bin.xor` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.bin.xor (::vast::hl::BinXorAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_9","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_11","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignfadd-vasthladdfassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.fadd` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.fadd (::vast::hl::AddFAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_10","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_12","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignfdiv-vasthldivfassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.fdiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.fdiv (::vast::hl::DivFAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_11","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_13","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignfmul-vasthlmulfassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.fmul` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.fmul (::vast::hl::MulFAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_12","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_14","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignfrem-vasthlremfassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.frem` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.frem (::vast::hl::RemFAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_13","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_15","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignfsub-vasthlsubfassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.fsub` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.fsub (::vast::hl::SubFAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_14","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_16","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignmul-vasthlmuliassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.mul` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.mul (::vast::hl::MulIAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_15","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_17","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignsdiv-vasthldivsassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.sdiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.sdiv (::vast::hl::DivSAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_16","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_18","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignsrem-vasthlremsassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.srem` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.srem (::vast::hl::RemSAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_17","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_19","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignsub-vasthlsubiassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.sub` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.sub (::vast::hl::SubIAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_18","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_20","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignudiv-vasthldivuassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.udiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.udiv (::vast::hl::DivUAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_19","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_21","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlassignurem-vasthlremuassignop","text":"VAST compound assign operation Syntax: operation ::= `hl.assign.urem` $src `to` $dst attr-dict `:` type(operands) `->` type(results) A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments. The custom assembly form of the operation is as follows: %result = src to dst : functional-type(operands, results) It represents C compound assignment statement: dst = src; Interfaces: InferTypeOpInterface","title":"hl.assign.urem (::vast::hl::RemUAssignOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_20","text":"Operand Description src lvalue to any type dst any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_22","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlbase-vasthlcxxbasespecifierop","text":"VAST base class specifier Syntax: operation ::= `hl.base` $type attr-dict $access (`virtual` $is_virtual^)? VAST base class specifier Interfaces: VastSymbol","title":"hl.base (::vast::hl::CxxBaseSpecifierOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_2","text":"Attribute MLIR Type Description type ::mlir::TypeAttr any type attribute access ::vast::hl::AccessSpecifierAttr Access specifier is_virtual ::mlir::UnitAttr unit attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hlbinand-vasthlbinandop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.bin.and` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.bin.and (::vast::hl::BinAndOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_21","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_23","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlbinashr-vasthlbinashrop","text":"VAST binary shift operation Syntax: operation ::= `hl.bin.ashr` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level binary shift operation. This operation takes two operands and returns one result. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.bin.ashr (::vast::hl::BinAShrOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_22","text":"Operand Description lhs integer like type rhs integer like type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_24","text":"Result Description result integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlbincomma-vasthlbincomma","text":"VAST binary operation Syntax: operation ::= `hl.bin.comma` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)","title":"hl.bin.comma (::vast::hl::BinComma)"},{"location":"dialects/HighLevel/HighLevel/#operands_23","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_25","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlbinland-vasthlbinlandop","text":"VAST logical binary operation Syntax: operation ::= `hl.bin.land` $lhs`,` $rhs attr-dict `:` type(results) High-level logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type","title":"hl.bin.land (::vast::hl::BinLAndOp)"},{"location":"dialects/HighLevel/HighLevel/#results_26","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlbinlor-vasthlbinlorop","text":"VAST logical binary operation Syntax: operation ::= `hl.bin.lor` $lhs`,` $rhs attr-dict `:` type(results) High-level logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : type","title":"hl.bin.lor (::vast::hl::BinLOrOp)"},{"location":"dialects/HighLevel/HighLevel/#results_27","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlbinlshr-vasthlbinlshrop","text":"VAST binary shift operation Syntax: operation ::= `hl.bin.lshr` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level binary shift operation. This operation takes two operands and returns one result. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.bin.lshr (::vast::hl::BinLShrOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_24","text":"Operand Description lhs integer like type rhs integer like type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_28","text":"Result Description result integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlbinor-vasthlbinorop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.bin.or` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.bin.or (::vast::hl::BinOrOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_25","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_29","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlbinshl-vasthlbinshlop","text":"VAST binary shift operation Syntax: operation ::= `hl.bin.shl` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level binary shift operation. This operation takes two operands and returns one result. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.bin.shl (::vast::hl::BinShlOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_26","text":"Operand Description lhs integer like type rhs integer like type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_30","text":"Result Description result integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlbinxor-vasthlbinxorop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.bin.xor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.bin.xor (::vast::hl::BinXorOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_27","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_31","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlbreak-vasthlbreakop","text":"VAST break statement Syntax: operation ::= `hl.break` attr-dict VAST break statement Traits: NoRegionArguments, NoTerminator, soft_terminator Interfaces: RegionKindInterface","title":"hl.break (::vast::hl::BreakOp)"},{"location":"dialects/HighLevel/HighLevel/#hlbuiltin_bitcast-vasthlbuiltinbitcastop","text":"VAST cast operation Syntax: operation ::= `hl.builtin_bitcast` $value $kind attr-dict `:` type($value) `->` type($result) VAST cast operation","title":"hl.builtin_bitcast (::vast::hl::BuiltinBitCastOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_3","text":"Attribute MLIR Type Description kind ::vast::hl::CastKindAttr cast kind","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#operands_28","text":"Operand Description value any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_32","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlcall-vasthlcallop","text":"VAST call operation Syntax: operation ::= `hl.call` $callee `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results ) VAST call operation Interfaces: CallOpInterface","title":"hl.call (::vast::hl::CallOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_4","text":"Attribute MLIR Type Description callee ::mlir::FlatSymbolRefAttr flat symbol reference attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#operands_29","text":"Operand Description argOperands any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_33","text":"Result Description results any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlcase-vasthlcaseop","text":"VAST case statement Syntax: operation ::= `hl.case` $lhs $body attr-dict The operation represents a single case of a switch statement. The generic form of the operation is as follows: hl.case { ... / lhs/check region / hl.value.yield %val : !hl.type } { ... / body region / } It represents a C statement of form case lhs: body; . Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface","title":"hl.case (::vast::hl::CaseOp)"},{"location":"dialects/HighLevel/HighLevel/#hlclass-vasthlclassdeclop","text":"VAST C++ class declaration Syntax: operation ::= `hl.class` $name attr-dict `:` `bases` $bases $fields VAST C++ class declaration Traits: NoTerminator Interfaces: VastSymbol","title":"hl.class (::vast::hl::ClassDeclOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_5","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hlcmp-vasthlcmpop","text":"VAST comparison operation Syntax: operation ::= `hl.cmp` $predicate $lhs `,` $rhs attr-dict `:` type(operands) `->` type($result) VAST comparison operation","title":"hl.cmp (::vast::hl::CmpOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_6","text":"Attribute MLIR Type Description predicate ::vast::hl::PredicateAttr comparison predicate","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#operands_30","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_34","text":"Result Description result bool or integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlcond-vasthlcondop","text":"VAST conditional statement Syntax: operation ::= `hl.cond` $condRegion `?` $thenRegion `:` $elseRegion attr-dict `:` type(results) The operation takes builders of three regions -- condition, true branch and false branch. Builders, given the location, build a particular region. The generic form of the operation is as follows: hl.cond { ... / condition region / hl.cond.yield %cond : !hl.bool } ? { ... / true region / } : { ... / false region / } Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface","title":"hl.cond (::vast::hl::CondOp)"},{"location":"dialects/HighLevel/HighLevel/#results_35","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlcondyield-vasthlcondyieldop","text":"Condition yield operation Syntax: operation ::= `hl.cond.yield` attr-dict $result `:` type($result) A condition yield operation is used to terminate the region representing condition expression of control flow operations IfOp , WhileOp , ForOp and DoOp . It yields a boolean value for the conditional branch. The custom assembly form of the operation is as follows: hl.cond.yield result : BoolType Traits: HasParent , Terminator","title":"hl.cond.yield (::vast::hl::CondYieldOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_31","text":"Operand Description result any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#hlconst-vasthlconstantop","text":"VAST value constant Syntax: operation ::= `hl.const` $value attr-dict VAST value constant Traits: ConstantLike Interfaces: InferTypeOpInterface","title":"hl.const (::vast::hl::ConstantOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_7","text":"Attribute MLIR Type Description value ::mlir::TypedAttr TypedAttr instance","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#results_36","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlcontinue-vasthlcontinueop","text":"VAST continue statement Syntax: operation ::= `hl.continue` attr-dict VAST continue statement Traits: NoRegionArguments, NoTerminator, soft_terminator Interfaces: RegionKindInterface","title":"hl.continue (::vast::hl::ContinueOp)"},{"location":"dialects/HighLevel/HighLevel/#hlcstyle_cast-vasthlcstylecastop","text":"VAST cast operation Syntax: operation ::= `hl.cstyle_cast` $value $kind attr-dict `:` type($value) `->` type($result) VAST cast operation","title":"hl.cstyle_cast (::vast::hl::CStyleCastOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_8","text":"Attribute MLIR Type Description kind ::vast::hl::CastKindAttr cast kind","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#operands_32","text":"Operand Description value any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_37","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlcxxstruct-vasthlcxxstructdeclop","text":"VAST C++ struct declaration Syntax: operation ::= `hl.cxxstruct` $name attr-dict `:` `bases` $bases $fields VAST C++ struct declaration Traits: NoTerminator Interfaces: VastSymbol","title":"hl.cxxstruct (::vast::hl::CxxStructDeclOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_9","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hldefault-vasthldefaultop","text":"VAST default statement Syntax: operation ::= `hl.default` $body attr-dict VAST default statement Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface","title":"hl.default (::vast::hl::DefaultOp)"},{"location":"dialects/HighLevel/HighLevel/#hlderef-vasthlderef","text":"VAST deref operation Syntax: operation ::= `hl.deref` $addr attr-dict `:` type($addr) `->` type($result) VAST deref operation","title":"hl.deref (::vast::hl::Deref)"},{"location":"dialects/HighLevel/HighLevel/#operands_33","text":"Operand Description addr any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_38","text":"Result Description result lvalue to any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hldo-vasthldoop","text":"VAST do-while statement Syntax: operation ::= `hl.do` $bodyRegion `while` $condRegion attr-dict The operation represents a do-while statement. The generic form of the operation is as follows: hl.do { ... / body region / } cond { ... / cond region / hl.cond.yield %cond : !hl.bool } Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface","title":"hl.do (::vast::hl::DoOp)"},{"location":"dialects/HighLevel/HighLevel/#hlemptydecl-vasthlemptydeclop","text":"Syntax: operation ::= `hl.empty.decl` attr-dict","title":"hl.empty.decl (::vast::hl::EmptyDeclOp)"},{"location":"dialects/HighLevel/HighLevel/#hlenum-vasthlenumdeclop","text":"VAST enum declaration Syntax: operation ::= `hl.enum` $name attr-dict `:` ($type^ $constants)? Enum declaration serves to declare region for enum constant declarations. It also defines an underlying type. Traits: NoTerminator Interfaces: VastSymbol","title":"hl.enum (::vast::hl::EnumDeclOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_10","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hlenumconst-vasthlenumconstantop","text":"VAST enum constant declaration Syntax: operation ::= `hl.enum.const` $name `=` $value attr-dict (`init` $init^)? Enumeration constant servers to link name to an enum value. It is required to be scoped in Enum operation. For example: hl.enum.const \"F\" = 2 : !hl.int A constant can have a constant expression initializer: hl.enum.const \"G\" = #core.integer<12> : !hl.int init { %0 = hl.enumref \"F\" : !hl.int %1 = hl.enumref \"C\" : !hl.int %2 = hl.add %0, %1 : !hl.int hl.value.yield %2 : !hl.int }","title":"hl.enum.const (::vast::hl::EnumConstantOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_11","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute value ::mlir::TypedAttr TypedAttr instance","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hlenumref-vasthlenumrefop","text":"VAST variable reference declaration Syntax: operation ::= `hl.enumref` $value attr-dict `:` type($result) VAST variable reference declaration","title":"hl.enumref (::vast::hl::EnumRefOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_12","text":"Attribute MLIR Type Description value ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#results_39","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlexpr-vasthlexprop","text":"VAST expression Syntax: operation ::= `hl.expr` attr-dict `:` type($result) $subexpr VAST expression Traits: SingleBlock","title":"hl.expr (::vast::hl::ExprOp)"},{"location":"dialects/HighLevel/HighLevel/#results_40","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlfadd-vasthladdfop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.fadd` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.fadd (::vast::hl::AddFOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_34","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_41","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlfcmp-vasthlfcmpop","text":"VAST flaoting point comparison operation Syntax: operation ::= `hl.fcmp` $predicate $lhs `,` $rhs attr-dict `:` type(operands) `->` type($result) VAST floating point comparison operation","title":"hl.fcmp (::vast::hl::FCmpOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_13","text":"Attribute MLIR Type Description predicate ::vast::hl::FPredicateAttr floating point comparison predicate","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#operands_35","text":"Operand Description lhs float like type rhs float like type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_42","text":"Result Description result bool or integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlfdiv-vasthldivfop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.fdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.fdiv (::vast::hl::DivFOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_36","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_43","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlfield-vasthlfielddeclop","text":"VAST record field declaration Syntax: operation ::= `hl.field` $name attr-dict (`bw` $bits^)? `:` $type VAST record field declaration Interfaces: VastSymbol","title":"hl.field (::vast::hl::FieldDeclOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_14","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute bits ::mlir::IntegerAttr 32-bit signless integer attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hlfmul-vasthlmulfop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.fmul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.fmul (::vast::hl::MulFOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_37","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_44","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlfor-vasthlforop","text":"VAST for statement Syntax: operation ::= `hl.for` $condRegion `incr` $incrRegion attr-dict `do` $bodyRegion Operation represents a for-loop statement. The generic form of the operation is as follows: hl.for { ... / cond region / hl.cond.yield %cond : !hl.bool } incr { ... / increment/update region / } do { ... / body region / } Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface","title":"hl.for (::vast::hl::ForOp)"},{"location":"dialects/HighLevel/HighLevel/#hlfrem-vasthlremfop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.frem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.frem (::vast::hl::RemFOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_38","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_45","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlfsub-vasthlsubfop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.fsub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.fsub (::vast::hl::SubFOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_39","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_46","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlfunc-vasthlfuncop","text":"VAST function template Syntax: operation ::= `hl.func` $sym_name custom< FunctionSignatureAndBody >($function_type, attr-dict, $body) Inspired by cir::FuncOp and mlir::func::FuncOp : Operations within the function cannot implicitly capture values defined outside of the function, i.e. Functions are IsolatedFromAbove . All external references must use function arguments or attributes that establish a symbolic connection (e.g. symbols referenced by name via a string attribute like SymbolRefAttr). An external function declaration (used when referring to a function declared in some other module) has no body. The function linkage information is specified by linkage , as defined by GlobalLinkageKind attribute. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, RegionKindInterface, Symbol","title":"hl.func (::vast::hl::FuncOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_15","text":"Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::core::GlobalLinkageKindAttr global linkage kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hlfuncref-vasthlfuncrefop","text":"VAST function reference declaration Syntax: operation ::= `hl.funcref` $function attr-dict `:` type($result) VAST function reference declaration","title":"hl.funcref (::vast::hl::FuncRefOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_16","text":"Attribute MLIR Type Description function ::mlir::FlatSymbolRefAttr flat symbol reference attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#results_47","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlglobref-vasthlglobalrefop","text":"VAST global variable reference declaration Syntax: operation ::= `hl.globref` $global attr-dict `:` type($result) VAST global variable reference declaration","title":"hl.globref (::vast::hl::GlobalRefOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_17","text":"Attribute MLIR Type Description global ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#results_48","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlgnuextension-vasthlextensionop","text":"VAST extension (__extension__) keyword Syntax: operation ::= `hl.gnu.extension` $value attr-dict `:` type($value) `->` type($result) VAST op corresponding to GNU extension keyword.","title":"hl.gnu.extension (::vast::hl::ExtensionOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_40","text":"Operand Description value any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_49","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlgoto-vasthlgotostmt","text":"Syntax: operation ::= `hl.goto` $label attr-dict","title":"hl.goto (::vast::hl::GotoStmt)"},{"location":"dialects/HighLevel/HighLevel/#operands_41","text":"Operand Description label","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#hlif-vasthlifop","text":"VAST if statement The operation takes builders of two mandatory regions -- condition and then region -- and one builder optional region representing else block of C if statement. Builders, given the location, build a particular region. The generic form of the operation is as follows: hl.if { ... / condition region / hl.cond.yield %cond : !hl.bool } then { ... / then region / } else { ... / else region / } Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface","title":"hl.if (::vast::hl::IfOp)"},{"location":"dialects/HighLevel/HighLevel/#hlimplicit_cast-vasthlimplicitcastop","text":"VAST cast operation Syntax: operation ::= `hl.implicit_cast` $value $kind attr-dict `:` type($value) `->` type($result) VAST cast operation","title":"hl.implicit_cast (::vast::hl::ImplicitCastOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_18","text":"Attribute MLIR Type Description kind ::vast::hl::CastKindAttr cast kind","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#operands_42","text":"Operand Description value any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_50","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlindirect_call-vasthlindirectcallop","text":"VAST call operation Syntax: operation ::= `hl.indirect_call` $callee `:` type($callee) `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results ) VAST call operation Interfaces: CallOpInterface","title":"hl.indirect_call (::vast::hl::IndirectCallOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_43","text":"Operand Description callee any type argOperands any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_51","text":"Result Description results any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlinitlist-vasthlinitlistexpr","text":"VAST initializer list expression Syntax: operation ::= `hl.initlist` $elements attr-dict `:` functional-type($elements, results) VAST initializer list expression","title":"hl.initlist (::vast::hl::InitListExpr)"},{"location":"dialects/HighLevel/HighLevel/#operands_44","text":"Operand Description elements any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_52","text":"Result Description \u00abunnamed\u00bb any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hllabel-vasthllabelstmt","text":"VAST control flow operation Syntax: operation ::= `hl.label` $label $body attr-dict VAST control flow operation Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface","title":"hl.label (::vast::hl::LabelStmt)"},{"location":"dialects/HighLevel/HighLevel/#operands_45","text":"Operand Description label","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#hllabeldecl-vasthllabeldeclop","text":"Syntax: operation ::= `hl.label.decl` $name attr-dict `:` type($result) Interfaces: InferTypeOpInterface","title":"hl.label.decl (::vast::hl::LabelDeclOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_19","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#results_53","text":"Result Description result","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hllabeladdr-vasthladdrlabelexpr","text":"VAST address of label extension Syntax: operation ::= `hl.labeladdr` $label attr-dict `:` type($result) VAST address of label extension","title":"hl.labeladdr (::vast::hl::AddrLabelExpr)"},{"location":"dialects/HighLevel/HighLevel/#operands_46","text":"Operand Description label","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_54","text":"Result Description result lvalue to pointer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hllnot-vasthllnotop","text":"VAST unary logical operation Syntax: operation ::= `hl.lnot` $arg attr-dict `:` type($arg) `->` type($res) High-level unary logical operation assures that result has the right type. The custom assembly form of the operation is as follows: %result = %arg : type -> ret_type","title":"hl.lnot (::vast::hl::LNotOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_47","text":"Operand Description arg any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_55","text":"Result Description res bool or integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlmember-vasthlrecordmemberop","text":"VAST record element access operation Syntax: operation ::= `hl.member` $record `at` $name attr-dict `:` type($record) `->` type($element) VAST record element access operation","title":"hl.member (::vast::hl::RecordMemberOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_20","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#operands_48","text":"Operand Description record any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_56","text":"Result Description element lvalue to any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlminus-vasthlminusop","text":"VAST unary type preserving operation Syntax: operation ::= `hl.minus` $arg attr-dict `:` type($result) Type preserving high-level unary operation assures that argument and result has the same type. The custom assembly form of the operation is as follows: %result = %arg : type Traits: SameOperandsAndResultType Interfaces: InferTypeOpInterface","title":"hl.minus (::vast::hl::MinusOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_49","text":"Operand Description arg any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_57","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlmul-vasthlmuliop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.mul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results) Traits: Commutative","title":"hl.mul (::vast::hl::MulIOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_50","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_58","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlnot-vasthlnotop","text":"VAST unary type preserving operation Syntax: operation ::= `hl.not` $arg attr-dict `:` type($result) Type preserving high-level unary operation assures that argument and result has the same type. The custom assembly form of the operation is as follows: %result = %arg : type Traits: SameOperandsAndResultType Interfaces: InferTypeOpInterface","title":"hl.not (::vast::hl::NotOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_51","text":"Operand Description arg any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_59","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlplus-vasthlplusop","text":"VAST unary type preserving operation Syntax: operation ::= `hl.plus` $arg attr-dict `:` type($result) Type preserving high-level unary operation assures that argument and result has the same type. The custom assembly form of the operation is as follows: %result = %arg : type Traits: SameOperandsAndResultType Interfaces: InferTypeOpInterface","title":"hl.plus (::vast::hl::PlusOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_52","text":"Operand Description arg any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_60","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlpostdec-vasthlpostdecop","text":"VAST unary inplace operation Syntax: operation ::= `hl.post.dec` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface","title":"hl.post.dec (::vast::hl::PostDecOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_53","text":"Operand Description arg lvalue to any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_61","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlpostinc-vasthlpostincop","text":"VAST unary inplace operation Syntax: operation ::= `hl.post.inc` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface","title":"hl.post.inc (::vast::hl::PostIncOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_54","text":"Operand Description arg lvalue to any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_62","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlpredec-vasthlpredecop","text":"VAST unary inplace operation Syntax: operation ::= `hl.pre.dec` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface","title":"hl.pre.dec (::vast::hl::PreDecOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_55","text":"Operand Description arg lvalue to any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_63","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlpreinc-vasthlpreincop","text":"VAST unary inplace operation Syntax: operation ::= `hl.pre.inc` $arg attr-dict `:` type($arg) `->` type($result) Inplace high-level unary operation changes its single argument in place. It does not produce a new value. The custom assembly form of the operation is as follows: %result = %arg : type Interfaces: InferTypeOpInterface","title":"hl.pre.inc (::vast::hl::PreIncOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_56","text":"Operand Description arg lvalue to any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_64","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlpredefinedexpr-vasthlpredefinedexpr","text":"VAT predefined expr ( such as __func__ ) Syntax: operation ::= `hl.predefined.expr` $value $kind attr-dict `:` type($value) `->` type($result) VAT predefined expr ( such as func )","title":"hl.predefined.expr (::vast::hl::PredefinedExpr)"},{"location":"dialects/HighLevel/HighLevel/#attributes_21","text":"Attribute MLIR Type Description kind ::vast::hl::IdentKindAttr ident kind","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#operands_57","text":"Operand Description value any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_65","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlref-vasthldeclrefop","text":"VAST variable reference declaration Syntax: operation ::= `hl.ref` $decl attr-dict `:` functional-type(operands, results) VAST variable reference declaration","title":"hl.ref (::vast::hl::DeclRefOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_58","text":"Operand Description decl any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_66","text":"Result Description result lvalue to any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlreturn-vasthlreturnop","text":"Syntax: operation ::= `hl.return` ($result^ `:` type($result))? attr-dict Traits: return_trait, soft_terminator","title":"hl.return (::vast::hl::ReturnOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_59","text":"Operand Description result any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#hlsdiv-vasthldivsop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.sdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.sdiv (::vast::hl::DivSOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_60","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_67","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlsizeofexpr-vasthlsizeofexprop","text":"VAST expr sizeof operator Syntax: operation ::= `hl.sizeof.expr` attr-dict `->` type($result) $expr VAST expr sizeof operator","title":"hl.sizeof.expr (::vast::hl::SizeOfExprOp)"},{"location":"dialects/HighLevel/HighLevel/#results_68","text":"Result Description result integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlsizeoftype-vasthlsizeoftypeop","text":"VAST type sizeof operator Syntax: operation ::= `hl.sizeof.type` $arg attr-dict `->` type($result) VAST type sizeof operator","title":"hl.sizeof.type (::vast::hl::SizeOfTypeOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_22","text":"Attribute MLIR Type Description arg ::mlir::TypeAttr any type attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#results_69","text":"Result Description result integer like type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlskip-vasthlskipstmt","text":"VAST skip statement Syntax: operation ::= `hl.skip` attr-dict VAST skip statement","title":"hl.skip (::vast::hl::SkipStmt)"},{"location":"dialects/HighLevel/HighLevel/#hlsrem-vasthlremsop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.srem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.srem (::vast::hl::RemSOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_61","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_70","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlstmtexpr-vasthlstmtexprop","text":"VAST statement expression Syntax: operation ::= `hl.stmt.expr` attr-dict `:` type($result) $substmt VAST statement expression Traits: SingleBlock Interfaces: RegionKindInterface","title":"hl.stmt.expr (::vast::hl::StmtExprOp)"},{"location":"dialects/HighLevel/HighLevel/#results_71","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlstruct-vasthlstructdeclop","text":"VAST struct declaration Syntax: operation ::= `hl.struct` $name attr-dict `:` $fields VAST struct declaration Traits: NoTerminator Interfaces: VastSymbol","title":"hl.struct (::vast::hl::StructDeclOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_23","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hlsub-vasthlsubiop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.sub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.sub (::vast::hl::SubIOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_62","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_72","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlsubscript-vasthlsubscriptop","text":"VAST array subscript operator Syntax: operation ::= `hl.subscript` $array `at` ` ` `[` $index `:` type($index) `]` attr-dict `:` type($array) `->` type($result) VAST array subscript operator","title":"hl.subscript (::vast::hl::SubscriptOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_63","text":"Operand Description array lvalue to subscriptable type index integer like type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_73","text":"Result Description result lvalue to any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlswitch-vasthlswitchop","text":"VAST switch statement Syntax: operation ::= `hl.switch` $condRegion `cases` $cases attr-dict The operation represents a switch statement. The generic form of the operation is as follows: hl.switch { ... / cond region / hl.value.yield %val : !hl.type } cases { ... / casesregion / } Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface","title":"hl.switch (::vast::hl::SwitchOp)"},{"location":"dialects/HighLevel/HighLevel/#hlthis-vasthlthisop","text":"VAST this operator Syntax: operation ::= `hl.this` attr-dict `:` type($result) VAST this operator","title":"hl.this (::vast::hl::ThisOp)"},{"location":"dialects/HighLevel/HighLevel/#results_74","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hltranslation_unit-vasthltranslationunitop","text":"VAST translation unit Syntax: operation ::= `hl.translation_unit` $body attr-dict VAST tranaslation unit Traits: IsolatedFromAbove, NoTerminator, SymbolTable","title":"hl.translation_unit (::vast::hl::TranslationUnitOp)"},{"location":"dialects/HighLevel/HighLevel/#hltype-vasthltypedeclop","text":"VAST type declaration Syntax: operation ::= `hl.type` $name attr-dict VAST type declaration Interfaces: VastSymbol","title":"hl.type (::vast::hl::TypeDeclOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_24","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hltypeyield-vasthltypeyieldop","text":"Type yield operation Syntax: operation ::= `hl.type.yield` attr-dict $result `:` type($result) A type yield operation is used to terminate the underlying expression region of a typeof(expr) statement. The custom assembly form of the operation is as follows: hl.type.yield result : type Traits: Terminator","title":"hl.type.yield (::vast::hl::TypeYieldOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_64","text":"Operand Description result any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#hltypedef-vasthltypedefop","text":"VAST typedef operation Syntax: operation ::= `hl.typedef` $name attr-dict `:` $type Typedef operation servers to declare named types. It creates a new type symbol in the current scope to be referenced as NamedType later. Interfaces: VastSymbol","title":"hl.typedef (::vast::hl::TypeDefOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_25","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hltypeofexpr-vasthltypeofexprop","text":"VAST typeof(expr) operation Syntax: operation ::= `hl.typeof.expr` $name $expr `:` $type attr-dict The Typeof operation serves to declare a type using type introspection. It evaluates its underlying expression, creates a new type symbol in the current scope, assigns it to the type of the underlying expression, and returns the type symbol to be referenced later Traits: SingleBlock Interfaces: VastSymbol","title":"hl.typeof.expr (::vast::hl::TypeOfExprOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_26","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute type ::mlir::TypeAttr any type attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hltypeoftype-vasthltypeoftypeop","text":"VAST typeof(type) operation Syntax: operation ::= `hl.typeof.type` attr-dict `:` $type Interfaces: VastSymbol","title":"hl.typeof.type (::vast::hl::TypeOfTypeOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_27","text":"Attribute MLIR Type Description type ::mlir::TypeAttr any type attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hludiv-vasthldivuop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.udiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.udiv (::vast::hl::DivUOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_65","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_75","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlunion-vasthluniondeclop","text":"VAST record declaration Syntax: operation ::= `hl.union` $name attr-dict `:` $fields VAST record declaration Traits: NoTerminator Interfaces: VastSymbol","title":"hl.union (::vast::hl::UnionDeclOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_28","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#hlunreachable-vasthlunreachableop","text":"VAST unreachable operation Syntax: operation ::= `hl.unreachable` attr-dict VAST unreachable operation Traits: Terminator","title":"hl.unreachable (::vast::hl::UnreachableOp)"},{"location":"dialects/HighLevel/HighLevel/#hlurem-vasthlremuop","text":"VAST arithmetic binary operation Syntax: operation ::= `hl.urem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results) High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type. The custom assembly form of the operation is as follows: %result = %lhs, %rhs : functional-type(operands, results)","title":"hl.urem (::vast::hl::RemUOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_66","text":"Operand Description lhs any type rhs any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#results_76","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlvalueyield-vasthlvalueyieldop","text":"Value yield operation Syntax: operation ::= `hl.value.yield` attr-dict $result `:` type($result) A value yield operation is used to terminate the case region of a switch statement. The yielded value triggers the parent case statement region. The custom assembly form of the operation is as follows: hl.value.yield result : type Traits: Terminator","title":"hl.value.yield (::vast::hl::ValueYieldOp)"},{"location":"dialects/HighLevel/HighLevel/#operands_67","text":"Operand Description result any type","title":"Operands:"},{"location":"dialects/HighLevel/HighLevel/#hlvar-vasthlvardeclop","text":"VAST variable declaration Syntax: operation ::= `hl.var` $name attr-dict ($storageClass^)? ($threadStorageClass^)? `:` type($result) (`=` $initializer^)? (`allocation_size` $allocation_size^)? VAST variable declaration Interfaces: VastSymbol","title":"hl.var (::vast::hl::VarDeclOp)"},{"location":"dialects/HighLevel/HighLevel/#attributes_29","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute storageClass ::vast::hl::StorageClassAttr storage class threadStorageClass ::vast::hl::TSClassAttr thread storage class","title":"Attributes:"},{"location":"dialects/HighLevel/HighLevel/#results_77","text":"Result Description result any type","title":"Results:"},{"location":"dialects/HighLevel/HighLevel/#hlwhile-vasthlwhileop","text":"VAST while statement Syntax: operation ::= `hl.while` $condRegion `do` $bodyRegion attr-dict The operation takes builders of two mandatory regions -- condition and body region. Builders, given the location, build a particular region. The generic form of the operation is as follows: hl.while { ... / condition region / hl.cond.yield %cond : !hl.bool } do { ... / body region / } Traits: NoRegionArguments, NoTerminator Interfaces: RegionKindInterface","title":"hl.while (::vast::hl::WhileOp)"},{"location":"dialects/HighLevel/HighLevel/#attribute-definition","text":"","title":"Attribute definition"},{"location":"dialects/HighLevel/HighLevel/#allocalignattr","text":"Syntax: #hl.alloc_align< int # alignment >","title":"AllocAlignAttr"},{"location":"dialects/HighLevel/HighLevel/#parameters","text":"Parameter C++ type Description alignment int","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#allocsizeattr","text":"Syntax: #hl.alloc_size< int, # size_arg_pos int # num_arg_pos >","title":"AllocSizeAttr"},{"location":"dialects/HighLevel/HighLevel/#parameters_1","text":"Parameter C++ type Description size_arg_pos int num_arg_pos int","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#annotationattr","text":"Syntax: #hl.annotation< ::mlir::StringAttr # name >","title":"AnnotationAttr"},{"location":"dialects/HighLevel/HighLevel/#parameters_2","text":"Parameter C++ type Description name ::mlir::StringAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#asmlabelattr","text":"Syntax: #hl.asm< ::mlir::StringAttr, # label bool # isLiteral >","title":"AsmLabelAttr"},{"location":"dialects/HighLevel/HighLevel/#parameters_3","text":"Parameter C++ type Description label ::mlir::StringAttr isLiteral bool","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#builtinattr","text":"Syntax: #hl.builtin< unsigned # ID >","title":"BuiltinAttr"},{"location":"dialects/HighLevel/HighLevel/#parameters_4","text":"Parameter C++ type Description ID unsigned","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#cvqualifiersattr","text":"Syntax: #hl.quals< bool, # is_const bool # is_volatile >","title":"CVQualifiersAttr"},{"location":"dialects/HighLevel/HighLevel/#parameters_5","text":"Parameter C++ type Description is_const bool const qualifier is_volatile bool volatile qualifier","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#cvrqualifiersattr","text":"Syntax: #hl.quals< bool, # is_const bool, # is_volatile bool # is_restrict >","title":"CVRQualifiersAttr"},{"location":"dialects/HighLevel/HighLevel/#parameters_6","text":"Parameter C++ type Description is_const bool const qualifier is_volatile bool volatile qualifier is_restrict bool restrict qualifier","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#constattr","text":"Syntax: #hl.const","title":"ConstAttr"},{"location":"dialects/HighLevel/HighLevel/#formatattr","text":"Syntax: #hl.format< ::mlir::StringAttr # name >","title":"FormatAttr"},{"location":"dialects/HighLevel/HighLevel/#parameters_7","text":"Parameter C++ type Description name ::mlir::StringAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#loaderuninitializedattr","text":"Syntax: #hl.loader_uninitialized","title":"LoaderUninitializedAttr"},{"location":"dialects/HighLevel/HighLevel/#modeattr","text":"Syntax: #hl.mode< ::mlir::StringAttr # mode >","title":"ModeAttr"},{"location":"dialects/HighLevel/HighLevel/#parameters_8","text":"Parameter C++ type Description mode ::mlir::StringAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#noinstrumentfunctionattr","text":"Syntax: #hl.no_instrument_function","title":"NoInstrumentFunctionAttr"},{"location":"dialects/HighLevel/HighLevel/#nothrowattr","text":"Syntax: #hl.nothrow","title":"NoThrowAttr"},{"location":"dialects/HighLevel/HighLevel/#nonnullattr","text":"Syntax: #hl.nonnull","title":"NonNullAttr"},{"location":"dialects/HighLevel/HighLevel/#packedattr","text":"Syntax: #hl.packed","title":"PackedAttr"},{"location":"dialects/HighLevel/HighLevel/#pureattr","text":"Syntax: #hl.pure","title":"PureAttr"},{"location":"dialects/HighLevel/HighLevel/#restrictattr","text":"Syntax: #hl.restrict","title":"RestrictAttr"},{"location":"dialects/HighLevel/HighLevel/#sectionattr","text":"Syntax: #hl.section< ::mlir::StringAttr # name >","title":"SectionAttr"},{"location":"dialects/HighLevel/HighLevel/#parameters_9","text":"Parameter C++ type Description name ::mlir::StringAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#ucvqualifiersattr","text":"Syntax: #hl.quals< bool, # is_unsigned bool, # is_const bool # is_volatile >","title":"UCVQualifiersAttr"},{"location":"dialects/HighLevel/HighLevel/#parameters_10","text":"Parameter C++ type Description is_unsigned bool unsigned qualifier is_const bool const qualifier is_volatile bool volatile qualifier","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#warnunusedresultattr","text":"Syntax: #hl.warn_unused_result","title":"WarnUnusedResultAttr"},{"location":"dialects/HighLevel/HighLevel/#type-definition","text":"","title":"Type definition"},{"location":"dialects/HighLevel/HighLevel/#adjustedtype","text":"Syntax: !hl.adjusted< Type, # original Type # adjusted >","title":"AdjustedType"},{"location":"dialects/HighLevel/HighLevel/#parameters_11","text":"Parameter C++ type Description original Type adjusted Type","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#arraytype","text":"Syntax: !hl.array< SizeParam, # size Type, # elementType CVRQualifiersAttr # quals >","title":"ArrayType"},{"location":"dialects/HighLevel/HighLevel/#parameters_12","text":"Parameter C++ type Description size SizeParam size parameter for arrays elementType Type quals CVRQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#attributedtype","text":"Syntax: !hl.attributed< Type # elementType >","title":"AttributedType"},{"location":"dialects/HighLevel/HighLevel/#parameters_13","text":"Parameter C++ type Description elementType Type","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#bfloat16type","text":"Syntax: !hl.bfloat16< CVQualifiersAttr # quals >","title":"BFloat16Type"},{"location":"dialects/HighLevel/HighLevel/#parameters_14","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#booltype","text":"Syntax: !hl.bool< CVQualifiersAttr # quals >","title":"BoolType"},{"location":"dialects/HighLevel/HighLevel/#parameters_15","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#chartype","text":"Syntax: !hl.char< UCVQualifiersAttr # quals >","title":"CharType"},{"location":"dialects/HighLevel/HighLevel/#parameters_16","text":"Parameter C++ type Description quals UCVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#decayedtype","text":"Syntax: !hl.decayed< Type # elementType >","title":"DecayedType"},{"location":"dialects/HighLevel/HighLevel/#parameters_17","text":"Parameter C++ type Description elementType Type","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#doubletype","text":"Syntax: !hl.double< CVQualifiersAttr # quals >","title":"DoubleType"},{"location":"dialects/HighLevel/HighLevel/#parameters_18","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#elaboratedtype","text":"Syntax: !hl.elaborated< Type, # elementType CVRQualifiersAttr # quals >","title":"ElaboratedType"},{"location":"dialects/HighLevel/HighLevel/#parameters_19","text":"Parameter C++ type Description elementType Type quals CVRQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#enumtype","text":"Syntax: !hl.enum< ::llvm::StringRef, # name CVQualifiersAttr # quals >","title":"EnumType"},{"location":"dialects/HighLevel/HighLevel/#parameters_20","text":"Parameter C++ type Description name ::llvm::StringRef quals CVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#float128type","text":"Syntax: !hl.float128< CVQualifiersAttr # quals >","title":"Float128Type"},{"location":"dialects/HighLevel/HighLevel/#parameters_21","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#floattype","text":"Syntax: !hl.float< CVQualifiersAttr # quals >","title":"FloatType"},{"location":"dialects/HighLevel/HighLevel/#parameters_22","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#halftype","text":"Syntax: !hl.half< CVQualifiersAttr # quals >","title":"HalfType"},{"location":"dialects/HighLevel/HighLevel/#parameters_23","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#int128type","text":"Syntax: !hl.int128< UCVQualifiersAttr # quals >","title":"Int128Type"},{"location":"dialects/HighLevel/HighLevel/#parameters_24","text":"Parameter C++ type Description quals UCVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#inttype","text":"Syntax: !hl.int< UCVQualifiersAttr # quals >","title":"IntType"},{"location":"dialects/HighLevel/HighLevel/#parameters_25","text":"Parameter C++ type Description quals UCVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#lvaluetype","text":"Syntax: !hl.lvalue< Type # elementType >","title":"LValueType"},{"location":"dialects/HighLevel/HighLevel/#parameters_26","text":"Parameter C++ type Description elementType Type","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#labeltype","text":"Syntax: !hl.label","title":"LabelType"},{"location":"dialects/HighLevel/HighLevel/#longdoubletype","text":"Syntax: !hl.longdouble< CVQualifiersAttr # quals >","title":"LongDoubleType"},{"location":"dialects/HighLevel/HighLevel/#parameters_27","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#longlongtype","text":"Syntax: !hl.longlong< UCVQualifiersAttr # quals >","title":"LongLongType"},{"location":"dialects/HighLevel/HighLevel/#parameters_28","text":"Parameter C++ type Description quals UCVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#longtype","text":"Syntax: !hl.long< UCVQualifiersAttr # quals >","title":"LongType"},{"location":"dialects/HighLevel/HighLevel/#parameters_29","text":"Parameter C++ type Description quals UCVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#parentype","text":"Syntax: !hl.paren< Type # elementType >","title":"ParenType"},{"location":"dialects/HighLevel/HighLevel/#parameters_30","text":"Parameter C++ type Description elementType Type","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#pointertype","text":"Syntax: !hl.ptr< Type, # elementType CVRQualifiersAttr # quals >","title":"PointerType"},{"location":"dialects/HighLevel/HighLevel/#parameters_31","text":"Parameter C++ type Description elementType Type quals CVRQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#rvaluetype","text":"Syntax: !hl.rvalue< Type # elementType >","title":"RValueType"},{"location":"dialects/HighLevel/HighLevel/#parameters_32","text":"Parameter C++ type Description elementType Type","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#recordtype","text":"Syntax: !hl.record< ::llvm::StringRef, # name CVQualifiersAttr # quals >","title":"RecordType"},{"location":"dialects/HighLevel/HighLevel/#parameters_33","text":"Parameter C++ type Description name ::llvm::StringRef quals CVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#referencetype","text":"Syntax: !hl.reference< Type # elementType >","title":"ReferenceType"},{"location":"dialects/HighLevel/HighLevel/#parameters_34","text":"Parameter C++ type Description elementType Type","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#shorttype","text":"Syntax: !hl.short< UCVQualifiersAttr # quals >","title":"ShortType"},{"location":"dialects/HighLevel/HighLevel/#parameters_35","text":"Parameter C++ type Description quals UCVQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#typeofexprtype","text":"Syntax: !hl.typeof.expr< ::llvm::StringRef, # name CVRQualifiersAttr # quals >","title":"TypeOfExprType"},{"location":"dialects/HighLevel/HighLevel/#parameters_36","text":"Parameter C++ type Description name ::llvm::StringRef quals CVRQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#typeoftypetype","text":"Syntax: !hl.typeof.type< Type, # unmodifiedType CVRQualifiersAttr # quals >","title":"TypeOfTypeType"},{"location":"dialects/HighLevel/HighLevel/#parameters_37","text":"Parameter C++ type Description unmodifiedType Type quals CVRQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#typedeftype","text":"Syntax: !hl.typedef< ::llvm::StringRef, # name CVRQualifiersAttr # quals >","title":"TypedefType"},{"location":"dialects/HighLevel/HighLevel/#parameters_38","text":"Parameter C++ type Description name ::llvm::StringRef quals CVRQualifiersAttr","title":"Parameters:"},{"location":"dialects/HighLevel/HighLevel/#voidtype","text":"Syntax: !hl.void< CVQualifiersAttr # quals >","title":"VoidType"},{"location":"dialects/HighLevel/HighLevel/#parameters_39","text":"Parameter C++ type Description quals CVQualifiersAttr","title":"Parameters:"},{"location":"dialects/LowLevel/LowLevel/","text":"'ll' Dialect A vast low-level dialect. This dialect serves as a bottom layer in VAST dialect tower. There should always exist a pass that lowers this dialect into LLVM Dialect. Work in progress - new operations are still being added and existing can be changed or removed. 'll' Dialect Operation definition ll.br (::vast::ll::Br) Operands: Successors: ll.concat (::vast::ll::Concat) Operands: Results: ll.cond_br (::vast::ll::CondBr) Operands: Successors: ll.cond_scope_ret (::vast::ll::CondScopeRet) Operands: Successors: ll.extract (::vast::ll::Extract) Attributes: Operands: Results: ll.func (::vast::ll::FuncOp) Attributes: ll.gep (::vast::ll::StructGEPOp) Attributes: Operands: Results: ll.initialize (::vast::ll::InitializeVar) Operands: Results: ll.inline_scope (::vast::ll::InlineScope) ll.return (::vast::ll::ReturnOp) Operands: ll.scope (::vast::ll::Scope) ll.scope_recurse (::vast::ll::ScopeRecurse) ll.scope_ret (::vast::ll::ScopeRet) ll.uninitialized_var (::vast::ll::UninitializedVar) Results: Operation definition ll.br (::vast::ll::Br) Direct branch. Syntax: operation ::= `ll.br` $dest (`(` $operands^ `:` type($operands) `)`)? attr-dict Direct branch Traits: Terminator Interfaces: BranchOpInterface Operands: Operand Description operands any type Successors: Successor Description dest any successor ll.concat (::vast::ll::Concat) Concat integers together Syntax: operation ::= `ll.concat` operands attr-dict `:` functional-type(operands, results) Concat operands together, where first argument occupies lsb. Operands: Operand Description args any type Results: Result Description result any type ll.cond_br (::vast::ll::CondBr) Conditional branch. Syntax: operation ::= `ll.cond_br` $cond `:` type($cond) `,` $trueDest (`(` $trueOperands^ `:` type($trueOperands) `)`)? `,` $falseDest (`(` $falseOperands^ `:` type($falseOperands) `)`)? attr-dict Direct branch Traits: AttrSizedOperandSegments, Terminator Operands: Operand Description cond any type trueOperands any type falseOperands any type Successors: Successor Description trueDest any successor falseDest any successor ll.cond_scope_ret (::vast::ll::CondScopeRet) Terminator of scope if condition is met, otherwise branch. Syntax: operation ::= `ll.cond_scope_ret` $cond `:` type($cond) `,` $dest (`(` $dest_operands^ `:` type($dest_operands) `)`)? attr-dict Terminate or branch. Traits: Terminator Operands: Operand Description cond any type dest_operands any type Successors: Successor Description dest any successor ll.extract (::vast::ll::Extract) Extracts value Syntax: operation ::= `ll.extract` operands attr-dict `:` functional-type(operands, results) 0 is lsb, [inc, exc) Attributes: Attribute MLIR Type Description from ::mlir::TypedAttr TypedAttr instance to ::mlir::TypedAttr TypedAttr instance Operands: Operand Description arg any type Results: Result Description result any type ll.func (::vast::ll::FuncOp) VAST function template Syntax: operation ::= `ll.func` $linkage $sym_name custom< FunctionSignatureAndBody >($function_type, attr-dict, $body) Inspired by cir::FuncOp and mlir::func::FuncOp : Operations within the function cannot implicitly capture values defined outside of the function, i.e. Functions are IsolatedFromAbove . All external references must use function arguments or attributes that establish a symbolic connection (e.g. symbols referenced by name via a string attribute like SymbolRefAttr). An external function declaration (used when referring to a function declared in some other module) has no body. The function linkage information is specified by linkage , as defined by GlobalLinkageKind attribute. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, RegionKindInterface, Symbol Attributes: Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::core::GlobalLinkageKindAttr global linkage kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes ll.gep (::vast::ll::StructGEPOp) VAST struct gep operation VAST struct gep operation Attributes: Attribute MLIR Type Description idx ::mlir::IntegerAttr 32-bit signless integer attribute name ::mlir::StringAttr string attribute Operands: Operand Description record any type Results: Result Description element any type ll.initialize (::vast::ll::InitializeVar) Initialize a variable. Syntax: operation ::= `ll.initialize` operands attr-dict `:` functional-type(operands, results) Initialize a variable - for now this operation is a direct lowering from hl.var initialization section. Later there will be need to discover how this ties to constructors. Operands: Operand Description var any type elements any type Results: Result Description result any type ll.inline_scope (::vast::ll::InlineScope) Scope, that forwards (cond)scope return up. Result of inlined if. Traits: NoRegionArguments ll.return (::vast::ll::ReturnOp) Syntax: operation ::= `ll.return` ($result^ `:` type($result))? attr-dict Traits: Terminator, return_trait Operands: Operand Description result any type ll.scope (::vast::ll::Scope) Scope, holds one region. Syntax: operation ::= `ll.scope` $body attr-dict Scope that holds one region, each block should be terminated with either branch, scope return or their conditional variants. Traits: NoRegionArguments ll.scope_recurse (::vast::ll::ScopeRecurse) Jump to first block of scope. Syntax: operation ::= `ll.scope_recurse` attr-dict Modelling continue. Traits: Terminator ll.scope_ret (::vast::ll::ScopeRet) Terminator of scope. Syntax: operation ::= `ll.scope_ret` attr-dict Terminator of scopes (for example during lowering of loops). Traits: Terminator ll.uninitialized_var (::vast::ll::UninitializedVar) Declaration of variable that have not been initialized yet. Syntax: operation ::= `ll.uninitialized_var` attr-dict `:` type($result) Declaration of variable that have not been initialized yet. Interfaces: VastSymbol Results: Result Description result any type","title":"LowLevel"},{"location":"dialects/LowLevel/LowLevel/#ll-dialect","text":"A vast low-level dialect. This dialect serves as a bottom layer in VAST dialect tower. There should always exist a pass that lowers this dialect into LLVM Dialect. Work in progress - new operations are still being added and existing can be changed or removed. 'll' Dialect Operation definition ll.br (::vast::ll::Br) Operands: Successors: ll.concat (::vast::ll::Concat) Operands: Results: ll.cond_br (::vast::ll::CondBr) Operands: Successors: ll.cond_scope_ret (::vast::ll::CondScopeRet) Operands: Successors: ll.extract (::vast::ll::Extract) Attributes: Operands: Results: ll.func (::vast::ll::FuncOp) Attributes: ll.gep (::vast::ll::StructGEPOp) Attributes: Operands: Results: ll.initialize (::vast::ll::InitializeVar) Operands: Results: ll.inline_scope (::vast::ll::InlineScope) ll.return (::vast::ll::ReturnOp) Operands: ll.scope (::vast::ll::Scope) ll.scope_recurse (::vast::ll::ScopeRecurse) ll.scope_ret (::vast::ll::ScopeRet) ll.uninitialized_var (::vast::ll::UninitializedVar) Results:","title":"'ll' Dialect"},{"location":"dialects/LowLevel/LowLevel/#operation-definition","text":"","title":"Operation definition"},{"location":"dialects/LowLevel/LowLevel/#llbr-vastllbr","text":"Direct branch. Syntax: operation ::= `ll.br` $dest (`(` $operands^ `:` type($operands) `)`)? attr-dict Direct branch Traits: Terminator Interfaces: BranchOpInterface","title":"ll.br (::vast::ll::Br)"},{"location":"dialects/LowLevel/LowLevel/#operands","text":"Operand Description operands any type","title":"Operands:"},{"location":"dialects/LowLevel/LowLevel/#successors","text":"Successor Description dest any successor","title":"Successors:"},{"location":"dialects/LowLevel/LowLevel/#llconcat-vastllconcat","text":"Concat integers together Syntax: operation ::= `ll.concat` operands attr-dict `:` functional-type(operands, results) Concat operands together, where first argument occupies lsb.","title":"ll.concat (::vast::ll::Concat)"},{"location":"dialects/LowLevel/LowLevel/#operands_1","text":"Operand Description args any type","title":"Operands:"},{"location":"dialects/LowLevel/LowLevel/#results","text":"Result Description result any type","title":"Results:"},{"location":"dialects/LowLevel/LowLevel/#llcond_br-vastllcondbr","text":"Conditional branch. Syntax: operation ::= `ll.cond_br` $cond `:` type($cond) `,` $trueDest (`(` $trueOperands^ `:` type($trueOperands) `)`)? `,` $falseDest (`(` $falseOperands^ `:` type($falseOperands) `)`)? attr-dict Direct branch Traits: AttrSizedOperandSegments, Terminator","title":"ll.cond_br (::vast::ll::CondBr)"},{"location":"dialects/LowLevel/LowLevel/#operands_2","text":"Operand Description cond any type trueOperands any type falseOperands any type","title":"Operands:"},{"location":"dialects/LowLevel/LowLevel/#successors_1","text":"Successor Description trueDest any successor falseDest any successor","title":"Successors:"},{"location":"dialects/LowLevel/LowLevel/#llcond_scope_ret-vastllcondscoperet","text":"Terminator of scope if condition is met, otherwise branch. Syntax: operation ::= `ll.cond_scope_ret` $cond `:` type($cond) `,` $dest (`(` $dest_operands^ `:` type($dest_operands) `)`)? attr-dict Terminate or branch. Traits: Terminator","title":"ll.cond_scope_ret (::vast::ll::CondScopeRet)"},{"location":"dialects/LowLevel/LowLevel/#operands_3","text":"Operand Description cond any type dest_operands any type","title":"Operands:"},{"location":"dialects/LowLevel/LowLevel/#successors_2","text":"Successor Description dest any successor","title":"Successors:"},{"location":"dialects/LowLevel/LowLevel/#llextract-vastllextract","text":"Extracts value Syntax: operation ::= `ll.extract` operands attr-dict `:` functional-type(operands, results) 0 is lsb, [inc, exc)","title":"ll.extract (::vast::ll::Extract)"},{"location":"dialects/LowLevel/LowLevel/#attributes","text":"Attribute MLIR Type Description from ::mlir::TypedAttr TypedAttr instance to ::mlir::TypedAttr TypedAttr instance","title":"Attributes:"},{"location":"dialects/LowLevel/LowLevel/#operands_4","text":"Operand Description arg any type","title":"Operands:"},{"location":"dialects/LowLevel/LowLevel/#results_1","text":"Result Description result any type","title":"Results:"},{"location":"dialects/LowLevel/LowLevel/#llfunc-vastllfuncop","text":"VAST function template Syntax: operation ::= `ll.func` $linkage $sym_name custom< FunctionSignatureAndBody >($function_type, attr-dict, $body) Inspired by cir::FuncOp and mlir::func::FuncOp : Operations within the function cannot implicitly capture values defined outside of the function, i.e. Functions are IsolatedFromAbove . All external references must use function arguments or attributes that establish a symbolic connection (e.g. symbols referenced by name via a string attribute like SymbolRefAttr). An external function declaration (used when referring to a function declared in some other module) has no body. The function linkage information is specified by linkage , as defined by GlobalLinkageKind attribute. Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator Interfaces: CallableOpInterface, FunctionOpInterface, RegionKindInterface, Symbol","title":"ll.func (::vast::ll::FuncOp)"},{"location":"dialects/LowLevel/LowLevel/#attributes_1","text":"Attribute MLIR Type Description sym_name ::mlir::StringAttr string attribute function_type ::mlir::TypeAttr type attribute of function type linkage ::vast::core::GlobalLinkageKindAttr global linkage kind sym_visibility ::mlir::StringAttr string attribute arg_attrs ::mlir::ArrayAttr Array of dictionary attributes res_attrs ::mlir::ArrayAttr Array of dictionary attributes","title":"Attributes:"},{"location":"dialects/LowLevel/LowLevel/#llgep-vastllstructgepop","text":"VAST struct gep operation VAST struct gep operation","title":"ll.gep (::vast::ll::StructGEPOp)"},{"location":"dialects/LowLevel/LowLevel/#attributes_2","text":"Attribute MLIR Type Description idx ::mlir::IntegerAttr 32-bit signless integer attribute name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"dialects/LowLevel/LowLevel/#operands_5","text":"Operand Description record any type","title":"Operands:"},{"location":"dialects/LowLevel/LowLevel/#results_2","text":"Result Description element any type","title":"Results:"},{"location":"dialects/LowLevel/LowLevel/#llinitialize-vastllinitializevar","text":"Initialize a variable. Syntax: operation ::= `ll.initialize` operands attr-dict `:` functional-type(operands, results) Initialize a variable - for now this operation is a direct lowering from hl.var initialization section. Later there will be need to discover how this ties to constructors.","title":"ll.initialize (::vast::ll::InitializeVar)"},{"location":"dialects/LowLevel/LowLevel/#operands_6","text":"Operand Description var any type elements any type","title":"Operands:"},{"location":"dialects/LowLevel/LowLevel/#results_3","text":"Result Description result any type","title":"Results:"},{"location":"dialects/LowLevel/LowLevel/#llinline_scope-vastllinlinescope","text":"Scope, that forwards (cond)scope return up. Result of inlined if. Traits: NoRegionArguments","title":"ll.inline_scope (::vast::ll::InlineScope)"},{"location":"dialects/LowLevel/LowLevel/#llreturn-vastllreturnop","text":"Syntax: operation ::= `ll.return` ($result^ `:` type($result))? attr-dict Traits: Terminator, return_trait","title":"ll.return (::vast::ll::ReturnOp)"},{"location":"dialects/LowLevel/LowLevel/#operands_7","text":"Operand Description result any type","title":"Operands:"},{"location":"dialects/LowLevel/LowLevel/#llscope-vastllscope","text":"Scope, holds one region. Syntax: operation ::= `ll.scope` $body attr-dict Scope that holds one region, each block should be terminated with either branch, scope return or their conditional variants. Traits: NoRegionArguments","title":"ll.scope (::vast::ll::Scope)"},{"location":"dialects/LowLevel/LowLevel/#llscope_recurse-vastllscoperecurse","text":"Jump to first block of scope. Syntax: operation ::= `ll.scope_recurse` attr-dict Modelling continue. Traits: Terminator","title":"ll.scope_recurse (::vast::ll::ScopeRecurse)"},{"location":"dialects/LowLevel/LowLevel/#llscope_ret-vastllscoperet","text":"Terminator of scope. Syntax: operation ::= `ll.scope_ret` attr-dict Terminator of scopes (for example during lowering of loops). Traits: Terminator","title":"ll.scope_ret (::vast::ll::ScopeRet)"},{"location":"dialects/LowLevel/LowLevel/#lluninitialized_var-vastlluninitializedvar","text":"Declaration of variable that have not been initialized yet. Syntax: operation ::= `ll.uninitialized_var` attr-dict `:` type($result) Declaration of variable that have not been initialized yet. Interfaces: VastSymbol","title":"ll.uninitialized_var (::vast::ll::UninitializedVar)"},{"location":"dialects/LowLevel/LowLevel/#results_4","text":"Result Description result any type","title":"Results:"},{"location":"dialects/Meta/Meta/","text":"'meta' Dialect A vast metadata dialect. This dialect intends capture user metadata that are kept accross transformations. 'meta' Dialect Attribute definition IdentifierAttr Parameters: Attribute definition IdentifierAttr A metadata identifier. Syntax: #meta.id< identifier_t # value > A metadata identifier can be used to relate operations to external metadata storage. #meta.id<\"0x3A28213A\"> Parameters: Parameter C++ type Description value identifier_t","title":"Meta"},{"location":"dialects/Meta/Meta/#meta-dialect","text":"A vast metadata dialect. This dialect intends capture user metadata that are kept accross transformations. 'meta' Dialect Attribute definition IdentifierAttr Parameters:","title":"'meta' Dialect"},{"location":"dialects/Meta/Meta/#attribute-definition","text":"","title":"Attribute definition"},{"location":"dialects/Meta/Meta/#identifierattr","text":"A metadata identifier. Syntax: #meta.id< identifier_t # value > A metadata identifier can be used to relate operations to external metadata storage. #meta.id<\"0x3A28213A\">","title":"IdentifierAttr"},{"location":"dialects/Meta/Meta/#parameters","text":"Parameter C++ type Description value identifier_t","title":"Parameters:"},{"location":"dialects/Unsupported/Unsupported/","text":"'unsup' Dialect A vast unsupported dialect. This dialect defines a set of generic unsupported operation/types that can be used to lower AST Node that are yet not supported and can't be lowered by other dialects. 'unsup' Dialect Operation definition unsup.decl (::vast::unsup::UnsupportedDecl) Attributes: unsup.stmt (::vast::unsup::UnsupportedStmt) Attributes: Results: Attribute definition UnsupportedAttr Parameters: Type definition UnsupportedType Parameters: Operation definition unsup.decl (::vast::unsup::UnsupportedDecl) VAST unsupported decl Syntax: operation ::= `unsup.decl` $name attr-dict `:` $body VAST unsupported decl Traits: NoTerminator Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute unsup.stmt (::vast::unsup::UnsupportedStmt) VAST unsupported statement Syntax: operation ::= `unsup.stmt` $name attr-dict `:` type($result) $children VAST unsupported statement Traits: NoTerminator Attributes: Attribute MLIR Type Description name ::mlir::StringAttr string attribute Results: Result Description result any type Attribute definition UnsupportedAttr Syntax: #unsup.attr< ::mlir::StringAttr # spelling > Parameters: Parameter C++ type Description spelling ::mlir::StringAttr Type definition UnsupportedType Syntax: !unsup.type< ::llvm::StringRef # originName > Parameters: Parameter C++ type Description originName ::llvm::StringRef","title":"Unsupported"},{"location":"dialects/Unsupported/Unsupported/#unsup-dialect","text":"A vast unsupported dialect. This dialect defines a set of generic unsupported operation/types that can be used to lower AST Node that are yet not supported and can't be lowered by other dialects. 'unsup' Dialect Operation definition unsup.decl (::vast::unsup::UnsupportedDecl) Attributes: unsup.stmt (::vast::unsup::UnsupportedStmt) Attributes: Results: Attribute definition UnsupportedAttr Parameters: Type definition UnsupportedType Parameters:","title":"'unsup' Dialect"},{"location":"dialects/Unsupported/Unsupported/#operation-definition","text":"","title":"Operation definition"},{"location":"dialects/Unsupported/Unsupported/#unsupdecl-vastunsupunsupporteddecl","text":"VAST unsupported decl Syntax: operation ::= `unsup.decl` $name attr-dict `:` $body VAST unsupported decl Traits: NoTerminator","title":"unsup.decl (::vast::unsup::UnsupportedDecl)"},{"location":"dialects/Unsupported/Unsupported/#attributes","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"dialects/Unsupported/Unsupported/#unsupstmt-vastunsupunsupportedstmt","text":"VAST unsupported statement Syntax: operation ::= `unsup.stmt` $name attr-dict `:` type($result) $children VAST unsupported statement Traits: NoTerminator","title":"unsup.stmt (::vast::unsup::UnsupportedStmt)"},{"location":"dialects/Unsupported/Unsupported/#attributes_1","text":"Attribute MLIR Type Description name ::mlir::StringAttr string attribute","title":"Attributes:"},{"location":"dialects/Unsupported/Unsupported/#results","text":"Result Description result any type","title":"Results:"},{"location":"dialects/Unsupported/Unsupported/#attribute-definition","text":"","title":"Attribute definition"},{"location":"dialects/Unsupported/Unsupported/#unsupportedattr","text":"Syntax: #unsup.attr< ::mlir::StringAttr # spelling >","title":"UnsupportedAttr"},{"location":"dialects/Unsupported/Unsupported/#parameters","text":"Parameter C++ type Description spelling ::mlir::StringAttr","title":"Parameters:"},{"location":"dialects/Unsupported/Unsupported/#type-definition","text":"","title":"Type definition"},{"location":"dialects/Unsupported/Unsupported/#unsupportedtype","text":"Syntax: !unsup.type< ::llvm::StringRef # originName >","title":"UnsupportedType"},{"location":"dialects/Unsupported/Unsupported/#parameters_1","text":"Parameter C++ type Description originName ::llvm::StringRef","title":"Parameters:"}]}